###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\EIE_TEXT\二进制计数器\firmware_common\drivers\leds.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\leds.c -D EIE_ASCII
#        --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\leds.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\leds.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\leds.c
      1          /*!**********************************************************************************************************************
      2          @file leds.c                                                                
      3          @brief LED driver and API
      4          
      5          This driver provides on, off, toggle, and blink functionality.
      6          The basic on/off/toggle functionality is applied directly to the LEDs.
      7          Blinking of LEDs rely on the EIE operating system to provide timing at
      8          regular 1ms calls to LedSM_Idle().
      9          
     10          ------------------------------------------------------------------------------------------------------------------------
     11          GLOBALS
     12          - NONE
     13          
     14          CONSTANTS
     15          - NONE
     16          
     17          TYPES
     18          - LedNameType (devboard-specific)
     19          
     20           (from eief1-pcb-01):
     21           {WHITE, PURPLE, BLUE, CYAN, 
     22            GREEN, YELLOW, ORANGE, RED, 
     23            LCD_RED, LCD_GREEN, LCD_BLUE}
     24          
     25           (from mpgl2-ehdw-02):
     26           {RED0,   RED1,   RED2,   RED3, 
     27            GREEN0, GREEN1, GREEN2, GREEN3, 
     28            BLUE0,  BLUE1,  BLUE2,  BLUE3}
     29          
     30          
     31          - LedRateType:
     32            {LED_0HZ = 0, LED_0_5HZ = 1000, LED_1HZ = 500, LED_2HZ = 250, LED_4HZ = 125, LED_8HZ = 63,
     33             LED_PWM_0 = 0,   LED_PWM_5 = 1,   LED_PWM_10 = 2,  LED_PWM_15 = 3,  LED_PWM_20 = 4, 
     34             LED_PWM_25 = 5,  LED_PWM_30 = 6,  LED_PWM_35 = 7,  LED_PWM_40 = 8,  LED_PWM_45 = 9, 
     35             LED_PWM_50 = 10, LED_PWM_55 = 11, LED_PWM_60 = 12, LED_PWM_65 = 13, LED_PWM_70 = 14, 
     36             LED_PWM_75 = 15, LED_PWM_80 = 16, LED_PWM_85 = 17, LED_PWM_90 = 18, LED_PWM_95 = 19, 
     37             LED_PWM_100 = 20} 
     38          
     39          PUBLIC FUNCTIONS
     40          - void LedOn(LedNameType eLED_)
     41          - void LedOff(LedNameType eLED_)
     42          - void LedToggle(LedNameType eLED_)
     43          - void LedBlink(LedNameType eLED_, LedRateType eBlinkRate_)
     44          - void LedPWM(LedNameType eLED_, LedRateType ePwmRate_)
     45          
     46          PROTECTED FUNCTIONS
     47          - void LedInitialize(void)
     48          - void LedRunActiveState(void)
     49          
     50          ***********************************************************************************************************************/
     51          
     52          #include "configuration.h"
     53          
     54          
     55          /***********************************************************************************************************************
     56          Global variable definitions with scope across entire project.
     57          All Global variable names shall start with "G_<type>Led"
     58          ***********************************************************************************************************************/
     59          /*--------------------------------------------------------------------------------------------------------------------*/
     60          /* New variables (all shall start with G_xxLed*/
     61          
     62          
     63          /*--------------------------------------------------------------------------------------------------------------------*/
     64          /* External global variables defined in other files (must indicate which file they are defined in) */
     65          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     66          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     67          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     68          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
     69          
     70          extern const PinConfigurationType G_asBspLedConfigurations[U8_TOTAL_LEDS]; /*!< @brief from board-specific file */
     71          
     72          
     73          /***********************************************************************************************************************
     74          Global variable definitions with scope limited to this local application.
     75          Variable names shall start with "Led_<type>" and be declared as static.
     76          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     77          static fnCode_type Led_StateMachine;                   /*!< @brief The state machine function pointer */
   \                     Led_StateMachine:
   \   00000000                      DS8 4
     78          //static u32 Led_u32Timeout;                             /*!< @brief Timeout counter used across states */
     79          

   \                                 In section .bss, align 4
     80          static LedControlType Led_asControl[U8_TOTAL_LEDS];    /*!< @brief Holds individual control parameters for LEDs */
   \                     Led_asControl:
   \   00000000                      DS8 88
     81          
     82          
     83          /**********************************************************************************************************************
     84          Function Definitions
     85          **********************************************************************************************************************/
     86          
     87          /*--------------------------------------------------------------------------------------------------------------------*/
     88          /*! @publicsection */                                                                                            
     89          /*--------------------------------------------------------------------------------------------------------------------*/
     90          
     91          /*!----------------------------------------------------------------------------------------------------------------------
     92          @fn void LedOn(LedNameType eLED_)
     93          
     94          @brief Turn the specified LED on.  
     95          
     96          This function automatically takes care of the active low vs. active high LEDs.
     97          The function works immediately (it does not require the main application
     98          loop to be running). 
     99          
    100          Currently it only supports one LED at a time.
    101          
    102          Example:
    103          
    104          LedOn(BLUE);
    105          
    106          
    107          Requires:
    108          - Definitions in G_asBspLedConfigurations[eLED_] and Led_asControl[eLED_] are correct
    109          
    110          @param eLED_ is a valid LED index
    111          
    112          Promises:
    113          - eLED_ is turned on 
    114          - eLED_ is set to LED_NORMAL_MODE mode
    115          
    116          */

   \                                 In section .text, align 2, keep-with-next
    117          void LedOn(LedNameType eLED_)
    118          {
    119            u32 *pu32OnAddress;
    120          
    121            /* Configure set and clear addresses */
    122            if(G_asBspLedConfigurations[eLED_].eActiveState == ACTIVE_HIGH)
   \                     LedOn: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable7
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000000A   0x7952             LDRB     R2,[R2, #+5]
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xD10B             BNE.N    ??LedOn_0
    123            {
    124              /* Active high LEDs use SODR to turn on */
    125              pu32OnAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + G_asBspLedConfigurations[(u8)eLED_].ePort);
   \   00000010   0x.... 0x....      LDR.W    R2,??DataTable7_1  ;; 0x400e0c30
   \   00000014   0x.... 0x....      LDR.W    R3,??DataTable7
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   0000001E   0x791B             LDRB     R3,[R3, #+4]
   \   00000020   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   00000024   0x0011             MOVS     R1,R2
   \   00000026   0xE00A             B.N      ??LedOn_1
    126            }
    127            else
    128            {
    129              /* Active low LEDs use CODR to turn on */
    130              pu32OnAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + G_asBspLedConfigurations[(u8)eLED_].ePort);
   \                     ??LedOn_0: (+1)
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable7_2  ;; 0x400e0c34
   \   0000002C   0x.... 0x....      LDR.W    R3,??DataTable7
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   00000036   0x791B             LDRB     R3,[R3, #+4]
   \   00000038   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   0000003C   0x0011             MOVS     R1,R2
    131            }
    132            
    133            /* Turn on the LED */
    134            *pu32OnAddress = G_asBspLedConfigurations[(u8)eLED_].u32BitPosition;
   \                     ??LedOn_1: (+1)
   \   0000003E   0x....             LDR.N    R2,??DataTable7
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0xF852 0x2030      LDR      R2,[R2, R0, LSL #+3]
   \   00000046   0x600A             STR      R2,[R1, #+0]
    135            
    136            /* Always set the LED back to LED_NORMAL_MODE mode */
    137          	Led_asControl[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0x....             LDR.N    R3,??DataTable7_3
   \   0000004C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000004E   0xF803 0x2030      STRB     R2,[R3, R0, LSL #+3]
    138          
    139          } /* end LedOn() */
   \   00000052   0x4770             BX       LR               ;; return
    140          
    141          
    142          /*!----------------------------------------------------------------------------------------------------------------------
    143          @fn void LedOff(LedNameType eLED_)
    144          
    145          @brief Turn the specified LED off.
    146          
    147          This function automatically takes care of the active low vs. active high LEDs.
    148          It works immediately (it does not require the main application
    149          loop to be running). 
    150          
    151          Currently it only supports one LED at a time.
    152          
    153          Example:
    154          
    155          LedOff(BLUE);
    156          
    157          
    158          Requires:
    159          - Definitions in G_asBspLedConfigurations[eLED_] and Led_asControl[eLED_] are correct
    160          
    161          @param eLED_ is a valid LED index
    162          
    163          Promises:
    164          - eLED_ is turned off 
    165          - eLED_ is set to LED_NORMAL_MODE mode
    166          
    167          */

   \                                 In section .text, align 2, keep-with-next
    168          void LedOff(LedNameType eLED_)
    169          {
    170            u32 *pu32OffAddress;
    171          
    172            /* Configure set and clear addresses */
    173            if(G_asBspLedConfigurations[(u8)eLED_].eActiveState == ACTIVE_HIGH)
   \                     LedOff: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000008   0x7952             LDRB     R2,[R2, #+5]
   \   0000000A   0x2A01             CMP      R2,#+1
   \   0000000C   0xD109             BNE.N    ??LedOff_0
    174            {
    175              /* Active high LEDs use CODR to turn off */
    176              pu32OffAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_CODR) + G_asBspLedConfigurations[(u8)eLED_].ePort);
   \   0000000E   0x....             LDR.N    R2,??DataTable7_2  ;; 0x400e0c34
   \   00000010   0x....             LDR.N    R3,??DataTable7
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   00000018   0x791B             LDRB     R3,[R3, #+4]
   \   0000001A   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   0000001E   0x0011             MOVS     R1,R2
   \   00000020   0xE008             B.N      ??LedOff_1
    177            }
    178            else
    179            {
    180              /* Active low LEDs use SODR to turn off */
    181              pu32OffAddress = (u32*)(&(AT91C_BASE_PIOA->PIO_SODR) + G_asBspLedConfigurations[(u8)eLED_].ePort);
   \                     ??LedOff_0: (+1)
   \   00000022   0x....             LDR.N    R2,??DataTable7_1  ;; 0x400e0c30
   \   00000024   0x....             LDR.N    R3,??DataTable7
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   0000002C   0x791B             LDRB     R3,[R3, #+4]
   \   0000002E   0xEB12 0x0283      ADDS     R2,R2,R3, LSL #+2
   \   00000032   0x0011             MOVS     R1,R2
    182            }
    183            
    184            /* Clear the bit corresponding to eLED_ */
    185          	*pu32OffAddress = G_asBspLedConfigurations[(u8)eLED_].u32BitPosition;
   \                     ??LedOff_1: (+1)
   \   00000034   0x....             LDR.N    R2,??DataTable7
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xF852 0x2030      LDR      R2,[R2, R0, LSL #+3]
   \   0000003C   0x600A             STR      R2,[R1, #+0]
    186          
    187            /* Always set the LED back to LED_NORMAL_MODE mode */
    188          	Led_asControl[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x....             LDR.N    R3,??DataTable7_3
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0xF803 0x2030      STRB     R2,[R3, R0, LSL #+3]
    189            
    190          } /* end LedOff() */
   \   00000048   0x4770             BX       LR               ;; return
    191          
    192          
    193          /*!----------------------------------------------------------------------------------------------------------------------
    194          @fn void LedToggle(LedNameType eLED_)
    195          
    196          @brief Toggles the specified LED from on to off or vise-versa.
    197          
    198          This function automatically takes care of the active low vs. active high LEDs.
    199          It works immediately (it does not require the main application
    200          loop to be running). 
    201          
    202          Currently it only supports one LED at a time.
    203          
    204          Example:
    205          
    206          LedToggle(BLUE);
    207          
    208          
    209          Requires:
    210          - Write access to PIOx_ODSR is enabled
    211          
    212          @param eLED_ is a valid LED index
    213          
    214          Promises:
    215          - eLED_ is toggled 
    216          - eLED_ is set to LED_NORMAL_MODE
    217          
    218          */

   \                                 In section .text, align 2, keep-with-next
    219          void LedToggle(LedNameType eLED_)
    220          {
    221            u32* pu32Address = (u32*)(&(AT91C_BASE_PIOA->PIO_ODSR) + G_asBspLedConfigurations[eLED_].ePort);
   \                     LedToggle: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_4  ;; 0x400e0c38
   \   00000002   0x....             LDR.N    R2,??DataTable7
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000000A   0x7912             LDRB     R2,[R2, #+4]
   \   0000000C   0xEB11 0x0182      ADDS     R1,R1,R2, LSL #+2
    222          
    223            *pu32Address ^= G_asBspLedConfigurations[(u8)eLED_].u32BitPosition;
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x....             LDR.N    R3,??DataTable7
   \   00000014   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000016   0xF853 0x3030      LDR      R3,[R3, R0, LSL #+3]
   \   0000001A   0x405A             EORS     R2,R3,R2
   \   0000001C   0x600A             STR      R2,[R1, #+0]
    224            
    225            /* Set the LED to LED_NORMAL_MODE mode */
    226          	Led_asControl[(u8)eLED_].eMode = LED_NORMAL_MODE;
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x....             LDR.N    R3,??DataTable7_3
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xF803 0x2030      STRB     R2,[R3, R0, LSL #+3]
    227          
    228          } /* end LedToggle() */
   \   00000028   0x4770             BX       LR               ;; return
    229          
    230          
    231          /*!----------------------------------------------------------------------------------------------------------------------
    232          @fn void LedBlink(LedNameType eLED_, LedRateType eBlinkRate_)
    233          
    234          @brief Sets eLED_ to BLINK mode with the rate given.
    235          
    236          BLINK mode requires the main loop to be running at 1ms period. If the main
    237          loop timing is regularly off, the blinking timing may be affected although
    238          unlikely to a noticeable degree.  
    239          
    240          Example to blink the PURPLE LED at 1Hz:
    241          
    242          LedBlink(PURPLE, LED_1HZ);
    243          
    244          
    245          Requires:
    246          @param eLED_ is a valid LED index
    247          @param eBlinkRate_ is an allowed blinking rate from LedRateType
    248          
    249          Promises:
    250          - eLED_ is set to LED_BLINK_MODE at the blink rate specified
    251          
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          void LedBlink(LedNameType eLED_, LedRateType eBlinkRate_)
    254          {
    255          	Led_asControl[(u8)eLED_].eMode = LED_BLINK_MODE;
   \                     LedBlink: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             LDR.N    R3,??DataTable7_3
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xF803 0x2030      STRB     R2,[R3, R0, LSL #+3]
    256          	Led_asControl[(u8)eLED_].eRate = eBlinkRate_;
   \   0000000A   0x....             LDR.N    R2,??DataTable7_3
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000012   0x8051             STRH     R1,[R2, #+2]
    257          	Led_asControl[(u8)eLED_].u16Count = eBlinkRate_;
   \   00000014   0x....             LDR.N    R2,??DataTable7_3
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000001C   0x8091             STRH     R1,[R2, #+4]
    258          
    259          } /* end LedBlink() */
   \   0000001E   0x4770             BX       LR               ;; return
    260          
    261          
    262          /*!----------------------------------------------------------------------------------------------------------------------
    263          @fn void LedPWM(LedNameType eLED_, LedRateType ePwmRate_)
    264          
    265          @brief Sets an LED to PWM mode with the rate given.
    266          
    267          The PWM output is bit-bashed based on the 1ms system timing.  Therefore,
    268          PWM mode requires the main loop to be running properly. If the main 
    269          loop timing is longer than 1ms, noticeable glitches will be observed
    270          in the PWM signal to the LED.  Even if all applications are working properly,
    271          there still may be some jitter due to applications taking processor time.
    272          
    273          Use LedOff(eLED_) to stop PWM mode and return to NORMAL mode.
    274          
    275          Example to turn on the BLUE LED with 5% duty cycle:
    276          
    277          LedPWM(BLUE, LED_PWM_5);
    278          
    279          
    280          Requires:
    281          @param eLED_ is a valid LED index
    282          @param ePwmRate_ is an allowed duty cycle - use a PWM value from LedRateType
    283          
    284          Promises:
    285          - eLED_ is set to PWM mode at the duty cycle rate specified
    286          
    287          */

   \                                 In section .text, align 2, keep-with-next
    288          void LedPWM(LedNameType eLED_, LedRateType ePwmRate_)
    289          {
    290            Led_asControl[(u8)eLED_].eMode = LED_PWM_MODE;
   \                     LedPWM: (+1)
   \   00000000   0x2202             MOVS     R2,#+2
   \   00000002   0x....             LDR.N    R3,??DataTable7_3
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0xF803 0x2030      STRB     R2,[R3, R0, LSL #+3]
    291            Led_asControl[(u8)eLED_].eRate = ePwmRate_;
   \   0000000A   0x....             LDR.N    R2,??DataTable7_3
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   00000012   0x8051             STRH     R1,[R2, #+2]
    292            Led_asControl[(u8)eLED_].u16Count = (u16)ePwmRate_;
   \   00000014   0x....             LDR.N    R2,??DataTable7_3
   \   00000016   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000018   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000001C   0x8091             STRH     R1,[R2, #+4]
    293            Led_asControl[(u8)eLED_].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x....             LDR.N    R3,??DataTable7_3
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0xEB13 0x03C0      ADDS     R3,R3,R0, LSL #+3
   \   00000028   0x719A             STRB     R2,[R3, #+6]
    294          
    295          } /* end LedPWM() */
   \   0000002A   0x4770             BX       LR               ;; return
    296          
    297          
    298          /*--------------------------------------------------------------------------------------------------------------------*/
    299          /*! @protectedsection */                                                                                            
    300          /*--------------------------------------------------------------------------------------------------------------------*/
    301          
    302          #ifdef EIE_ASCII
    303          /*!----------------------------------------------------------------------------------------------------------------------
    304          @fn void LedInitialize(void)
    305          
    306          @brief Initialization of LED system parameters and visual LED check.
    307          
    308          
    309          Requires:
    310          - 
    311          
    312          Promises:
    313          - Led_asControl is initialized (all LEDs in LED_NORMAL_MODE)
    314          
    315          */

   \                                 In section .text, align 2, keep-with-next
    316          void LedInitialize(void)
    317          {
   \                     LedInitialize: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
    318            u32 u32Timer;
    319            u8  u8Index;
    320          
    321            u32 u32Buzzer1Frequency = 4000;
   \   00000006   0xF44F 0x657A      MOV      R5,#+4000
    322            u32 u32Buzzer2Frequency = 500;
   \   0000000A   0xF44F 0x76FA      MOV      R6,#+500
    323            u32 u32StepSize = (u32Buzzer1Frequency - u32Buzzer2Frequency) / 20;
   \   0000000E   0x1BA8             SUBS     R0,R5,R6
   \   00000010   0x2114             MOVS     R1,#+20
   \   00000012   0xFBB0 0xF7F1      UDIV     R7,R0,R1
    324          
    325            /* Initialize the LED control array */
    326            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
   \   00000016   0xF05F 0x0800      MOVS     R8,#+0
   \                     ??LedInitialize_0: (+1)
   \   0000001A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000001E   0xF1B8 0x0F0B      CMP      R8,#+11
   \   00000022   0xDA07             BGE.N    ??LedInitialize_1
    327            {
    328              LedPWM( (LedNameType)i, LED_PWM_100);
   \   00000024   0x2114             MOVS     R1,#+20
   \   00000026   0x4640             MOV      R0,R8
   \   00000028   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002A   0x.... 0x....      BL       LedPWM
    329            }
   \   0000002E   0xF118 0x0801      ADDS     R8,R8,#+1
   \   00000032   0xE7F2             B.N      ??LedInitialize_0
    330            
    331            /* Fade the LEDS out */
    332            for(u8Index = 20; u8Index > 0; u8Index--)
   \                     ??LedInitialize_1: (+1)
   \   00000034   0x2014             MOVS     R0,#+20
   \   00000036   0x0004             MOVS     R4,R0
   \                     ??LedInitialize_2: (+1)
   \   00000038   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003A   0x2C00             CMP      R4,#+0
   \   0000003C   0xD02E             BEQ.N    ??LedInitialize_3
    333            {
    334          #ifdef STARTUP_SOUND
    335              /* Configure Buzzers to provide some audio during start up */
    336              PWMAudioSetFrequency(BUZZER1, u32Buzzer1Frequency);
    337              PWMAudioOn(BUZZER1);
    338              PWMAudioSetFrequency(BUZZER2, u32Buzzer2Frequency);
    339              PWMAudioOn(BUZZER2);
    340          #endif /* STARTUP_SOUND */
    341              
    342              /* Spend a little bit of time in each level of intensity */
    343              for(u16 j = 20; j > 0; j--)
   \   0000003E   0xF05F 0x0814      MOVS     R8,#+20
   \                     ??LedInitialize_4: (+1)
   \   00000042   0xFA1F 0xF888      UXTH     R8,R8            ;; ZeroExt  R8,R8,#+16,#+16
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD00D             BEQ.N    ??LedInitialize_5
    344              {
    345                u32Timer = G_u32SystemTime1ms;
   \   0000004C   0x....             LDR.N    R0,??DataTable7_5
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x9000             STR      R0,[SP, #+0]
    346                while( !IsTimeUp(&u32Timer, 1) );
   \                     ??LedInitialize_6: (+1)
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       IsTimeUp
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD0F9             BEQ.N    ??LedInitialize_6
    347                LedSM_Idle();
   \   0000005E   0x.... 0x....      BL       LedSM_Idle
    348              }
   \   00000062   0xF1B8 0x0801      SUBS     R8,R8,#+1
   \   00000066   0xE7EC             B.N      ??LedInitialize_4
    349              /* Pause for a bit on the first iteration to show the LEDs on for little while */
    350              if(u8Index == 20)
   \                     ??LedInitialize_5: (+1)
   \   00000068   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000006A   0x2C14             CMP      R4,#+20
   \   0000006C   0xD105             BNE.N    ??LedInitialize_7
    351              {
    352                while( !IsTimeUp(&u32Timer, 200) );
   \                     ??LedInitialize_8: (+1)
   \   0000006E   0x21C8             MOVS     R1,#+200
   \   00000070   0xA800             ADD      R0,SP,#+0
   \   00000072   0x.... 0x....      BL       IsTimeUp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD0F9             BEQ.N    ??LedInitialize_8
    353              }
    354              
    355              /* Set the LED intensity for the next iteration */
    356              for(u8 j = 0; j < U8_TOTAL_LEDS; j++)
   \                     ??LedInitialize_7: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??LedInitialize_9: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x280B             CMP      R0,#+11
   \   00000080   0xDA08             BGE.N    ??LedInitialize_10
    357              {
    358                Led_asControl[j].eRate = (LedRateType)(u8Index - 1);
   \   00000082   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000084   0x1E61             SUBS     R1,R4,#+1
   \   00000086   0x....             LDR.N    R2,??DataTable7_3
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   0000008E   0x8051             STRH     R1,[R2, #+2]
    359              }
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0xE7F3             B.N      ??LedInitialize_9
    360              
    361              /* Set the buzzer frequency for the next iteration */
    362              u32Buzzer1Frequency -= u32StepSize;
   \                     ??LedInitialize_10: (+1)
   \   00000094   0x1BED             SUBS     R5,R5,R7
    363              u32Buzzer2Frequency += u32StepSize;
   \   00000096   0x19BE             ADDS     R6,R7,R6
    364            }
   \   00000098   0x1E64             SUBS     R4,R4,#+1
   \   0000009A   0xE7CD             B.N      ??LedInitialize_2
    365          
    366            /* Final update to set last state, hold for a short period */
    367            LedSM_Idle();
   \                     ??LedInitialize_3: (+1)
   \   0000009C   0x.... 0x....      BL       LedSM_Idle
    368            while( !IsTimeUp(&u32Timer, 200) );
   \                     ??LedInitialize_11: (+1)
   \   000000A0   0x21C8             MOVS     R1,#+200
   \   000000A2   0xA800             ADD      R0,SP,#+0
   \   000000A4   0x.... 0x....      BL       IsTimeUp
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD0F9             BEQ.N    ??LedInitialize_11
    369            
    370          #ifdef STARTUP_SOUND
    371            /* Turn off the buzzers */
    372            PWMAudioOff(BUZZER1);
    373            PWMAudioOff(BUZZER2);
    374          #endif /* STARTUP_SOUND */
    375           
    376          
    377            /* Initialize the LED control array */
    378            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
   \   000000AC   0x2000             MOVS     R0,#+0
   \                     ??LedInitialize_12: (+1)
   \   000000AE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B0   0x280B             CMP      R0,#+11
   \   000000B2   0xDA18             BGE.N    ??LedInitialize_13
    379            {
    380              Led_asControl[i].eMode = LED_NORMAL_MODE;
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x....             LDR.N    R2,??DataTable7_3
   \   000000B8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000BA   0xF802 0x1030      STRB     R1,[R2, R0, LSL #+3]
    381              Led_asControl[i].eRate = LED_0HZ;
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x....             LDR.N    R2,??DataTable7_3
   \   000000C2   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C4   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000C8   0x8051             STRH     R1,[R2, #+2]
    382              Led_asControl[i].u16Count = 0;
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x....             LDR.N    R2,??DataTable7_3
   \   000000CE   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D0   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000D4   0x8091             STRH     R1,[R2, #+4]
    383              Led_asControl[i].eCurrentDuty = LED_PWM_DUTY_LOW;
   \   000000D6   0x2100             MOVS     R1,#+0
   \   000000D8   0x....             LDR.N    R2,??DataTable7_3
   \   000000DA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000DC   0xEB12 0x02C0      ADDS     R2,R2,R0, LSL #+3
   \   000000E0   0x7191             STRB     R1,[R2, #+6]
    384            }
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0xE7E3             B.N      ??LedInitialize_12
    385          
    386            /* Backlight on and white */
    387            LedOn(LCD_RED);
   \                     ??LedInitialize_13: (+1)
   \   000000E6   0x2008             MOVS     R0,#+8
   \   000000E8   0x.... 0x....      BL       LedOn
    388            LedOn(LCD_GREEN);
   \   000000EC   0x2009             MOVS     R0,#+9
   \   000000EE   0x.... 0x....      BL       LedOn
    389            LedOn(LCD_BLUE);
   \   000000F2   0x200A             MOVS     R0,#+10
   \   000000F4   0x.... 0x....      BL       LedOn
    390          
    391            /* If good initialization, set state to Idle */
    392            if( 1 )
    393            {
    394              /* Final setup and report that LED system is ready */
    395              G_u32ApplicationFlags |= _APPLICATION_FLAGS_LED;
   \   000000F8   0x....             LDR.N    R0,??DataTable7_6
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000100   0x....             LDR.N    R1,??DataTable7_6
   \   00000102   0x6008             STR      R0,[R1, #+0]
    396              DebugPrintf("LED functions ready\n\r");
   \   00000104   0x....             LDR.N    R0,??DataTable7_7
   \   00000106   0x.... 0x....      BL       DebugPrintf
    397              Led_StateMachine = LedSM_Idle;
   \   0000010A   0x.... 0x....      ADR.W    R0,LedSM_Idle
   \   0000010E   0x....             LDR.N    R1,??DataTable7_8
   \   00000110   0x6008             STR      R0,[R1, #+0]
    398            }
    399            else
    400            {
    401              /* The task isn't properly initialized, so shut it down and don't run */
    402              Led_StateMachine = LedSM_Error;
    403            }
    404            
    405          } /* end LedInitialize() */
   \   00000112   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
    406          #endif /* EIE_ASCII */
    407          
    408          
    409          #ifdef EIE_DOTMATRIX
    410          /*!----------------------------------------------------------------------------------------------------------------------
    411          @fn void LedInitialize(void)
    412          
    413          @brief Initialization of LED system parameters and visual LED check.
    414          
    415          
    416          Requires:
    417          - 
    418          
    419          Promises:
    420          - Led_asControl is initialized (all LEDs in LED_NORMAL_MODE)
    421          
    422          */
    423          void LedInitialize(void)
    424          {
    425            u32 u32Timer;
    426            u8  u8Index;
    427          
    428            u32 u32Buzzer1Frequency = 4000;
    429            u32 u32StepSize = u32Buzzer1Frequency / 20;
    430          
    431            /* Initialize the LED control array */
    432            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
    433            {
    434              LedPWM( (LedNameType)i, LED_PWM_100);
    435            }
    436            
    437            /* Fade the LEDS out */
    438            for(u8Index = 20; u8Index > 0; u8Index--)
    439            {
    440          #ifdef STARTUP_SOUND
    441              /* Configure Buzzers to provide some audio during start up */
    442              PWMAudioSetFrequency(BUZZER1, u32Buzzer1Frequency);
    443              PWMAudioOn(BUZZER1);
    444          #endif /* STARTUP_SOUND */
    445              
    446              /* Spend a little bit of time in each level of intensity */
    447              for(u16 j = 20; j > 0; j--)
    448              {
    449                u32Timer = G_u32SystemTime1ms;
    450                while( !IsTimeUp(&u32Timer, 1) );
    451                LedSM_Idle();
    452              }
    453              /* Pause for a bit on the first iteration to show the LEDs on for little while */
    454              if(u8Index == 20)
    455              {
    456                while( !IsTimeUp(&u32Timer, 200) );
    457              }
    458              
    459              /* Set the LED intensity for the next iteration */
    460              for(u8 j = 0; j < U8_TOTAL_LEDS; j++)
    461              {
    462                Led_asControl[j].eRate = (LedRateType)(u8Index - 1);
    463              }
    464              
    465              /* Set the buzzer frequency for the next iteration */
    466              u32Buzzer1Frequency -= u32StepSize;
    467            }
    468          
    469            /* Final update to set last state, hold for a short period */
    470            LedSM_Idle();
    471            while( !IsTimeUp(&u32Timer, 200) );
    472            
    473          #ifdef STARTUP_SOUND
    474            /* Turn off the buzzers */
    475            PWMAudioOff(BUZZER1);
    476          #endif /* STARTUP_SOUND */
    477           
    478          
    479            /* Initialize the LED control array */
    480            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
    481            {
    482              Led_asControl[i].eMode = LED_NORMAL_MODE;
    483              Led_asControl[i].eRate = LED_0HZ;
    484              Led_asControl[i].u16Count = 0;
    485              Led_asControl[i].eCurrentDuty = LED_PWM_DUTY_LOW;
    486            }
    487          
    488            /* Backlight on */
    489            LedOn(LCD_BL);
    490          
    491            /* If good initialization, set state to Idle */
    492            if( 1 )
    493            {
    494              /* Final setup and report that LED system is ready */
    495              G_u32ApplicationFlags |= _APPLICATION_FLAGS_LED;
    496              DebugPrintf("LED functions ready\n\r");
    497              Led_StateMachine = LedSM_Idle;
    498            }
    499            else
    500            {
    501              /* The task isn't properly initialized, so shut it down and don't run */
    502              Led_StateMachine = LedSM_Error;
    503            }
    504            
    505          } /* end LedInitialize() */
    506          #endif /* EIE_DOTMATRIX */
    507          
    508          
    509          /*!----------------------------------------------------------------------------------------------------------------------
    510          @fn void LedRunActiveState(void)
    511          
    512          @brief Selects and runs one iteration of the current state in the state machine.
    513          
    514          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    515          may take 1ms / n to execute.
    516          
    517          Requires:
    518          - State machine function pointer points at current state
    519          
    520          Promises:
    521          - Calls the function to pointed by the state machine function pointer
    522          
    523          */

   \                                 In section .text, align 2, keep-with-next
    524          void LedRunActiveState(void)
    525          {
   \                     LedRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    526            Led_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable7_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    527          
    528          } /* end LedRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    529          
    530          
    531          
    532          /*------------------------------------------------------------------------------------------------------------------*/
    533          /*! @privatesection */                                                                                            
    534          /*--------------------------------------------------------------------------------------------------------------------*/
    535          
    536          
    537          /***********************************************************************************************************************
    538          State Machine Declarations
    539          ***********************************************************************************************************************/
    540          
    541          /*!-------------------------------------------------------------------------------------------------------------------
    542          @fn static void LedSM_Idle(void)
    543          
    544          @brief Run through all the LEDs to check for blinking updates.
    545          */

   \                                 In section .text, align 4, keep-with-next
    546          static void LedSM_Idle(void)
    547          {
   \                     LedSM_Idle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    548            u32* pu32Address;
    549            
    550          	/* Loop through each LED to check for blinkers */
    551            for(u8 i = 0; i < U8_TOTAL_LEDS; i++)
   \   00000002   0x2500             MOVS     R5,#+0
   \                     ??LedSM_Idle_0: (+1)
   \   00000004   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000006   0x2D0B             CMP      R5,#+11
   \   00000008   0xF280 0x809E      BGE.W    ??LedSM_Idle_1
    552            {
    553              /* Check if LED is in LED_BLINK_MODE */
    554              if(Led_asControl[(LedNameType)i].eMode == LED_BLINK_MODE)
   \   0000000C   0x....             LDR.N    R0,??DataTable7_3
   \   0000000E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000010   0xF810 0x0035      LDRB     R0,[R0, R5, LSL #+3]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD12B             BNE.N    ??LedSM_Idle_2
    555              {
    556                /* Decrement counter and check for 0 */
    557                if( --Led_asControl[(LedNameType)i].u16Count == 0)
   \   00000018   0x....             LDR.N    R0,??DataTable7_3
   \   0000001A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000001C   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000020   0x8880             LDRH     R0,[R0, #+4]
   \   00000022   0x1E40             SUBS     R0,R0,#+1
   \   00000024   0x....             LDR.N    R1,??DataTable7_3
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000002C   0x8088             STRH     R0,[R1, #+4]
   \   0000002E   0x....             LDR.N    R0,??DataTable7_3
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000036   0x8880             LDRH     R0,[R0, #+4]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD119             BNE.N    ??LedSM_Idle_2
    558                {
    559                  /* Toggle and reload the LED */
    560                  pu32Address = (u32*)(&(AT91C_BASE_PIOA->PIO_ODSR) + G_asBspLedConfigurations[i].ePort);
   \   0000003C   0x....             LDR.N    R0,??DataTable7_4  ;; 0x400e0c38
   \   0000003E   0x....             LDR.N    R1,??DataTable7
   \   00000040   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000042   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000046   0x7909             LDRB     R1,[R1, #+4]
   \   00000048   0xEB10 0x0081      ADDS     R0,R0,R1, LSL #+2
   \   0000004C   0x0004             MOVS     R4,R0
    561                  *pu32Address ^= G_asBspLedConfigurations[i].u32BitPosition;
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x....             LDR.N    R1,??DataTable7
   \   00000052   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000054   0xF851 0x1035      LDR      R1,[R1, R5, LSL #+3]
   \   00000058   0x4048             EORS     R0,R1,R0
   \   0000005A   0x6020             STR      R0,[R4, #+0]
    562                  Led_asControl[(LedNameType)i].u16Count = Led_asControl[(LedNameType)i].eRate;
   \   0000005C   0x....             LDR.N    R0,??DataTable7_3
   \   0000005E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000060   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000064   0x8840             LDRH     R0,[R0, #+2]
   \   00000066   0x....             LDR.N    R1,??DataTable7_3
   \   00000068   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000006A   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000006E   0x8088             STRH     R0,[R1, #+4]
    563                }
    564              } /* end LED_BLINK_MODE */
    565              
    566              /* Check if LED is in LED_PWM_MODE */
    567              if(Led_asControl[(LedNameType)i].eMode == LED_PWM_MODE)
   \                     ??LedSM_Idle_2: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable7_3
   \   00000072   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000074   0xF810 0x0035      LDRB     R0,[R0, R5, LSL #+3]
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD163             BNE.N    ??LedSM_Idle_3
    568              {
    569                /* Handle special case of 0% duty cycle */
    570                if( Led_asControl[i].eRate == LED_PWM_0 )
   \   0000007C   0x....             LDR.N    R0,??DataTable7_3
   \   0000007E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000080   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000084   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD104             BNE.N    ??LedSM_Idle_4
    571                {
    572                  LedOff( (LedNameType)i );
   \   0000008C   0x0028             MOVS     R0,R5
   \   0000008E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000090   0x.... 0x....      BL       LedOff
   \   00000094   0xE051             B.N      ??LedSM_Idle_5
    573                }
    574                
    575                /* Handle special case of 100% duty cycle */
    576                else if( Led_asControl[i].eRate == LED_PWM_100 )
   \                     ??LedSM_Idle_4: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable7_3
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   0000009E   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000A2   0x2814             CMP      R0,#+20
   \   000000A4   0xD104             BNE.N    ??LedSM_Idle_6
    577                {
    578                  LedOn( (LedNameType)i );
   \   000000A6   0x0028             MOVS     R0,R5
   \   000000A8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000AA   0x.... 0x....      BL       LedOn
   \   000000AE   0xE044             B.N      ??LedSM_Idle_5
    579                }
    580            
    581                /* Otherwise, regular PWM: decrement counter; toggle and reload if counter reaches 0 */
    582                else
    583                {
    584                  if(--Led_asControl[(LedNameType)i].u16Count == 0)
   \                     ??LedSM_Idle_6: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable7_3
   \   000000B2   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000B4   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000B8   0x8880             LDRH     R0,[R0, #+4]
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x....             LDR.N    R1,??DataTable7_3
   \   000000BE   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000C0   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   000000C4   0x8088             STRH     R0,[R1, #+4]
   \   000000C6   0x....             LDR.N    R0,??DataTable7_3
   \   000000C8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000CA   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000CE   0x8880             LDRH     R0,[R0, #+4]
   \   000000D0   0x2800             CMP      R0,#+0
   \   000000D2   0xD132             BNE.N    ??LedSM_Idle_5
    585                  {
    586                    if(Led_asControl[(LedNameType)i].eCurrentDuty == LED_PWM_DUTY_HIGH)
   \   000000D4   0x....             LDR.N    R0,??DataTable7_3
   \   000000D6   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000D8   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000DC   0x7980             LDRB     R0,[R0, #+6]
   \   000000DE   0x2801             CMP      R0,#+1
   \   000000E0   0xD117             BNE.N    ??LedSM_Idle_7
    587                    {
    588                      /* Turn the LED off and update the counters for the next cycle */
    589                      LedOff( (LedNameType)i );
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E6   0x.... 0x....      BL       LedOff
    590                      Led_asControl[(LedNameType)i].u16Count = LED_PWM_100 - Led_asControl[(LedNameType)i].eRate;
   \   000000EA   0x....             LDR.N    R0,??DataTable7_3
   \   000000EC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000EE   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   000000F2   0xF9B0 0x0002      LDRSH    R0,[R0, #+2]
   \   000000F6   0xF1D0 0x0014      RSBS     R0,R0,#+20
   \   000000FA   0x....             LDR.N    R1,??DataTable7_3
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000102   0x8088             STRH     R0,[R1, #+4]
    591                      Led_asControl[(LedNameType)i].eCurrentDuty = LED_PWM_DUTY_LOW;
   \   00000104   0x2000             MOVS     R0,#+0
   \   00000106   0x....             LDR.N    R1,??DataTable7_3
   \   00000108   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000010A   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000010E   0x7188             STRB     R0,[R1, #+6]
   \   00000110   0xE013             B.N      ??LedSM_Idle_5
    592                    }
    593                    else
    594                    {
    595                      /* Turn the LED on and update the counters for the next cycle */
    596                      LedOn( (LedNameType)i );
   \                     ??LedSM_Idle_7: (+1)
   \   00000112   0x0028             MOVS     R0,R5
   \   00000114   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000116   0x.... 0x....      BL       LedOn
    597                      Led_asControl[i].u16Count = Led_asControl[i].eRate;
   \   0000011A   0x....             LDR.N    R0,??DataTable7_3
   \   0000011C   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011E   0xEB10 0x00C5      ADDS     R0,R0,R5, LSL #+3
   \   00000122   0x8840             LDRH     R0,[R0, #+2]
   \   00000124   0x....             LDR.N    R1,??DataTable7_3
   \   00000126   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000128   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   0000012C   0x8088             STRH     R0,[R1, #+4]
    598                      Led_asControl[i].eCurrentDuty = LED_PWM_DUTY_HIGH;
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x....             LDR.N    R1,??DataTable7_3
   \   00000132   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000134   0xEB11 0x01C5      ADDS     R1,R1,R5, LSL #+3
   \   00000138   0x7188             STRB     R0,[R1, #+6]
    599                    }
    600                  }
    601                }
    602          
    603                /* Set the LED back to PWM mode since LedOff and LedOn set it to normal mode */
    604               	Led_asControl[(LedNameType)i].eMode = LED_PWM_MODE;
   \                     ??LedSM_Idle_5: (+1)
   \   0000013A   0x2002             MOVS     R0,#+2
   \   0000013C   0x....             LDR.N    R1,??DataTable7_3
   \   0000013E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000140   0xF801 0x0035      STRB     R0,[R1, R5, LSL #+3]
    605                
    606              } /* end LED_PWM_MODE */
    607              
    608            } /* end for(u8 i = 0; i < U8_TOTAL_LEDS; i++) */
   \                     ??LedSM_Idle_3: (+1)
   \   00000144   0x1C6D             ADDS     R5,R5,#+1
   \   00000146   0xE75D             B.N      ??LedSM_Idle_0
    609             
    610          } /* end LedSM_Idle() */
   \                     ??LedSM_Idle_1: (+1)
   \   00000148   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     G_asBspLedConfigurations

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x400E0C30         DC32     0x400e0c30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x400E0C34         DC32     0x400e0c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     Led_asControl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x400E0C38         DC32     0x400e0c38

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     Led_StateMachine

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x4C 0x45          DC8 "LED functions ready\012\015"
   \              0x44 0x20    
   \              0x66 0x75    
   \              0x6E 0x63    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
    611          
    612          
    613          /*!-------------------------------------------------------------------------------------------------------------------
    614          @fn static void LedSM_Error(void)
    615          
    616          @brief Handle an error here.  For now, the task is just held in this state. 
    617          */
    618          static void LedSM_Error(void)          
    619          {
    620            
    621          } /* end LedSM_Error() */
    622          
    623          
    624          /*--------------------------------------------------------------------------------------------------------------------*/
    625          /* End of File */
    626          /*--------------------------------------------------------------------------------------------------------------------*/
    627          
    628          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   LedBlink
      32   LedInitialize
        32   -> DebugPrintf
        32   -> IsTimeUp
        32   -> LedOn
        32   -> LedPWM
        32   -> LedSM_Idle
       0   LedOff
       0   LedOn
       0   LedPWM
       8   LedRunActiveState
         8   -- Indirect call
      16   LedSM_Idle
        16   -> LedOff
        16   -> LedOn
       0   LedToggle


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
      24  ?_0
      32  LedBlink
     278  LedInitialize
      74  LedOff
      84  LedOn
      44  LedPWM
      10  LedRunActiveState
     330  LedSM_Idle
      42  LedToggle
       4  Led_StateMachine
      88  Led_asControl

 
  92 bytes in section .bss
  24 bytes in section .rodata
 930 bytes in section .text
 
 930 bytes of CODE  memory
  24 bytes of CONST memory
  92 bytes of DATA  memory

Errors: none
Warnings: none
