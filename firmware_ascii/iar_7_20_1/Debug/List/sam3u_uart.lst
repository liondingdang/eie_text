###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_uart.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_uart.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\sam3u_uart.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_uart.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_uart.c
      1          /*!**********************************************************************************************************************
      2          @file sam3u_uart.c                                                                
      3          @brief Provides a driver to use UART peripherals on the SAM3U processor to send and receive data using interrupts. 
      4          
      5          This driver covers both the dedicated UART peripheral and the three USART peripherals (assuming they are
      6          running in asynchronous (UART) mode).
      7          
      8          INITIALIZATION (should take place in application's initialization function):
      9          1. Create a variable of UartConfigurationType in your application and initialize it to the desired UART peripheral,
     10          the address of the receive buffer for the application, and the size in bytes of the receive buffer.
     11          
     12          2. Call UartRequest() with pointer to the configuration variable created in step 1.  The returned pointer is the
     13          UartPeripheralType object created that will be used by your application and should be assigned to a variable
     14          accessible to your application.
     15          
     16          3. If the application no longer needs the UART resource, call UartRelease().  
     17          
     18          ------------------------------------------------------------------------------------------------------------------------
     19          GLOBALS
     20          - NONE
     21          
     22          CONSTANTS
     23          - NONE
     24          
     25          TYPES
     26          - UartConfigurationType
     27          - UartPeripheralType
     28          
     29          PUBLIC FUNCTIONS
     30          - UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
     31          - void UartRelease(UartPeripheralType* psUartPeripheral_)
     32          - u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
     33          - u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* pu8Data_)
     34          
     35          PROTECTED FUNCTIONS
     36          - void UartInitialize(void);
     37          - void UartRunActiveState(void);
     38          - static void UartManualMode(void);
     39          
     40          
     41          **********************************************************************************************************************/
     42          
     43          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     44          
     45          
     46          /***********************************************************************************************************************
     47          Global variable definitions with scope across entire project.
     48          All Global variable names shall start with "G_<type>Uart"
     49          ***********************************************************************************************************************/
     50          /* New variables */
     51          
     52          
     53          /*--------------------------------------------------------------------------------------------------------------------*/
     54          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     55          extern volatile u32 G_u32SystemTime1ms;          /*!< @brief From main.c */
     56          extern volatile u32 G_u32SystemTime1s;           /*!< @brief From main.c */
     57          extern volatile u32 G_u32SystemFlags;            /*!< @brief From main.c */
     58          extern volatile u32 G_u32ApplicationFlags;       /*!< @brief From main.c */
     59          
     60          
     61          
     62          /***********************************************************************************************************************
     63          Global variable definitions with scope limited to this local application.
     64          Variable names shall start with "Uart_<type>" and be declared as static.
     65          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     66          static fnCode_type Uart_pfnStateMachine;         /*!< @brief The UART application state machine function pointer */
   \                     Uart_pfnStateMachine:
   \   00000000                      DS8 4
     67          

   \                                 In section .bss, align 4
     68          static u32 Uart_u32Flags;                        /*!< @brief Application flags for UART */
   \                     Uart_u32Flags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     69          static u8  Uart_u8ActiveUarts;                   /*!< @brief Counting semaphore for # of active UARTs */
   \                     Uart_u8ActiveUarts:
   \   00000000                      DS8 1
     70          

   \                                 In section .bss, align 4
     71          static UartPeripheralType Uart_sPeripheral;      /*!< @brief UART peripheral object */
   \                     Uart_sPeripheral:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     72          static UartPeripheralType Uart_sPeripheral0;     /*!< @brief USART0 peripheral object (used as UART) */
   \                     Uart_sPeripheral0:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     73          static UartPeripheralType Uart_sPeripheral1;     /*!< @brief USART1 peripheral object (used as UART) */
   \                     Uart_sPeripheral1:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
     74          static UartPeripheralType Uart_sPeripheral2;     /*!< @brief USART2 peripheral object (used as UART) */
   \                     Uart_sPeripheral2:
   \   00000000                      DS8 36
     75          

   \                                 In section .bss, align 4
     76          static UartPeripheralType* Uart_psCurrentUart;   /*!< @brief Current UART peripheral being processed */
   \                     Uart_psCurrentUart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     77          static UartPeripheralType* Uart_psCurrentISR;    /*!< @brief Current UART peripheral being processed in ISR */
   \                     Uart_psCurrentISR:
   \   00000000                      DS8 4
     78          

   \                                 In section .bss, align 4
     79          static u32 Uart_u32IntCount  = 0;                /*!< @brief Debug counter for UART interrupts */
   \                     Uart_u32IntCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     80          static u32 Uart_u32Int0Count = 0;                /*!< @brief Debug counter for USART0 interrupts */
   \                     Uart_u32Int0Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     81          static u32 Uart_u32Int1Count = 0;                /*!< @brief Debug counter for USART1 interrupts */
   \                     Uart_u32Int1Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     82          static u32 Uart_u32Int2Count = 0;                /*!< @brief Debug counter for USART2 interrupts */
   \                     Uart_u32Int2Count:
   \   00000000                      DS8 4
     83          
     84          
     85          /***********************************************************************************************************************
     86          Function Definitions
     87          ***********************************************************************************************************************/
     88          
     89          /*--------------------------------------------------------------------------------------------------------------------*/
     90          /*! @publicsection */                                                                                            
     91          /*--------------------------------------------------------------------------------------------------------------------*/
     92          
     93          
     94          /*!---------------------------------------------------------------------------------------------------------------------
     95          @fn UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
     96          
     97          @brief Requests access to a UART resource.  
     98          
     99          If the resource is available, the transmit and receive parameters are set up
    100          and the peripheral is made ready to use in the application.  
    101          
    102          Requires:
    103          - Uart_sPeripheralx perihperal objects have been initialized
    104          - USART Peripheralx registers are not write-protected (WPEN)
    105          - UART peripheral register initialization values in configuration.h must be set correctly
    106          - UART/USART peripheral registers configured here are at the same address offset regardless of the peripheral. 
    107          
    108          @param psUartConfig_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    109                 application is ready to start using the peripheral.
    110          
    111          Promises:
    112          - Returns NULL if a resource cannot be assigned; OR
    113          - Returns a pointer to the requested UART peripheral object if the resource is available
    114          - Peripheral is configured and enabled 
    115          - Peripheral interrupts are enabled.
    116          
    117          */

   \                                 In section .text, align 2, keep-with-next
    118          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
    119          {
   \                     UartRequest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    120            UartPeripheralType* psRequestedUart;
    121            u32 u32TargetCR;
    122            u32 u32TargetMR;
    123            u32 u32TargetIER;
    124            u32 u32TargetIDR;
    125            u32 u32TargetBRGR;
    126            
    127            /* Set-up is peripheral-specific */
    128            switch(psUartConfig_->UartPeripheral)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD002             BEQ.N    ??UartRequest_0
   \   0000000C   0x2802             CMP      R0,#+2
   \   0000000E   0xD010             BEQ.N    ??UartRequest_1
   \   00000010   0xE01F             B.N      ??UartRequest_2
    129            {
    130              case UART:
    131              {
    132                psRequestedUart = &Uart_sPeripheral; 
   \                     ??UartRequest_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000016   0x0005             MOVS     R5,R0
    133          
    134                u32TargetCR   = UART_US_CR_INIT;
   \   00000018   0x2050             MOVS     R0,#+80
   \   0000001A   0x0006             MOVS     R6,R0
    135                u32TargetMR   = UART_US_MR_INIT; 
   \   0000001C   0xF44F 0x600C      MOV      R0,#+2240
   \   00000020   0x0007             MOVS     R7,R0
    136                u32TargetIER  = UART_US_IER_INIT; 
   \   00000022   0x2008             MOVS     R0,#+8
   \   00000024   0x4680             MOV      R8,R0
    137                u32TargetIDR  = UART_US_IDR_INIT;
   \   00000026   0xF07F 0x0008      MVNS     R0,#+8
   \   0000002A   0x4681             MOV      R9,R0
    138                u32TargetBRGR = UART_US_BRGR_INIT;
   \   0000002C   0x201A             MOVS     R0,#+26
   \   0000002E   0x4682             MOV      R10,R0
    139                break;
   \   00000030   0xE011             B.N      ??UartRequest_3
    140              } 
    141          
    142              case USART0:
    143              {
    144                psRequestedUart = &Uart_sPeripheral0; 
   \                     ??UartRequest_1: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000036   0x0005             MOVS     R5,R0
    145          
    146                u32TargetCR   = USART0_US_CR_INIT;
   \   00000038   0x2050             MOVS     R0,#+80
   \   0000003A   0x0006             MOVS     R6,R0
    147                u32TargetMR   = USART0_US_MR_INIT; 
   \   0000003C   0xF44F 0x600C      MOV      R0,#+2240
   \   00000040   0x0007             MOVS     R7,R0
    148                u32TargetIER  = USART0_US_IER_INIT; 
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x4680             MOV      R8,R0
    149                u32TargetIDR  = USART0_US_IDR_INIT;
   \   00000046   0xF07F 0x0008      MVNS     R0,#+8
   \   0000004A   0x4681             MOV      R9,R0
    150                u32TargetBRGR = USART0_US_BRGR_INIT;
   \   0000004C   0x201A             MOVS     R0,#+26
   \   0000004E   0x4682             MOV      R10,R0
    151                break;
   \   00000050   0xE001             B.N      ??UartRequest_3
    152              } 
    153          
    154          #if 0
    155              case USART1:
    156              {
    157                psRequestedUart = &Uart_sPeripheral1; 
    158          
    159                u32TargetCR   = USART1_US_CR_INIT;
    160                u32TargetMR   = USART1_US_MR_INIT; 
    161                u32TargetIER  = USART1_US_IER_INIT; 
    162                u32TargetIDR  = USART1_US_IDR_INIT;
    163                u32TargetBRGR = USART1_US_BRGR_INIT;
    164                break;
    165              } 
    166              
    167              case USART2:
    168              {
    169                psRequestedUart = &Uart_sPeripheral2; 
    170                
    171                u32TargetCR   = USART2_US_CR_INIT;
    172                u32TargetMR   = USART2_US_MR_INIT; 
    173                u32TargetIER  = USART2_US_IER_INIT; 
    174                u32TargetIDR  = USART2_US_IDR_INIT;
    175                u32TargetBRGR = USART2_US_BRGR_INIT;
    176                break;
    177              } 
    178          #endif
    179              default:
    180              {
    181                return(NULL);
   \                     ??UartRequest_2: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE049             B.N      ??UartRequest_4
    182                break;
    183              } 
    184            } /* end switch */
    185          
    186            /* If the requested peripheral is already assigned, return NULL now */
    187            if(psRequestedUart->u32PrivateFlags & _UART_PERIPHERAL_ASSIGNED)
   \                     ??UartRequest_3: (+1)
   \   00000056   0x7928             LDRB     R0,[R5, #+4]
   \   00000058   0x07C0             LSLS     R0,R0,#+31
   \   0000005A   0xD501             BPL.N    ??UartRequest_5
    188            {
    189              return(NULL);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xE044             B.N      ??UartRequest_4
    190            }
    191            
    192            /* Activate and configure the peripheral */
    193            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedUart->u8PeripheralId);
   \                     ??UartRequest_5: (+1)
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x400e0410
   \   00000064   0x6800             LDR      R0,[R0, #+0]
   \   00000066   0x2101             MOVS     R1,#+1
   \   00000068   0xF995 0x2022      LDRSB    R2,[R5, #+34]
   \   0000006C   0x4091             LSLS     R1,R1,R2
   \   0000006E   0x4308             ORRS     R0,R1,R0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_5  ;; 0x400e0410
   \   00000074   0x6008             STR      R0,[R1, #+0]
    194          
    195            psRequestedUart->pu8RxBuffer     = psUartConfig_->pu8RxBufferAddress;
   \   00000076   0x6860             LDR      R0,[R4, #+4]
   \   00000078   0x6168             STR      R0,[R5, #+20]
    196            psRequestedUart->u16RxBufferSize = psUartConfig_->u16RxBufferSize;
   \   0000007A   0x8860             LDRH     R0,[R4, #+2]
   \   0000007C   0x8428             STRH     R0,[R5, #+32]
    197            psRequestedUart->pu8RxNextByte   = psUartConfig_->pu8RxNextByte;
   \   0000007E   0x68A0             LDR      R0,[R4, #+8]
   \   00000080   0x61A8             STR      R0,[R5, #+24]
    198            psRequestedUart->fnRxCallback    = psUartConfig_->fnRxCallback;
   \   00000082   0x68E0             LDR      R0,[R4, #+12]
   \   00000084   0x61E8             STR      R0,[R5, #+28]
    199            psRequestedUart->u32PrivateFlags |= _UART_PERIPHERAL_ASSIGNED;
   \   00000086   0x6868             LDR      R0,[R5, #+4]
   \   00000088   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000008C   0x6068             STR      R0,[R5, #+4]
    200            
    201            psRequestedUart->pBaseAddress->US_CR   = u32TargetCR;
   \   0000008E   0x6828             LDR      R0,[R5, #+0]
   \   00000090   0x6006             STR      R6,[R0, #+0]
    202            psRequestedUart->pBaseAddress->US_MR   = u32TargetMR;
   \   00000092   0x6828             LDR      R0,[R5, #+0]
   \   00000094   0x6047             STR      R7,[R0, #+4]
    203            psRequestedUart->pBaseAddress->US_IER  = u32TargetIER;
   \   00000096   0x6828             LDR      R0,[R5, #+0]
   \   00000098   0xF8C0 0x8008      STR      R8,[R0, #+8]
    204            psRequestedUart->pBaseAddress->US_IDR  = u32TargetIDR;
   \   0000009C   0x6828             LDR      R0,[R5, #+0]
   \   0000009E   0xF8C0 0x900C      STR      R9,[R0, #+12]
    205            psRequestedUart->pBaseAddress->US_BRGR = u32TargetBRGR;
   \   000000A2   0x6828             LDR      R0,[R5, #+0]
   \   000000A4   0xF8C0 0xA020      STR      R10,[R0, #+32]
    206          
    207            /* Preset the receive PDC pointers and counters; the receive buffer must be starting from [0] and be at least 2 bytes long)*/
    208            psRequestedUart->pBaseAddress->US_RPR  = (unsigned int)psUartConfig_->pu8RxBufferAddress;
   \   000000A8   0x6860             LDR      R0,[R4, #+4]
   \   000000AA   0x6829             LDR      R1,[R5, #+0]
   \   000000AC   0xF8C1 0x0100      STR      R0,[R1, #+256]
    209            psRequestedUart->pBaseAddress->US_RNPR = (unsigned int)((psUartConfig_->pu8RxBufferAddress) + 1);
   \   000000B0   0x6860             LDR      R0,[R4, #+4]
   \   000000B2   0x1C40             ADDS     R0,R0,#+1
   \   000000B4   0x6829             LDR      R1,[R5, #+0]
   \   000000B6   0xF8C1 0x0110      STR      R0,[R1, #+272]
    210            psRequestedUart->pBaseAddress->US_RCR  = 1;
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x6829             LDR      R1,[R5, #+0]
   \   000000BE   0xF8C1 0x0104      STR      R0,[R1, #+260]
    211            psRequestedUart->pBaseAddress->US_RNCR = 1;
   \   000000C2   0x2001             MOVS     R0,#+1
   \   000000C4   0x6829             LDR      R1,[R5, #+0]
   \   000000C6   0xF8C1 0x0114      STR      R0,[R1, #+276]
    212            
    213            /* Enable the receiver and transmitter requests */
    214            psRequestedUart->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \   000000CA   0xF240 0x1001      MOVW     R0,#+257
   \   000000CE   0x6829             LDR      R1,[R5, #+0]
   \   000000D0   0xF8C1 0x0120      STR      R0,[R1, #+288]
    215          
    216            /* Enable UART interrupts */
    217            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   000000D4   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   000000D8   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000DA   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    218            NVIC_EnableIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   000000DE   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   000000E2   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   000000E4   0x.... 0x....      BL       NVIC_EnableIRQ
    219            
    220            return(psRequestedUart);
   \   000000E8   0x0028             MOVS     R0,R5
   \                     ??UartRequest_4: (+1)
   \   000000EA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    221            
    222          } /* end UartRequest() */
    223          
    224          
    225          /*!---------------------------------------------------------------------------------------------------------------------
    226          @fn void UartRelease(UartPeripheralType* psUartPeripheral_)
    227          
    228          @brief Releases a UART resource.  
    229          
    230          Requires:
    231          @param psUartPeripheral_ has the UART peripheral number to be released
    232          
    233          Promises:
    234          - Disables the associated interrupts
    235          - Resets peripheral object's pointers
    236          - Any unsent messages are dumped and set to ABANDONED status
    237          - Main SM reset to Idle
    238          
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          void UartRelease(UartPeripheralType* psUartPeripheral_)
    241          {
   \                     UartRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    242            /* Check to see if the peripheral is already released */
    243            if(psUartPeripheral_->pu8RxBuffer == NULL)
   \   00000004   0x6960             LDR      R0,[R4, #+20]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD023             BEQ.N    ??UartRelease_0
    244            {
    245              return;
    246            }
    247            
    248            /* First disable the interrupts */
    249            NVIC_DisableIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \                     ??UartRelease_1: (+1)
   \   0000000A   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       NVIC_DisableIRQ
    250            NVIC_ClearPendingIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \   00000014   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   00000018   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    251           
    252            /* Now it's safe to release all of the resources in the target peripheral */
    253            psUartPeripheral_->pu8RxBuffer   = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6160             STR      R0,[R4, #+20]
    254            psUartPeripheral_->pu8RxNextByte = NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61A0             STR      R0,[R4, #+24]
    255            psUartPeripheral_->fnRxCallback  = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x61E0             STR      R0,[R4, #+28]
    256            psUartPeripheral_->u32PrivateFlags = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    257          
    258            /* Empty the transmit buffer if there were leftover messages */
    259            while(psUartPeripheral_->psTransmitBuffer != NULL)
   \                     ??UartRelease_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD009             BEQ.N    ??UartRelease_3
    260            {
    261              UpdateMessageStatus(psUartPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   00000034   0x2105             MOVS     R1,#+5
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       UpdateMessageStatus
    262              DeQueueMessage(&psUartPeripheral_->psTransmitBuffer);
   \   0000003E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000042   0x.... 0x....      BL       DeQueueMessage
   \   00000046   0xE7F2             B.N      ??UartRelease_2
    263            }
    264            
    265            /* Ensure the SM is in the Idle state */
    266            Uart_pfnStateMachine = UartSM_Idle;
   \                     ??UartRelease_3: (+1)
   \   00000048   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   00000050   0x6008             STR      R0,[R1, #+0]
    267           
    268          } /* end UartRelease() */
   \                     ??UartRelease_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    269          
    270          
    271          /*!---------------------------------------------------------------------------------------------------------------------
    272          @fn u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
    273          
    274          @brief Queues a single byte for transfer on the target UART peripheral.  
    275          
    276          Requires:
    277          @param psUartPeripheral_ has been requested.
    278          @param u8Byte_ is the byte to send
    279          
    280          Promises:
    281          - Creates a 1-byte message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    282            when it is available.
    283          - Returns the message token assigned to the message
    284          
    285          */

   \                                 In section .text, align 2, keep-with-next
    286          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
    287          {
   \                     UartWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    288            u32 u32Token;
    289            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    290            
    291            /* Attempt to queue message and get a response token */
    292            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, 1, &u8Data);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000014   0x.... 0x....      BL       QueueMessage
   \   00000018   0x0006             MOVS     R6,R0
    293            
    294            if( u32Token != NULL )
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD006             BEQ.N    ??UartWriteByte_0
    295            {
    296              /* If the system is initializing, we want to manually cycle the UART task through one iteration
    297              to send the message */
    298              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??UartWriteByte_0
    299              {
    300                UartManualMode();
   \   00000028   0x.... 0x....      BL       UartManualMode
    301              }
    302            }
    303            
    304            return(u32Token);
   \                     ??UartWriteByte_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    305            
    306          } /* end UartWriteByte() */
    307          
    308          
    309          /*!---------------------------------------------------------------------------------------------------------------------
    310          @fn u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* pu8Data_)
    311          
    312          @brief Queues an array of bytes for transfer on the target UART peripheral.  
    313          
    314          Requires:
    315          @param psUartPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    316                 in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    317          @param u32Size_ is the number of bytes in the data array; should not be 0
    318          @param pu8Data_ points to the first byte of the data array
    319          
    320          Promises:
    321          - adds the data message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    322            when it is available.
    323          - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    324            G_u32MessagingFlags can be checked for the reason
    325          
    326          */

   \                                 In section .text, align 2, keep-with-next
    327          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* pu8Data_)
    328          {
   \                     UartWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    329            u32 u32Token;
    330            
    331            /* Check for a valid size */
    332            if(u32Size_ == 0)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??UartWriteData_0
    333            {
    334              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE010             B.N      ??UartWriteData_1
    335            }
    336          
    337            /* Attempt to queue message and get a response token */
    338            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, u32Size_, pu8Data_);
   \                     ??UartWriteData_0: (+1)
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000018   0x.... 0x....      BL       QueueMessage
   \   0000001C   0x0007             MOVS     R7,R0
    339            if(u32Token)
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD006             BEQ.N    ??UartWriteData_2
    340            {
    341              /* If the system is initializing, manually cycle the UART task through one iteration to send the message */
    342              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD501             BPL.N    ??UartWriteData_2
    343              {
    344                UartManualMode();
   \   0000002C   0x.... 0x....      BL       UartManualMode
    345              }
    346            }
    347            
    348            return(u32Token);
   \                     ??UartWriteData_2: (+1)
   \   00000030   0x0038             MOVS     R0,R7
   \                     ??UartWriteData_1: (+1)
   \   00000032   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    349            
    350          } /* end UartWriteData() */
    351          
    352          
    353          /*--------------------------------------------------------------------------------------------------------------------*/
    354          /*! @protectedsection */                                                                                            
    355          /*--------------------------------------------------------------------------------------------------------------------*/
    356          
    357          /*!--------------------------------------------------------------------------------------------------------------------
    358          @fn void UartInitialize(void)
    359          
    360          @brief Initializes the UART application and its variables.  
    361          
    362          Requires:
    363          - NONE 
    364          
    365          Promises:
    366          - UART peripheral objects are ready 
    367          - UART application set to Idle
    368          
    369          */

   \                                 In section .text, align 2, keep-with-next
    370          void UartInitialize(void)
    371          {
    372            /* Initialize all the UART peripheral structures */
    373            Uart_sPeripheral.pBaseAddress      = (AT91S_USART*)AT91C_BASE_DBGU;
   \                     UartInitialize: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0x400e0600
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000008   0x6008             STR      R0,[R1, #+0]
    374            Uart_sPeripheral.psTransmitBuffer  = NULL;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000010   0x6088             STR      R0,[R1, #+8]
    375            Uart_sPeripheral.pu8RxBuffer       = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000018   0x6148             STR      R0,[R1, #+20]
    376            Uart_sPeripheral.u16RxBufferSize   = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000020   0x8408             STRH     R0,[R1, #+32]
    377            Uart_sPeripheral.pu8RxNextByte     = NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000028   0x6188             STR      R0,[R1, #+24]
    378            Uart_sPeripheral.u32PrivateFlags   = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000030   0x6048             STR      R0,[R1, #+4]
    379            Uart_sPeripheral.u8PeripheralId    = AT91C_ID_DBGU;
   \   00000032   0x2008             MOVS     R0,#+8
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000038   0xF881 0x0022      STRB     R0,[R1, #+34]
    380          
    381            Uart_sPeripheral0.pBaseAddress     = AT91C_BASE_US0;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_9  ;; 0x40090000
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000044   0x6008             STR      R0,[R1, #+0]
    382            Uart_sPeripheral0.psTransmitBuffer = NULL;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000004C   0x6088             STR      R0,[R1, #+8]
    383            Uart_sPeripheral0.pu8RxBuffer      = NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000054   0x6148             STR      R0,[R1, #+20]
    384            Uart_sPeripheral0.u16RxBufferSize  = 0;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000005C   0x8408             STRH     R0,[R1, #+32]
    385            Uart_sPeripheral0.pu8RxNextByte    = NULL;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000064   0x6188             STR      R0,[R1, #+24]
    386            Uart_sPeripheral0.u32PrivateFlags  = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000006C   0x6048             STR      R0,[R1, #+4]
    387            Uart_sPeripheral0.u8PeripheralId   = AT91C_ID_US0;
   \   0000006E   0x200D             MOVS     R0,#+13
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000074   0xF881 0x0022      STRB     R0,[R1, #+34]
    388          
    389            Uart_sPeripheral1.pBaseAddress     = AT91C_BASE_US1;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable15_10  ;; 0x40094000
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000080   0x6008             STR      R0,[R1, #+0]
    390            Uart_sPeripheral1.psTransmitBuffer = NULL;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000088   0x6088             STR      R0,[R1, #+8]
    391            Uart_sPeripheral1.pu8RxBuffer      = NULL;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000090   0x6148             STR      R0,[R1, #+20]
    392            Uart_sPeripheral1.u16RxBufferSize  = 0;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000098   0x8408             STRH     R0,[R1, #+32]
    393            Uart_sPeripheral1.pu8RxNextByte    = NULL;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   000000A0   0x6188             STR      R0,[R1, #+24]
    394            Uart_sPeripheral1.u32PrivateFlags  = 0;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   000000A8   0x6048             STR      R0,[R1, #+4]
    395            Uart_sPeripheral1.u8PeripheralId   = AT91C_ID_US1;
   \   000000AA   0x200E             MOVS     R0,#+14
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   000000B0   0xF881 0x0022      STRB     R0,[R1, #+34]
    396          
    397            Uart_sPeripheral2.pBaseAddress     = AT91C_BASE_US2;
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable15_12  ;; 0x40098000
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable15_13
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    398            Uart_sPeripheral2.psTransmitBuffer = NULL;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x....             LDR.N    R1,??DataTable15_13
   \   000000C2   0x6088             STR      R0,[R1, #+8]
    399            Uart_sPeripheral2.pu8RxBuffer      = NULL;
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0x....             LDR.N    R1,??DataTable15_13
   \   000000C8   0x6148             STR      R0,[R1, #+20]
    400            Uart_sPeripheral2.u16RxBufferSize  = 0;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0x....             LDR.N    R1,??DataTable15_13
   \   000000CE   0x8408             STRH     R0,[R1, #+32]
    401            Uart_sPeripheral2.pu8RxNextByte    = NULL;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x....             LDR.N    R1,??DataTable15_13
   \   000000D4   0x6188             STR      R0,[R1, #+24]
    402            Uart_sPeripheral2.u32PrivateFlags  = 0;
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0x....             LDR.N    R1,??DataTable15_13
   \   000000DA   0x6048             STR      R0,[R1, #+4]
    403            Uart_sPeripheral2.u8PeripheralId   = AT91C_ID_US2;
   \   000000DC   0x200F             MOVS     R0,#+15
   \   000000DE   0x....             LDR.N    R1,??DataTable15_13
   \   000000E0   0xF881 0x0022      STRB     R0,[R1, #+34]
    404            
    405            /* Select the first UART peripheral and initialize other globals */
    406            Uart_psCurrentUart = &Uart_sPeripheral;
   \   000000E4   0x....             LDR.N    R0,??DataTable15_3
   \   000000E6   0x....             LDR.N    R1,??DataTable15_14
   \   000000E8   0x6008             STR      R0,[R1, #+0]
    407            Uart_u32Flags = 0;
   \   000000EA   0x2000             MOVS     R0,#+0
   \   000000EC   0x....             LDR.N    R1,??DataTable15_15
   \   000000EE   0x6008             STR      R0,[R1, #+0]
    408            Uart_u8ActiveUarts = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x....             LDR.N    R1,??DataTable15_16
   \   000000F4   0x7008             STRB     R0,[R1, #+0]
    409            Uart_pfnStateMachine = UartSM_Idle;
   \   000000F6   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   000000FA   0x....             LDR.N    R1,??DataTable15_6
   \   000000FC   0x6008             STR      R0,[R1, #+0]
    410            
    411          } /* end UartInitialize() */
   \   000000FE   0x4770             BX       LR               ;; return
    412          
    413          
    414          /*!----------------------------------------------------------------------------------------------------------------------
    415          @fn void UartRunActiveState(void)
    416          
    417          @brief Selects and runs one iteration of the current state in the state machine.
    418          
    419          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    420          may take 1ms / n to execute.
    421          
    422          Requires:
    423          - State machine function pointer points at current state
    424          
    425          Promises:
    426          - Calls the function to pointed by the state machine function pointer
    427          
    428          */

   \                                 In section .text, align 2, keep-with-next
    429          void UartRunActiveState(void)
    430          {
   \                     UartRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    431            Uart_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable15_6
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    432          
    433          } /* end UartRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    434          
    435          
    436          /*!----------------------------------------------------------------------------------------------------------------------
    437          @fn static void UartManualMode(void)
    438          
    439          @brief Runs a transmit cycle of the UART application to clock out a message.  This function is used only during
    440          initialization.
    441          
    442          Requires:
    443          - G_u32SystemFlags _SYSTEM_INITIALIZING is set
    444          - UART application has been initialized.
    445          
    446          Promises:
    447          - Runs the UART task until no UART messages are queued for transmission.
    448          
    449          */

   \                                 In section .text, align 2, keep-with-next
    450          static void UartManualMode(void)
    451          {
   \                     UartManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    452            u32 u32Timer;
    453            
    454            Uart_u32Flags |=_UART_MANUAL_MODE;
   \   00000002   0x....             LDR.N    R0,??DataTable15_15
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x....             LDR.N    R1,??DataTable15_15
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    455            Uart_psCurrentUart = &Uart_sPeripheral;
   \   0000000E   0x....             LDR.N    R0,??DataTable15_3
   \   00000010   0x....             LDR.N    R1,??DataTable15_14
   \   00000012   0x6008             STR      R0,[R1, #+0]
    456            
    457            while(Uart_u32Flags &_UART_MANUAL_MODE)
   \                     ??UartManualMode_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable15_15
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD510             BPL.N    ??UartManualMode_1
    458            {
    459              WATCHDOG_BONE();
   \   0000001C   0x....             LDR.N    R0,??DataTable15_17  ;; 0xa5000001
   \   0000001E   0x....             LDR.N    R1,??DataTable15_18  ;; 0x400e1250
   \   00000020   0x6008             STR      R0,[R1, #+0]
    460              UartRunActiveState();
   \   00000022   0x.... 0x....      BL       UartRunActiveState
    461              MessagingRunActiveState();
   \   00000026   0x.... 0x....      BL       MessagingRunActiveState
    462          
    463              u32Timer = G_u32SystemTime1ms;
   \   0000002A   0x....             LDR.N    R0,??DataTable15_19
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x9000             STR      R0,[SP, #+0]
    464              while( !IsTimeUp(&u32Timer, 1) );
   \                     ??UartManualMode_2: (+1)
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       IsTimeUp
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1EB             BNE.N    ??UartManualMode_0
   \   0000003C   0xE7F8             B.N      ??UartManualMode_2
    465            }
    466                
    467          } /* end UartManualMode() */
   \                     ??UartManualMode_1: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    468          
    469          
    470          /*!----------------------------------------------------------------------------------------------------------------------
    471          @fn ISR void UART_IRQHandler(void)
    472          
    473          @brief Handles the enabled UART interrupts for the basic UART. 
    474          
    475          Requires:
    476          - NONE
    477          
    478          Promises:
    479          - Gets the current interrupt context and proceeds to the Generic handler
    480          
    481          */

   \                                 In section .text, align 2, keep-with-next
    482          void UART_IRQHandler(void)
    483          {
   \                     DBGU_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    484            /* Set the current ISR pointers to UART targets */
    485            Uart_psCurrentISR = &Uart_sPeripheral;                       
   \   00000002   0x....             LDR.N    R0,??DataTable15_3
   \   00000004   0x....             LDR.N    R1,??DataTable15_20
   \   00000006   0x6008             STR      R0,[R1, #+0]
    486            Uart_u32IntCount++;
   \   00000008   0x....             LDR.N    R0,??DataTable15_21
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable15_21
   \   00000010   0x6008             STR      R0,[R1, #+0]
    487          
    488            /* Go to common UART interrupt using Uart_psCurrentISR since the SSP cannot interrupt itself */
    489            UartGenericHandler();
   \   00000012   0x.... 0x....      BL       UartGenericHandler
    490          
    491          } /* end Uart_IRQHandler() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    492          
    493          
    494          /*!----------------------------------------------------------------------------------------------------------------------
    495          @fn ISR void UART0_IRQHandler(void)
    496          
    497          @brief Handles the enabled UART interrupts for UART0. 
    498          
    499          Requires:
    500          - NONE
    501          
    502          Promises:
    503          - Gets the current interrupt context and proceeds to the Generic handler
    504          
    505          */

   \                                 In section .text, align 2, keep-with-next
    506          void UART0_IRQHandler(void)
    507          {
   \                     USART0_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    508            /* Set the current ISR pointers to UART0 targets */
    509            Uart_psCurrentISR = &Uart_sPeripheral0;                         
   \   00000002   0x....             LDR.N    R0,??DataTable15_4
   \   00000004   0x....             LDR.N    R1,??DataTable15_20
   \   00000006   0x6008             STR      R0,[R1, #+0]
    510            Uart_u32Int0Count++;
   \   00000008   0x....             LDR.N    R0,??DataTable15_22
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable15_22
   \   00000010   0x6008             STR      R0,[R1, #+0]
    511          
    512            /* Go to common interrupt */
    513            UartGenericHandler();
   \   00000012   0x.... 0x....      BL       UartGenericHandler
    514          
    515          } /* end UART0_IRQHandler() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    516          
    517          
    518          /*!----------------------------------------------------------------------------------------------------------------------
    519          @fn ISR void UART1_IRQHandler(void)
    520          
    521          @brief Handles the enabled UART interrupts for UART1. 
    522          
    523          Requires:
    524          - NONE
    525          
    526          Promises:
    527          - Gets the current interrupt context and proceeds to the Generic handler
    528          
    529          */

   \                                 In section .text, align 2, keep-with-next
    530          void UART1_IRQHandler(void)
    531          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    532            /* Set the current ISR pointers to UART1 targets */
    533            Uart_psCurrentISR = &Uart_sPeripheral1;                          
   \   00000002   0x....             LDR.N    R0,??DataTable15_11
   \   00000004   0x....             LDR.N    R1,??DataTable15_20
   \   00000006   0x6008             STR      R0,[R1, #+0]
    534            Uart_u32Int1Count++;
   \   00000008   0x....             LDR.N    R0,??DataTable15_23
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable15_23
   \   00000010   0x6008             STR      R0,[R1, #+0]
    535          
    536            /* Go to common interrupt */
    537            UartGenericHandler();
   \   00000012   0x.... 0x....      BL       UartGenericHandler
    538          
    539          } /* end UART1_IRQHandler() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    540          
    541          
    542          /*!----------------------------------------------------------------------------------------------------------------------
    543          @fn ISR void UART2_IRQHandler(void)
    544          
    545          @brief Handles the enabled interrupts for UART2. 
    546          
    547          Requires:
    548          - NONE
    549          
    550          Promises:
    551          - Gets the current interrupt context and proceeds to the Generic handler
    552          
    553          */

   \                                 In section .text, align 2, keep-with-next
    554          void UART2_IRQHandler(void)
    555          {
   \                     UART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    556            /* Set the current ISR pointers to UART2 targets */
    557            Uart_psCurrentISR = &Uart_sPeripheral2;                          
   \   00000002   0x....             LDR.N    R0,??DataTable15_13
   \   00000004   0x....             LDR.N    R1,??DataTable15_20
   \   00000006   0x6008             STR      R0,[R1, #+0]
    558            Uart_u32Int2Count++;
   \   00000008   0x....             LDR.N    R0,??DataTable15_24
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x....             LDR.N    R1,??DataTable15_24
   \   00000010   0x6008             STR      R0,[R1, #+0]
    559          
    560            /* Go to common interrupt */
    561            UartGenericHandler();
   \   00000012   0x.... 0x....      BL       UartGenericHandler
    562          
    563          } /* end UART2_IRQHandler() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
    564          
    565          
    566          /*------------------------------------------------------------------------------------------------------------------*/
    567          /*! @privatesection */                                                                                            
    568          /*--------------------------------------------------------------------------------------------------------------------*/
    569          
    570          /*!----------------------------------------------------------------------------------------------------------------------
    571          @fn static void UartGenericHandler(void)
    572          
    573          @brief Common handler for all expected UART interrupts regardless of base peripheral
    574          
    575          Receive: A requested UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    576          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer configured.
    577          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    578          and to manage dummy bytes.  All data reception is done with DMA, but only 1 byte at a time.  Receiving is done by using
    579          the two reception pointers to ensure no data is missed.
    580          
    581          Transmit: All data bytes in the transmit buffer are sent using DMA and interrupts. Once the full message has been sent,
    582          the message status is updated.
    583          
    584          */

   \                                 In section .text, align 2, keep-with-next
    585          static void UartGenericHandler(void)
    586          {
   \                     UartGenericHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    587            /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR) */
    588            if( (Uart_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
    589                (Uart_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDRX) )
   \   00000002   0x....             LDR.N    R0,??DataTable15_20
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xD530             BPL.N    ??UartGenericHandler_0
   \   0000000E   0x....             LDR.N    R0,??DataTable15_20
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xD52A             BPL.N    ??UartGenericHandler_0
    590            {
    591              /* Update the "next" DMA pointer to the next valid Rx location with wrap-around check */
    592              Uart_psCurrentISR->pBaseAddress->US_RNPR++;
   \   0000001A   0x....             LDR.N    R0,??DataTable15_20
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x....             LDR.N    R1,??DataTable15_20
   \   00000028   0x6809             LDR      R1,[R1, #+0]
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xF8C1 0x0110      STR      R0,[R1, #+272]
    593              if(Uart_psCurrentISR->pBaseAddress->US_RNPR == (u32)(Uart_psCurrentISR->pu8RxBuffer + ( (u32)(Uart_psCurrentISR->u16RxBufferSize) & 0x0000FFFF ) ) )
   \   00000030   0x....             LDR.N    R0,??DataTable15_20
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   0000003A   0x....             LDR.N    R1,??DataTable15_20
   \   0000003C   0x6809             LDR      R1,[R1, #+0]
   \   0000003E   0x6949             LDR      R1,[R1, #+20]
   \   00000040   0x....             LDR.N    R2,??DataTable15_20
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x8C12             LDRH     R2,[R2, #+32]
   \   00000046   0x1851             ADDS     R1,R2,R1
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD107             BNE.N    ??UartGenericHandler_1
    594              {
    595                Uart_psCurrentISR->pBaseAddress->US_RNPR = (u32)Uart_psCurrentISR->pu8RxBuffer;  
   \   0000004C   0x....             LDR.N    R0,??DataTable15_20
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0x6940             LDR      R0,[R0, #+20]
   \   00000052   0x....             LDR.N    R1,??DataTable15_20
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x6809             LDR      R1,[R1, #+0]
   \   00000058   0xF8C1 0x0110      STR      R0,[R1, #+272]
    596              }
    597          
    598              /* Invoke the callback */
    599              Uart_psCurrentISR->fnRxCallback();
   \                     ??UartGenericHandler_1: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable15_20
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x69C0             LDR      R0,[R0, #+28]
   \   00000062   0x4780             BLX      R0
    600              
    601              /* Write RNCR to 1 to clear the ENDRX flag */
    602              Uart_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \   00000064   0x2001             MOVS     R0,#+1
   \   00000066   0x....             LDR.N    R1,??DataTable15_20
   \   00000068   0x6809             LDR      R1,[R1, #+0]
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0xF8C1 0x0114      STR      R0,[R1, #+276]
    603              
    604            } /* end of ENDRX interrupt processing */
    605          
    606            
    607            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
    608            if( (Uart_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
    609                (Uart_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDTX) )
   \                     ??UartGenericHandler_0: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable15_20
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0x6900             LDR      R0,[R0, #+16]
   \   00000078   0x06C0             LSLS     R0,R0,#+27
   \   0000007A   0xD538             BPL.N    ??UartGenericHandler_2
   \   0000007C   0x....             LDR.N    R0,??DataTable15_20
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x6940             LDR      R0,[R0, #+20]
   \   00000084   0x06C0             LSLS     R0,R0,#+27
   \   00000086   0xD532             BPL.N    ??UartGenericHandler_2
    610            {
    611              /* Update this message's token status and then DeQueue it */
    612              UpdateMessageStatus(Uart_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   00000088   0x2103             MOVS     R1,#+3
   \   0000008A   0x....             LDR.N    R0,??DataTable15_20
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x6880             LDR      R0,[R0, #+8]
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       UpdateMessageStatus
    613              DeQueueMessage( &Uart_psCurrentISR->psTransmitBuffer );
   \   00000096   0x....             LDR.N    R0,??DataTable15_20
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x3008             ADDS     R0,R0,#+8
   \   0000009C   0x.... 0x....      BL       DeQueueMessage
    614              Uart_psCurrentISR->u32PrivateFlags &= ~_UART_PERIPHERAL_TX;
   \   000000A0   0x....             LDR.N    R0,??DataTable15_20
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x6840             LDR      R0,[R0, #+4]
   \   000000A6   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000000AA   0x....             LDR.N    R1,??DataTable15_20
   \   000000AC   0x6809             LDR      R1,[R1, #+0]
   \   000000AE   0x6048             STR      R0,[R1, #+4]
    615                  
    616              /* Disable the transmitter and interrupt sources that were enabled in UART Idle to 
    617              start the transmission sequence */
    618              Uart_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \   000000B0   0xF44F 0x7000      MOV      R0,#+512
   \   000000B4   0x....             LDR.N    R1,??DataTable15_20
   \   000000B6   0x6809             LDR      R1,[R1, #+0]
   \   000000B8   0x6809             LDR      R1,[R1, #+0]
   \   000000BA   0xF8C1 0x0120      STR      R0,[R1, #+288]
    619              Uart_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \   000000BE   0x2010             MOVS     R0,#+16
   \   000000C0   0x....             LDR.N    R1,??DataTable15_20
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0x60C8             STR      R0,[R1, #+12]
    620              
    621              /* Decrement # of UARTs that are currently sending (incremented in UART Idle when the
    622              transmission started) */
    623              if(Uart_u8ActiveUarts != 0)
   \   000000C8   0x....             LDR.N    R0,??DataTable15_16
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD005             BEQ.N    ??UartGenericHandler_3
    624              {
    625                Uart_u8ActiveUarts--;
   \   000000D0   0x....             LDR.N    R0,??DataTable15_16
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x1E40             SUBS     R0,R0,#+1
   \   000000D6   0x....             LDR.N    R1,??DataTable15_16
   \   000000D8   0x7008             STRB     R0,[R1, #+0]
   \   000000DA   0xE008             B.N      ??UartGenericHandler_2
    626              }
    627              else
    628              {
    629                /* If Uart_u8ActiveUarts is already 0, then we are not properly synchronized */
    630                DebugPrintf("\n\rUART counter out of sync\n\r");
   \                     ??UartGenericHandler_3: (+1)
   \   000000DC   0x....             LDR.N    R0,??DataTable15_25
   \   000000DE   0x.... 0x....      BL       DebugPrintf
    631                Uart_u32Flags |= _UART_NO_ACTIVE_UARTS;
   \   000000E2   0x....             LDR.N    R0,??DataTable15_15
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   000000EA   0x....             LDR.N    R1,??DataTable15_15
   \   000000EC   0x6008             STR      R0,[R1, #+0]
    632              }
    633              
    634            } /* end of ENDTX interrupt processing */
    635            
    636          } /* end UartGenericHandler() */
   \                     ??UartGenericHandler_2: (+1)
   \   000000EE   0xBD01             POP      {R0,PC}          ;; return
    637          
    638          
    639          /***********************************************************************************************************************
    640          State Machine Function Definitions
    641          
    642          The UART state machine monitors messaging activity on the available UART peripherals.  It manages outgoing messages and will
    643          transmit any bytes that has been queued.  
    644          
    645          Transmitting:
    646          When TxBufferUnsentChar doesn't match Uart_pu8U0TxBufferNextChar, then we know that there is data to send.
    647          Data transfer is initiated by writing the first byte and setting the _Uart_U0_SENDING flag to keep the USART state machine 
    648          busy sending all of the current data on the USART.  The interrupt service routine will be responsible for clearing the
    649          bit which will allow the SM to return to Idle.  
    650          
    651          Receiving on USART 0:
    652          Since the UART can only talk to one device, we will hard-code some of the functionality.  Reception of bytes will
    653          simply dump into the UartRxBuffer and the task interested in those bytes can read the data.  In this case, we
    654          know that this is only the Debug / User interface task.  Though other tasks could also access the buffer, we
    655          assume they won't.
    656          
    657          ***********************************************************************************************************************/
    658          
    659          /*!-------------------------------------------------------------------------------------------------------------------
    660          @fn static void UartSM_Idle(void)
    661          
    662          @brief Wait for a transmit message to be queued.  Received data is handled in interrupts. 
    663          */

   \                                 In section .text, align 4, keep-with-next
    664          static void UartSM_Idle(void)
    665          {
   \                     UartSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    666            /* Check all UART peripherals for message activity or skip the current peripheral if it is already busy sending.
    667            All receive functions take place outside of the state machine.
    668            Devices sending a message will have Uart_psCurrentSsp->psTransmitBuffer->pu8Message pointing to the message to send. */
    669            if( (Uart_psCurrentUart->psTransmitBuffer != NULL) && 
    670               !(Uart_psCurrentUart->u32PrivateFlags & _UART_PERIPHERAL_TX ) )
   \   00000002   0x....             LDR.N    R0,??DataTable15_14
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD040             BEQ.N    ??UartSM_Idle_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_14
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x0280             LSLS     R0,R0,#+10
   \   00000014   0xD43B             BMI.N    ??UartSM_Idle_0
    671            {
    672              /* Transmitting: update the message's status and flag that the peripheral is now busy */
    673              UpdateMessageStatus(Uart_psCurrentUart->psTransmitBuffer->u32Token, SENDING);
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x....             LDR.N    R0,??DataTable15_14
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       UpdateMessageStatus
    674              Uart_psCurrentUart->u32PrivateFlags |= _UART_PERIPHERAL_TX;    
   \   00000024   0x....             LDR.N    R0,??DataTable15_14
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000002E   0x....             LDR.N    R1,??DataTable15_14
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
    675                
    676              /* Load the PDC counter and pointer registers */
    677              Uart_psCurrentUart->pBaseAddress->US_TPR = (unsigned int)Uart_psCurrentUart->psTransmitBuffer->pu8Message;
   \   00000034   0x....             LDR.N    R0,??DataTable15_14
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x3008             ADDS     R0,R0,#+8
   \   0000003C   0x....             LDR.N    R1,??DataTable15_14
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0xF8C1 0x0108      STR      R0,[R1, #+264]
    678              Uart_psCurrentUart->pBaseAddress->US_TCR = Uart_psCurrentUart->psTransmitBuffer->u32Size;
   \   00000046   0x....             LDR.N    R0,??DataTable15_14
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0x....             LDR.N    R1,??DataTable15_14
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0xF8C1 0x010C      STR      R0,[R1, #+268]
    679          
    680              /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
    681              Uart_psCurrentUart->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x....             LDR.N    R1,??DataTable15_14
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x6088             STR      R0,[R1, #+8]
    682              
    683              /* Update active UART count and enable the transmitter to start the transfer */
    684              Uart_u8ActiveUarts++;
   \   00000062   0x....             LDR.N    R0,??DataTable15_16
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable15_16
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    685              if(Uart_u8ActiveUarts > U8_MAX_NUM_UARTS)
   \   0000006C   0x....             LDR.N    R0,??DataTable15_16
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x2806             CMP      R0,#+6
   \   00000072   0xDB05             BLT.N    ??UartSM_Idle_1
    686              {
    687                /* Alert that the number of actual UARTs has been exceeded */
    688                Uart_u32Flags |= _UART_TOO_MANY_UARTS;
   \   00000074   0x....             LDR.N    R0,??DataTable15_15
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   0000007C   0x....             LDR.N    R1,??DataTable15_15
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    689              }
    690              Uart_psCurrentUart->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \                     ??UartSM_Idle_1: (+1)
   \   00000080   0xF44F 0x7080      MOV      R0,#+256
   \   00000084   0x....             LDR.N    R1,??DataTable15_14
   \   00000086   0x6809             LDR      R1,[R1, #+0]
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0xF8C1 0x0120      STR      R0,[R1, #+288]
    691            }
    692            
    693            /* Adjust to check the next peripheral next time through */
    694            switch (Uart_psCurrentUart->u8PeripheralId)
   \                     ??UartSM_Idle_0: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable15_14
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000096   0x2808             CMP      R0,#+8
   \   00000098   0xD006             BEQ.N    ??UartSM_Idle_2
   \   0000009A   0x280D             CMP      R0,#+13
   \   0000009C   0xD008             BEQ.N    ??UartSM_Idle_3
   \   0000009E   0x280E             CMP      R0,#+14
   \   000000A0   0xD00A             BEQ.N    ??UartSM_Idle_4
   \   000000A2   0x280F             CMP      R0,#+15
   \   000000A4   0xD00C             BEQ.N    ??UartSM_Idle_5
   \   000000A6   0xE01D             B.N      ??UartSM_Idle_6
    695            {
    696              case AT91C_ID_DBGU:
    697              {
    698                Uart_psCurrentUart = &Uart_sPeripheral0;
   \                     ??UartSM_Idle_2: (+1)
   \   000000A8   0x....             LDR.N    R0,??DataTable15_4
   \   000000AA   0x....             LDR.N    R1,??DataTable15_14
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    699                break;
   \   000000AE   0xE01C             B.N      ??UartSM_Idle_7
    700              }
    701              
    702              case AT91C_ID_US0:
    703              {
    704                Uart_psCurrentUart = &Uart_sPeripheral1;
   \                     ??UartSM_Idle_3: (+1)
   \   000000B0   0x....             LDR.N    R0,??DataTable15_11
   \   000000B2   0x....             LDR.N    R1,??DataTable15_14
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    705                break;
   \   000000B6   0xE018             B.N      ??UartSM_Idle_7
    706              }
    707              
    708              case AT91C_ID_US1:
    709              {  Uart_psCurrentUart = &Uart_sPeripheral2;
   \                     ??UartSM_Idle_4: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable15_13
   \   000000BA   0x....             LDR.N    R1,??DataTable15_14
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    710                break;
   \   000000BE   0xE014             B.N      ??UartSM_Idle_7
    711              }
    712              
    713              case AT91C_ID_US2:
    714              {
    715                Uart_psCurrentUart = &Uart_sPeripheral;
   \                     ??UartSM_Idle_5: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable15_3
   \   000000C2   0x....             LDR.N    R1,??DataTable15_14
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    716                
    717                /* Only clear _UART_MANUAL_MODE if all UARTs are done sending to ensure messages are sent during initialization */
    718                if( (G_u32SystemFlags & _SYSTEM_INITIALIZING) && !Uart_u8ActiveUarts)
   \   000000C6   0x....             LDR.N    R0,??DataTable15_7
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD509             BPL.N    ??UartSM_Idle_8
   \   000000CE   0x....             LDR.N    R0,??DataTable15_16
   \   000000D0   0x7800             LDRB     R0,[R0, #+0]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD105             BNE.N    ??UartSM_Idle_8
    719                {
    720                  Uart_u32Flags &= ~_UART_MANUAL_MODE;
   \   000000D6   0x....             LDR.N    R0,??DataTable15_15
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x0840             LSRS     R0,R0,#+1
   \   000000DC   0x0040             LSLS     R0,R0,#+1
   \   000000DE   0x....             LDR.N    R1,??DataTable15_15
   \   000000E0   0x6008             STR      R0,[R1, #+0]
    721                }
    722                break;
   \                     ??UartSM_Idle_8: (+1)
   \   000000E2   0xE002             B.N      ??UartSM_Idle_7
    723              }
    724              
    725              default:
    726              {
    727                Uart_psCurrentUart = &Uart_sPeripheral;
   \                     ??UartSM_Idle_6: (+1)
   \   000000E4   0x....             LDR.N    R0,??DataTable15_3
   \   000000E6   0x....             LDR.N    R1,??DataTable15_14
   \   000000E8   0x6008             STR      R0,[R1, #+0]
    728                break;
    729              }
    730            } /* end switch */
    731            
    732          } /* end UartSM_Idle() */
   \                     ??UartSM_Idle_7: (+1)
   \   000000EA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     Uart_sPeripheral

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     Uart_sPeripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     Uart_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x400E0600         DC32     0x400e0600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     Uart_sPeripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     Uart_sPeripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     Uart_psCurrentUart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x........         DC32     Uart_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x........         DC32     Uart_u8ActiveUarts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0xA5000001         DC32     0xa5000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x400E1250         DC32     0x400e1250

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x........         DC32     Uart_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x........         DC32     Uart_u32IntCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     Uart_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0x........         DC32     Uart_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x........         DC32     Uart_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0A 0x0D          DC8 "\012\015UART counter out of sync\012\015"
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x20 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    733          
    734          
    735          #if 0 /* Not currently used */
    736          /*!-------------------------------------------------------------------------------------------------------------------
    737          @fn static void UartSM_Error(void)
    738          
    739          @brief Handle an error
    740          */
    741          static void UartSM_Error(void)          
    742          {
    743            
    744          } /* end UartSM_Error() */
    745          #endif         
    746                    
    747                    
    748                    
    749                  
    750          /*--------------------------------------------------------------------------------------------------------------------*/
    751          /* End of File */
    752          /*--------------------------------------------------------------------------------------------------------------------*/
    753          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DBGU_IrqHandler
         8   -> UartGenericHandler
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   UART1_IRQHandler
         8   -> UartGenericHandler
       8   UART2_IRQHandler
         8   -> UartGenericHandler
       8   USART0_IrqHandler
         8   -> UartGenericHandler
       8   UartGenericHandler
         8   -- Indirect call
         8   -> DeQueueMessage
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       0   UartInitialize
       8   UartManualMode
         8   -> IsTimeUp
         8   -> MessagingRunActiveState
         8   -> UartRunActiveState
       8   UartRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   UartRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   UartRunActiveState
         8   -- Indirect call
       8   UartSM_Idle
         8   -> UpdateMessageStatus
      24   UartWriteByte
        24   -> QueueMessage
        24   -> UartManualMode
      24   UartWriteData
        24   -> QueueMessage
        24   -> UartManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      32  ?_0
      24  DBGU_IrqHandler
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      24  UART1_IRQHandler
      24  UART2_IRQHandler
      24  USART0_IrqHandler
     240  UartGenericHandler
     256  UartInitialize
      64  UartManualMode
      84  UartRelease
     238  UartRequest
      10  UartRunActiveState
     236  UartSM_Idle
      48  UartWriteByte
      52  UartWriteData
       4  Uart_pfnStateMachine
       4  Uart_psCurrentISR
       4  Uart_psCurrentUart
      36  Uart_sPeripheral
      36  Uart_sPeripheral0
      36  Uart_sPeripheral1
      36  Uart_sPeripheral2
       4  Uart_u32Flags
       4  Uart_u32Int0Count
       4  Uart_u32Int1Count
       4  Uart_u32Int2Count
       4  Uart_u32IntCount
       1  Uart_u8ActiveUarts

 
   177 bytes in section .bss
    32 bytes in section .rodata
 1 494 bytes in section .text
 
 1 494 bytes of CODE  memory
    32 bytes of CONST memory
   177 bytes of DATA  memory

Errors: none
Warnings: none
