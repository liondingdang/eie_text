###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\EIE_TEXT\二进制计数器\firmware_common\drivers\adc12.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\adc12.c -D EIE_ASCII
#        --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\adc12.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\adc12.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\adc12.c
      1          /*!**********************************************************************************************************************
      2          @file adc12.c 
      3          @brief 12-bit ADC driver and API
      4          
      5          Driver function to give access to the 12-bit ADC on the EiE development boards.  
      6          The ADC hardware is the same for the EiE 1 and EiE 2 development board Blade connectors.
      7          The EiE1 board has an additional on-board potentiometer for testing purporses.
      8          
      9          This driver currently only provides setup and single result read access from any
     10          channel on the ADC at a time.  Any averaging or special operations should be handled by the
     11          application using the driver.  This driver is set up as a state machine for future
     12          feature additions.
     13          
     14          The first sample tends to read 20-30 bits high.  If no sample is taken for a few minutes,
     15          the next first sample will also read high.  This implies a long time constant in the hold
     16          time, but the timing parameters that have been set all line up with the electrical
     17          characteristics and source impedence considerations.  So this is a mystery for
     18          now -- suggest the first sample is thrown out, or average it out with at least 16 samples
     19          per displayed result which will reduce the error down to 1 or 2 LSBs.  
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          GLOBALS
     23          - NONE
     24          
     25          CONSTANTS
     26          - NONE
     27          
     28          TYPES
     29          - Adc12ChannelType {ADC12_CH0 ... ADC12_CH7}
     30          
     31          PUBLIC FUNCTIONS
     32          - void Adc12AssignCallback(Adc12ChannelType eAdcChannel_, fnCode_u16_type pfUserCallback_)
     33          - bool Adc12StartConversion(Adc12ChannelType eAdcChannel_)
     34          
     35          PROTECTED FUNCTIONS
     36          - void Adc12Initialize(void)
     37          - void Adc12RunActiveState(void)
     38          - void ADCC0_IrqHandler(void)
     39          
     40          **********************************************************************************************************************/
     41          
     42          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable6  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable6_1  ;; 0xe000e280
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     43          
     44          /***********************************************************************************************************************
     45          Global variable definitions with scope across entire project.
     46          All Global variable names shall start with "G_<type>Adc12"
     47          ***********************************************************************************************************************/
     48          /* New variables */

   \                                 In section .bss, align 4
     49          volatile u32 G_u32Adc12Flags;                          /*!< @brief Global state flags */
   \                     G_u32Adc12Flags:
   \   00000000                      DS8 4
     50          
     51          
     52          /*--------------------------------------------------------------------------------------------------------------------*/
     53          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     54          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     55          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     56          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     57          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
     58          
     59          
     60          /***********************************************************************************************************************
     61          Global variable definitions with scope limited to this local application.
     62          Variable names shall start with "Adc12_<type>" and be declared as static.
     63          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     64          static fnCode_type Adc12_pfnStateMachine;              /*!< @brief The state machine function pointer */
   \                     Adc12_pfnStateMachine:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 1
     66          static bool Adc12_bAdcAvailable;                       /*!< @brief Binary semaphore to control access to the ADC12 peripheral */
   \                     Adc12_bAdcAvailable:
   \   00000000                      DS8 1
     67          

   \                                 In section .data, align 4
     68          static Adc12ChannelType Adc12_aeChannels[] = ADC_CHANNEL_ARRAY;  /*!< @brief Available channels defined in configuration.h */
   \                     Adc12_aeChannels:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 0
   \              0x03 0x00    

   \                                 In section .bss, align 4
     69          static fnCode_u16_type Adc12_apfCallbacks[8];          /*!< @brief ADC12 ISR callback function pointers */
   \                     Adc12_apfCallbacks:
   \   00000000                      DS8 32
     70          
     71          
     72          /**********************************************************************************************************************
     73          Function Definitions
     74          **********************************************************************************************************************/
     75          
     76          /*--------------------------------------------------------------------------------------------------------------------*/
     77          /*! @publicsection */                                                                                            
     78          /*--------------------------------------------------------------------------------------------------------------------*/
     79          
     80          /*!---------------------------------------------------------------------------------------------------------------------
     81          @fn void Adc12AssignCallback(Adc12ChannelType eAdcChannel_, fnCode_u16_type pfUserCallback_)
     82          
     83          @brief Assigns callback for the client application.  
     84          
     85          This is how the ADC result for any channel is accessed.  The callback function 
     86          must have one u16 parameter where the result is passed.  Define the function that 
     87          will be used for the callback, then assign this during user task initialization.
     88          
     89          Different callbacks may be assigned for each channel. 
     90          
     91          *** To mitigate the chance of indefinitely holding control of
     92          the ADC resource, new conversions shall not be started in this callback. ***
     93          
     94          Example:
     95          
     96          void UserApp_AdcCallback(u16 u16Result_);
     97          
     98          void UserApp1Initialize(void)
     99          {
    100           Adc12AssignCallback(ADC12_BLADE_AN0, UserApp_AdcCallback);
    101          }
    102          
    103          
    104          Requires:
    105          @param eAdcChannel_ is the channel to which the callback will be assigned
    106          @param pfUserCallback_ is the function address (name) for the user's callback
    107          
    108          Promises:
    109          - Adc12_fpCallbackCh<eAdcChannel_> ADC global value loaded with pfUserCallback_
    110          
    111          */

   \                                 In section .text, align 2, keep-with-next
    112          void Adc12AssignCallback(Adc12ChannelType eAdcChannel_, fnCode_u16_type pfUserCallback_)
    113          {
   \                     Adc12AssignCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    114            bool bChannelValid = FALSE;
   \   00000006   0x2600             MOVS     R6,#+0
    115          
    116            /* Check to ensure the requested channel exists */
    117            for(u8 i = 0; i < (sizeof(Adc12_aeChannels) / sizeof (Adc12ChannelType)); i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??Adc12AssignCallback_0: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD209             BCS.N    ??Adc12AssignCallback_1
    118            {
    119              if(Adc12_aeChannels[i] == eAdcChannel_)
   \   00000010   0x....             LDR.N    R1,??DataTable6_2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5C41             LDRB     R1,[R0, R1]
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x42A1             CMP      R1,R4
   \   0000001A   0xD101             BNE.N    ??Adc12AssignCallback_2
    120              {
    121                bChannelValid = TRUE;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x000E             MOVS     R6,R1
    122              }
    123            }
   \                     ??Adc12AssignCallback_2: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F2             B.N      ??Adc12AssignCallback_0
    124            
    125            /* If the channel is valid, then assign the new callback function */
    126            if(bChannelValid)
   \                     ??Adc12AssignCallback_1: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD004             BEQ.N    ??Adc12AssignCallback_3
    127            {
    128              Adc12_apfCallbacks[eAdcChannel_] = pfUserCallback_;
   \   0000002A   0x....             LDR.N    R0,??DataTable6_3
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   \   00000032   0xE002             B.N      ??Adc12AssignCallback_4
    129            }
    130            else
    131            {
    132              DebugPrintf("Invalid channel\n\r");
   \                     ??Adc12AssignCallback_3: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable6_4
   \   00000036   0x.... 0x....      BL       DebugPrintf
    133            }
    134            
    135          } /* end Adc12AssignCallback() */
   \                     ??Adc12AssignCallback_4: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    136          
    137          
    138          /*!---------------------------------------------------------------------------------------------------------------------
    139          @fn bool Adc12StartConversion(Adc12ChannelType eAdcChannel_)
    140          
    141          @brief Checks if the ADC is available and starts the conversion on the selected channel.
    142          
    143          Returns TRUE if the conversion is started; returns FALSE if the ADC is not available.
    144          
    145          Example:
    146          
    147          bool bConversionStarted = FALSE;
    148          
    149          bConversionStarted = Adc12StartConversion(ADC12_CH2);
    150          
    151          
    152          Requires:
    153          - Adc12_bAdcAvailable indicates if the ADC is available for a conversion
    154          
    155          @param eAdcChannel_ the ADC12 channel to disable
    156          
    157          Promises:
    158          
    159          If Adc12_bAdcAvailable is TRUE:
    160          - Adc12_bAdcAvailable changed to FALSE
    161          - ADC12B_CHER bit for eAdcChannel_ is set
    162          - ADC12B_IER bit for eAdcChannel_is set
    163          - Returns TRUE
    164          
    165          If Adc12_bAdcAvailable is FALSE:
    166          - Returns FALSE
    167          
    168          */

   \                                 In section .text, align 2, keep-with-next
    169          bool Adc12StartConversion(Adc12ChannelType eAdcChannel_)
    170          {
   \                     Adc12StartConversion: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    171            if(Adc12_bAdcAvailable)
   \   00000002   0x....             LDR.N    R0,??DataTable6_5
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD012             BEQ.N    ??Adc12StartConversion_0
    172            {
    173              /* Take the semaphore so we have the ADC resource.  Since this is a binary semaphore 
    174              that is only cleared in the ISR, it is safe to do this with interrupts enabled */
    175              Adc12_bAdcAvailable = FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R2,??DataTable6_5
   \   0000000E   0x7010             STRB     R0,[R2, #+0]
    176             
    177              /* Enable the channel and its interrupt */
    178              AT91C_BASE_ADC12B->ADC12B_CHER = (1 << eAdcChannel_);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4088             LSLS     R0,R0,R1
   \   00000014   0x....             LDR.N    R2,??DataTable6_6  ;; 0x400a8010
   \   00000016   0x6010             STR      R0,[R2, #+0]
    179              AT91C_BASE_ADC12B->ADC12B_IER  = (1 << eAdcChannel_);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4088             LSLS     R0,R0,R1
   \   0000001C   0x....             LDR.N    R2,??DataTable6_7  ;; 0x400a8024
   \   0000001E   0x6010             STR      R0,[R2, #+0]
    180            
    181              /* Start the conversion and exit */
    182              AT91C_BASE_ADC12B->ADC12B_CR |= AT91C_ADC12B_CR_START;
   \   00000020   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400a8000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000028   0x....             LDR.N    R2,??DataTable6_8  ;; 0x400a8000
   \   0000002A   0x6010             STR      R0,[R2, #+0]
    183              return TRUE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??Adc12StartConversion_1
    184            }
    185            
    186            /* The ADC is not available */
    187            return FALSE;
   \                     ??Adc12StartConversion_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??Adc12StartConversion_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    188          
    189          } /* end Adc12StartConversion() */
    190          
    191          
    192          /*--------------------------------------------------------------------------------------------------------------------*/
    193          /*! @protectedsection */                                                                                            
    194          /*--------------------------------------------------------------------------------------------------------------------*/
    195          
    196          /*!--------------------------------------------------------------------------------------------------------------------
    197          @fn void Adc12Initialize(void)
    198          
    199          @brief Runs required initialization for the task.  
    200          
    201          Should only be called once in main init section.
    202          
    203          Requires:
    204          - NONE
    205          
    206          Promises:
    207          - The ADC-12 peripheral is configured
    208          - ADC interrupt is enabled
    209          - Adc12_pfnStateMachine set to Idle
    210          
    211          */

   \                                 In section .text, align 2, keep-with-next
    212          void Adc12Initialize(void)
    213          {
   \                     Adc12Initialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    214            u8 au8Adc12Started[] = "ADC12 task initialized\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable6_9
   \   00000008   0x2219             MOVS     R2,#+25
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    215          
    216            /* Initialize peripheral registers. ADC starts totally disabled. */
    217            AT91C_BASE_ADC12B->ADC12B_MR   = ADC12B_MR_INIT;
   \   0000000E   0x....             LDR.N    R0,??DataTable6_10  ;; 0xf041700
   \   00000010   0x....             LDR.N    R1,??DataTable6_11  ;; 0x400a8004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    218            AT91C_BASE_ADC12B->ADC12B_CHDR = ADC12B_CHDR_INIT;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x....             LDR.N    R1,??DataTable6_12  ;; 0x400a8014
   \   00000018   0x6008             STR      R0,[R1, #+0]
    219            AT91C_BASE_ADC12B->ADC12B_ACR  = ADC12B_ACR_INIT;
   \   0000001A   0xF240 0x1001      MOVW     R0,#+257
   \   0000001E   0x....             LDR.N    R1,??DataTable6_13  ;; 0x400a8064
   \   00000020   0x6008             STR      R0,[R1, #+0]
    220            AT91C_BASE_ADC12B->ADC12B_EMR  = ADC12B_EMR_INIT;
   \   00000022   0x....             LDR.N    R0,??DataTable6_14  ;; 0x40001
   \   00000024   0x....             LDR.N    R1,??DataTable6_15  ;; 0x400a8068
   \   00000026   0x6008             STR      R0,[R1, #+0]
    221            AT91C_BASE_ADC12B->ADC12B_IDR  = ADC12B_IDR_INIT;
   \   00000028   0x....             LDR.N    R0,??DataTable6_16  ;; 0xfffff
   \   0000002A   0x....             LDR.N    R1,??DataTable6_17  ;; 0x400a8028
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    222            
    223            /* Set all the callbacks to default */
    224            for(u8 i = 0; i < (sizeof(Adc12_apfCallbacks) / sizeof(fnCode_u16_type)); i++)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??Adc12Initialize_0: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xD207             BCS.N    ??Adc12Initialize_1
    225            {
    226              Adc12_apfCallbacks[i] = Adc12DefaultCallback;
   \   00000036   0x.... 0x....      ADR.W    R1,Adc12DefaultCallback
   \   0000003A   0x....             LDR.N    R2,??DataTable6_3
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    227            }
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xE7F4             B.N      ??Adc12Initialize_0
    228            
    229            /* Mark the ADC semaphore as available */
    230            Adc12_bAdcAvailable = TRUE;
   \                     ??Adc12Initialize_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable6_5
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    231            
    232            /* Check initialization and set first state */
    233            if( 1 )
    234            {
    235              /* Enable required interrupts */
    236              NVIC_ClearPendingIRQ(IRQn_ADCC0);
   \   0000004C   0x201A             MOVS     R0,#+26
   \   0000004E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    237              NVIC_EnableIRQ(IRQn_ADCC0);
   \   00000052   0x201A             MOVS     R0,#+26
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    238              
    239              /* Write message, set "good" flag and select Idle state */
    240              DebugPrintf(au8Adc12Started);
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       DebugPrintf
    241              G_u32ApplicationFlags |= _APPLICATION_FLAGS_ADC;
   \   0000005E   0x....             LDR.N    R0,??DataTable6_18
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000066   0x....             LDR.N    R1,??DataTable6_18
   \   00000068   0x6008             STR      R0,[R1, #+0]
    242              Adc12_pfnStateMachine = Adc12SM_Idle;
   \   0000006A   0x.... 0x....      ADR.W    R0,Adc12SM_Idle
   \   0000006E   0x....             LDR.N    R1,??DataTable6_19
   \   00000070   0x6008             STR      R0,[R1, #+0]
    243            }
    244            else
    245            {
    246              /* The task isn't properly initialized, so shut it down and don't run */
    247              Adc12_pfnStateMachine = Adc12SM_Error;
    248            }
    249          
    250          } /* end Adc12Initialize() */
   \   00000072   0xB007             ADD      SP,SP,#+28
   \   00000074   0xBD00             POP      {PC}             ;; return
    251          
    252          
    253          /*!----------------------------------------------------------------------------------------------------------------------
    254          @fn void Adc12RunActiveState(void)
    255          
    256          @brief Selects and runs one iteration of the current state in the state machine.
    257          
    258          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    259          may take 1ms / n to execute.
    260          
    261          Requires:
    262          - State machine function pointer points at current state
    263          
    264          Promises:
    265          - Calls the function to pointed by the state machine function pointer
    266          
    267          */

   \                                 In section .text, align 2, keep-with-next
    268          void Adc12RunActiveState(void)
    269          {
   \                     Adc12RunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    270            Adc12_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable6_19
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    271          
    272          } /* end Adc12RunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    273          
    274          
    275          /*!----------------------------------------------------------------------------------------------------------------------
    276          @fn void ADCC0_IrqHandler(void)
    277          
    278          @brief Parses the ADC12 interrupts and handles them appropriately. 
    279          
    280          Note that all ADC12 interrupts are ORed and will trigger this handler, therefore 
    281          any expected interrupt that is enabled must be parsed out and handled.  There is 
    282          no obviously available explanation for why this handler is called ADCC0_IrqHandler 
    283          instead of ADC12B_IrqHandler
    284          
    285          Requires:
    286          - Only one channel can be converting at a time, so only one interrupt flag
    287            will be set.
    288          
    289          Promises:
    290          - Adc12_bAdcAvailable = TRUE
    291          
    292          */

   \                                 In section .text, align 2, keep-with-next
    293          void ADCC0_IrqHandler(void)
    294          {
   \                     ADCC0_IrqHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    295            u16 u16Adc12Result;
    296            
    297            /* WARNING: if you step through this handler with the ADC12B registers
    298            debugging, the debugger reads ADC12B_SR and clears the EOC flag bits */
    299          
    300            /* Check through all the available channels */
    301            for(u8 i = 0; i < (sizeof(Adc12_aeChannels) / sizeof(Adc12ChannelType)); i++)
   \   00000002   0x2500             MOVS     R5,#+0
   \                     ??ADCC0_IrqHandler_0: (+1)
   \   00000004   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000006   0x2D03             CMP      R5,#+3
   \   00000008   0xD221             BCS.N    ??ADCC0_IrqHandler_1
    302            {
    303              if(AT91C_BASE_ADC12B->ADC12B_SR & (1 << Adc12_aeChannels[i]))
   \   0000000A   0x....             LDR.N    R0,??DataTable6_20  ;; 0x400a801c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable6_2
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5C69             LDRB     R1,[R5, R1]
   \   00000014   0x40C8             LSRS     R0,R0,R1
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD517             BPL.N    ??ADCC0_IrqHandler_2
    304              {
    305                /* Read the channel's result register (clears EOC bit / interrupt) and send to callback */
    306                u16Adc12Result = AT91C_BASE_ADC12B->ADC12B_CDR[Adc12_aeChannels[i]];
   \   0000001A   0x....             LDR.N    R0,??DataTable6_21  ;; 0x400a8030
   \   0000001C   0x....             LDR.N    R1,??DataTable6_2
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x5C69             LDRB     R1,[R5, R1]
   \   00000022   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000026   0x0004             MOVS     R4,R0
    307                Adc12_apfCallbacks[Adc12_aeChannels[i]](u16Adc12Result);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x....             LDR.N    R1,??DataTable6_3
   \   0000002E   0x....             LDR.N    R2,??DataTable6_2
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x5CAA             LDRB     R2,[R5, R2]
   \   00000034   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   00000038   0x4788             BLX      R1
    308                
    309                /* Disable the channel and exit the loop since only one channel can be set */
    310                AT91C_BASE_ADC12B->ADC12B_CHDR = (1 << Adc12_aeChannels[i]);
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable6_2
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x5669             LDRSB    R1,[R5, R1]
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x....             LDR.N    R1,??DataTable6_12  ;; 0x400a8014
   \   00000046   0x6008             STR      R0,[R1, #+0]
    311                break;
   \   00000048   0xE001             B.N      ??ADCC0_IrqHandler_1
    312              }
    313            }
   \                     ??ADCC0_IrqHandler_2: (+1)
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0xE7DA             B.N      ??ADCC0_IrqHandler_0
    314            
    315            /* Give the Semaphore back, clear the ADC pending flag and exit */
    316            Adc12_bAdcAvailable = TRUE;
   \                     ??ADCC0_IrqHandler_1: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable6_5
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    317            NVIC->ICPR[0] = (1 << AT91C_ID_ADC12B);
   \   00000054   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000058   0x....             LDR.N    R1,??DataTable6_1  ;; 0xe000e280
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    318            
    319          } /* end ADCC0_IrqHandler() */
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    320          
    321          
    322          /*----------------------------------------------------------------------------------------------------------------------*/
    323          /*! @privatesection */                                                                                            
    324          /*----------------------------------------------------------------------------------------------------------------------*/
    325          
    326          /*!----------------------------------------------------------------------------------------------------------------------
    327          @fn void Adc12DefaultCallback(u16 u16Result_)
    328          
    329          @brief An empty function that the unset Adc Callbacks point to.  
    330          
    331          Expected that the user will set their own.
    332          
    333          Requires:
    334          @param u16Result_ Required for the ISR to pass the result to but not used
    335          
    336          Promises:
    337          - NONE
    338            
    339          */

   \                                 In section .text, align 4, keep-with-next
    340          void Adc12DefaultCallback(u16 u16Result_)
    341          {
    342            /* This is an empty function */
    343            
    344          } /* end Adc12DefaultCallback() */
   \                     Adc12DefaultCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    345          
    346          
    347          /***********************************************************************************************************************
    348          State Machine Declarations
    349          ***********************************************************************************************************************/
    350          
    351          /*!-------------------------------------------------------------------------------------------------------------------
    352          @fn static void Adc12SM_Idle(void)
    353          
    354          @brief Wait for a message to be queued 
    355          */

   \                                 In section .text, align 4, keep-with-next
    356          static void Adc12SM_Idle(void)
    357          {
    358              
    359          } /* end Adc12SM_Idle() */
   \                     Adc12SM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     Adc12_aeChannels

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     Adc12_apfCallbacks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     Adc12_bAdcAvailable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x400A8010         DC32     0x400a8010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x400A8024         DC32     0x400a8024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x400A8000         DC32     0x400a8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x0F041700         DC32     0xf041700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x400A8004         DC32     0x400a8004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x400A8014         DC32     0x400a8014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x400A8064         DC32     0x400a8064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x00040001         DC32     0x40001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x400A8068         DC32     0x400a8068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x000FFFFF         DC32     0xfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x400A8028         DC32     0x400a8028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x........         DC32     Adc12_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   0x400A801C         DC32     0x400a801c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_21:
   \   00000000   0x400A8030         DC32     0x400a8030

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x49 0x6E          DC8 "Invalid channel\012\015"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x44          DC8 "ADC12 task initialized\012\015"
   \              0x43 0x31    
   \              0x32 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    360               
    361          
    362          /*!-------------------------------------------------------------------------------------------------------------------
    363          @fn static void Adc12SM_Error(void)          
    364          
    365          @brief Handle an error 
    366          */
    367          static void Adc12SM_Error(void)          
    368          {
    369            
    370          } /* end Adc12SM_Error() */
    371          
    372          
    373          
    374          
    375          
    376          /*--------------------------------------------------------------------------------------------------------------------*/
    377          /* End of File                                                                                                        */
    378          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADCC0_IrqHandler
        16   -- Indirect call
      16   Adc12AssignCallback
        16   -> DebugPrintf
       0   Adc12DefaultCallback
      32   Adc12Initialize
        32   -> DebugPrintf
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
        32   -> __aeabi_memcpy
       8   Adc12RunActiveState
         8   -- Indirect call
       0   Adc12SM_Idle
       0   Adc12StartConversion
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      20  ?_0
      28  ?_1
      94  ADCC0_IrqHandler
      60  Adc12AssignCallback
       2  Adc12DefaultCallback
     118  Adc12Initialize
      10  Adc12RunActiveState
       2  Adc12SM_Idle
      52  Adc12StartConversion
       4  Adc12_aeChannels
      32  Adc12_apfCallbacks
       1  Adc12_bAdcAvailable
       4  Adc12_pfnStateMachine
       4  G_u32Adc12Flags
      20  NVIC_ClearPendingIRQ
      20  NVIC_EnableIRQ

 
  41 bytes in section .bss
   4 bytes in section .data
  48 bytes in section .rodata
 466 bytes in section .text
 
 466 bytes of CODE  memory
  48 bytes of CONST memory
  45 bytes of DATA  memory

Errors: none
Warnings: none
