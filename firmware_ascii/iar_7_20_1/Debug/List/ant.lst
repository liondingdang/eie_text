###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:30
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant.c -D EIE_ASCII
#        --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ant.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ant.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant.c
      1          /*!**********************************************************************************************************************
      2          @file ant.c                                                               
      3          @brief ANT implementation for Atmel SAM3U2 Cortex-M3 / Ant slave SPI.  
      4          
      5          This driver requires synchronous SPI slave connection to an AP2 or AP2-emulated 
      6          ANT device.  The ANT device is the SPI Master.  All interface layer code 
      7          is maintained here.  
      8          
      9          Transmitted messages are sent through the Message task; 
     10          Received messages use an SSP peripheral with SPI_SLAVE_FLOW_CONTROL.
     11          
     12          The functions here can be used directly but are more intended
     13          to be used with ant_api.c to simplify operation with ANT.  
     14          However, that simplification leads to the loss of some details
     15          that may be important to more complicated applications.
     16          
     17          Therefore, we describe the API that is available here but
     18          suggest anyone new to using ANT access it through ant_api.c
     19          
     20          ------------------------------------------------------------------------------------------------------------------------
     21          GLOBALS
     22          - AntApplicationMsgListType *G_psAntApplicationMsgList
     23          - AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]
     24          - AntMessageResponseType G_stAntMessageResponse
     25          - u32 G_u32AntFlags
     26          
     27          CONSTANTS
     28          - ANT_APPLICATION_MESSAGE_BYTES
     29          - ANT_NUM_CHANNELS
     30          - ANT_RX_BUFFER_SIZE
     31          
     32          TYPES
     33          - AntChannelStatusType
     34          - AntApplicationMessageType
     35          - AntChannelNumberType
     36          - AntExtendedDataType
     37          - AntApplicationMsgListType
     38          - AntAssignChannelInfoType
     39          - AntMessageResponseType
     40          - AntOutgoingMessageListType
     41          
     42          PUBLIC FUNCTIONS
     43          - u8 AntCalculateTxChecksum(u8* pu8Message_)
     44          - bool AntQueueOutgoingMessage(u8 *pu8Message_)
     45          - void AntDeQueueApplicationMessage(void)
     46          
     47          PROTECTED FUNCTIONS
     48          - void AntInitialize(void)
     49          - void AntRunActiveState(void)
     50          - void AntTxFlowControlCallback(void)
     51          - void AntRxFlowControlCallback(void)
     52          
     53          
     54          ***********************************************************************************************************************/
     55          
     56          #include "configuration.h"
     57          
     58          /***********************************************************************************************************************
     59          Global variable definitions with scope across entire project.
     60          All Global variable names shall start with "G_<type>Ant"
     61          ***********************************************************************************************************************/
     62          
     63          /* New variables */

   \                                 In section .bss, align 4
     64          u32 G_u32AntFlags;                                    /*!< @brief Flag bits for ANT-related information */
   \                     G_u32AntFlags:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /*!< @brief Keeps track of all configured ANT channels */
   \                     G_asAntChannelConfiguration:
   \   00000000                      DS8 160

   \                                 In section .bss, align 4
     67          AntMessageResponseType G_stAntMessageResponse;           /*!< @brief Holds the latest message response info */
   \                     G_stAntMessageResponse:
   \   00000000                      DS8 4
     68          

   \                                 In section .bss, align 4
     69          AntApplicationMsgListType *G_psAntApplicationMsgList;  /*!< @brief Public linked list of messages from ANT to the application */
   \                     G_psAntApplicationMsgList:
   \   00000000                      DS8 4
     70          
     71          /*! @cond DOXYGEN_EXCLUDE */

   \                                 In section .data, align 4
     72          u8 G_au8AntMessageOk[]     = "OK\n\r";
   \                     G_au8AntMessageOk:
   \   00000000   0x4F 0x4B          DC8 "OK\012\015"
   \              0x0A 0x0D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     73          u8 G_au8AntMessageFail[  ] = "FAIL\n\r";
   \                     G_au8AntMessageFail:
   \   00000000   0x46 0x41          DC8 "FAIL\012\015"
   \              0x49 0x4C    
   \              0x0A 0x0D    
   \              0x00         
   \   00000007   0x00               DC8 0
     74          
     75          /* Replace 'd' at [12] with channel number */

   \                                 In section .data, align 4
     76          u8 G_au8AntMessageAssign[]    = "ANT channel d assign "; 
   \                     G_au8AntMessageAssign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d assign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .data, align 4
     77          u8 G_au8AntMessageUnassign[]  = "ANT channel d unassign ";
   \                     G_au8AntMessageUnassign:
   \   00000000   0x41 0x4E          DC8 "ANT channel d unassign "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x75 0x6E    
   \              0x61 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x20 0x00    

   \                                 In section .data, align 4
     78          u8 G_au8AntMessageUnhandled[] = "ANT channel d message 0xxx response dd ";
   \                     G_au8AntMessageUnhandled:
   \   00000000   0x41 0x4E          DC8 "ANT channel d message 0xxx response dd "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x30 0x78    
   \              0x78 0x78    
   \              0x20 0x72    
   \              0x65 0x73    
   \              0x70 0x6F    
   \              0x6E 0x73    
   \              0x65 0x20    
   \              0x64 0x64    
   \              0x20 0x00    

   \                                 In section .data, align 4
     79          u8 G_au8AntMessageSetup[] = "ANT channel d setup ";
   \                     G_au8AntMessageSetup:
   \   00000000   0x41 0x4E          DC8 "ANT channel d setup "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x75    
   \              0x70 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     80          u8 G_au8AntMessageClose[] = "ANT channel d close ";
   \                     G_au8AntMessageClose:
   \   00000000   0x41 0x4E          DC8 "ANT channel d close "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     81          u8 G_au8AntMessageOpen[]  = "ANT channel d open ";
   \                     G_au8AntMessageOpen:
   \   00000000   0x41 0x4E          DC8 "ANT channel d open "
   \              0x54 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x64 0x20    
   \              0x6F 0x70    
   \              0x65 0x6E    
   \              0x20 0x00    
     82          

   \                                 In section .data, align 4
     83          u8 G_au8AntMessageInit[]  = "Initializing ANT... ";
   \                     G_au8AntMessageInit:
   \   00000000   0x49 0x6E          DC8 "Initializing ANT... "
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x69    
   \              0x6E 0x67    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x2E 0x2E    
   \              0x2E 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
     84          u8 G_au8AntMessageInitFail[] = "failed. Host IOs set to HiZ.\r\n";
   \                     G_au8AntMessageInitFail:
   \   00000000   0x66 0x61          DC8 "failed. Host IOs set to HiZ.\015\012"
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x48 0x6F    
   \              0x73 0x74    
   \              0x20 0x49    
   \              0x4F 0x73    
   \              0x20 0x73    
   \              0x65 0x74    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x48 0x69    
   \              0x5A 0x2E    
   \              0x0D 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .data, align 4
     85          u8 G_au8AntMessageNoAnt[] = "\n\r## nRF51422 Programming Mode: no ANT functionality ##\n\n\r";
   \                     G_au8AntMessageNoAnt:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 23H, 23H, 20H, 6EH, 52H, 46H
   \              0x23 0x23    
   \              0x20 0x6E    
   \              0x52 0x46    
   \   00000008   0x35 0x31          DC8 35H, 31H, 34H, 32H, 32H, 20H, 50H, 72H
   \              0x34 0x32    
   \              0x32 0x20    
   \              0x50 0x72    
   \   00000010   0x6F 0x67          DC8 6FH, 67H, 72H, 61H, 6DH, 6DH, 69H, 6EH
   \              0x72 0x61    
   \              0x6D 0x6D    
   \              0x69 0x6E    
   \   00000018   0x67 0x20          DC8 67H, 20H, 4DH, 6FH, 64H, 65H, 3AH, 20H
   \              0x4D 0x6F    
   \              0x64 0x65    
   \              0x3A 0x20    
   \   00000020   0x6E 0x6F          DC8 6EH, 6FH, 20H, 41H, 4EH, 54H, 20H, 66H
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x20 0x66    
   \   00000028   0x75 0x6E          DC8 75H, 6EH, 63H, 74H, 69H, 6FH, 6EH, 61H
   \              0x63 0x74    
   \              0x69 0x6F    
   \              0x6E 0x61    
   \   00000030   0x6C 0x69          DC8 6CH, 69H, 74H, 79H, 20H, 23H, 23H, 0AH
   \              0x74 0x79    
   \              0x20 0x23    
   \              0x23 0x0A    
   \   00000038   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   0000003B   0x00               DC8 0
     86          
     87          /* ANT message structures */

   \                                 In section .data, align 4
     88          u8 G_au8AntSetNetworkKey[]    = {MESG_NETWORK_KEY_SIZE, MESG_NETWORK_KEY_ID, 0 /* Network number */, 
   \                     G_au8AntSetNetworkKey:
   \   00000000   0x09 0x46          DC8 9, 70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     89                                           0 /* KEY0 */, 0 /* KEY1 */, 0 /* KEY2 */, 0 /* KEY3 */, 
     90                                           0 /* KEY4 */, 0 /* KEY5 */, 0 /* KEY6 */, 0 /* KEY7 */, CS};

   \                                 In section .data, align 4
     91          u8 G_au8AntAssignChannel[]    = {MESG_ASSIGN_CHANNEL_SIZE, MESG_ASSIGN_CHANNEL_ID, 0 /* AntChannel */, 
   \                     G_au8AntAssignChannel:
   \   00000000   0x03 0x42          DC8 3, 66, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     92                                           0 /* AntChannelType */, 0 /* AntNetwork */, CS};

   \                                 In section .data, align 4
     93          u8 G_au8AntSetChannelID[]     = {MESG_CHANNEL_ID_SIZE, MESG_CHANNEL_ID_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelID:
   \   00000000   0x05 0x51          DC8 5, 81, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     94                                           0 /* AntDeviceIdLo */, 0 /* AntDeviceIdHi */, 0 /* AntDeviceType */, 
     95                                           0 /* AntTransmissionType */, CS};

   \                                 In section .data, align 4
     96          u8 G_au8AntSetChannelPeriod[] = {MESG_CHANNEL_MESG_PERIOD_SIZE, MESG_CHANNEL_MESG_PERIOD_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPeriod:
   \   00000000   0x03 0x43          DC8 3, 67, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     97                                           0 /* AntChannelPeriodLo */, 0 /* AntChannelPeriodHi */, CS};

   \                                 In section .data, align 4
     98          u8 G_au8AntSetChannelRFFreq[] = {MESG_CHANNEL_RADIO_FREQ_SIZE, MESG_CHANNEL_RADIO_FREQ_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelRFFreq:
   \   00000000   0x02 0x45          DC8 2, 69, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
     99                                           0 /* AntFrequency */, CS};           

   \                                 In section .data, align 4
    100          u8 G_au8AntSetChannelPower[]  = {MESG_RADIO_TX_POWER_SIZE, MESG_RADIO_TX_POWER_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetChannelPower:
   \   00000000   0x02 0x47          DC8 2, 71, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    101                                           0 /* AntTxPower */, CS};        

   \                                 In section .data, align 4
    102          u8 G_au8AntSetSearchTimeout[] = {MESG_CHANNEL_SEARCH_TIMEOUT_SIZE, MESG_CHANNEL_SEARCH_TIMEOUT_ID, 0 /* AntChannel */, 
   \                     G_au8AntSetSearchTimeout:
   \   00000000   0x02 0x44          DC8 2, 68, 0, 255, 0, 0, 0, 0
   \              0x00 0xFF    
   \              0x00 0x00    
   \              0x00 0x00    
    103                                           0xFF /* SearchTime (0xFF = infinite) */, CS};        

   \                                 In section .data, align 4
    104          u8 G_au8AntLibConfig[]        = {MESG_LIB_CONFIG_SIZE, MESG_LIB_CONFIG_ID, 0, LIB_CONFIG_CHANNEL_ID_FLAG | LIB_CONFIG_RSSI_FLAG, CS};        
   \                     G_au8AntLibConfig:
   \   00000000   0x02 0x6E          DC8 2, 110, 0, 192, 0, 0, 0, 0
   \              0x00 0xC0    
   \              0x00 0x00    
   \              0x00 0x00    
    105          

   \                                 In section .data, align 4
    106          u8 G_au8AntBroadcastDataMessage[] = {MESG_DATA_SIZE, MESG_BROADCAST_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntBroadcastDataMessage:
   \   00000000   0x09 0x4E          DC8 9, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
    107          u8 G_au8AntAckDataMessage[] = {MESG_DATA_SIZE, MESG_ACKNOWLEDGED_DATA_ID, CH, D_0, D_1, D_2, D_3, D_4, D_5, D_6, D_7, CS};
   \                     G_au8AntAckDataMessage:
   \   00000000   0x09 0x4F          DC8 9, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
    108          u8 G_au8ANTGetVersion[]     = {MESG_REQUEST_SIZE, MESG_REQUEST_ID, 0, MESG_VERSION_ID, 0};   
   \                     G_au8ANTGetVersion:
   \   00000000   0x02 0x4D          DC8 2, 77, 0, 62, 0, 0, 0, 0
   \              0x00 0x3E    
   \              0x00 0x00    
   \              0x00 0x00    
    109          /*! @endcond */
    110          
    111          
    112          /*----------------------------------------------------------------------------*/
    113          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
    114          and indicate what file the variable is defined in. */
    115          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
    116          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
    117          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
    118          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
    119          
    120          extern volatile u32 ANT_SSP_FLAGS;                     /*!< @brief From configuration.h */
    121          
    122          
    123          /***********************************************************************************************************************
    124          Global variable definitions with scope limited to this local application.
    125          Variable names shall start with "Ant_<type>Name" and be declared as static.
    126          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    127          static fnCode_type Ant_pfnStateMachine;                 /*!< @brief The ANT state machine function pointer */
   \                     Ant_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    128          static u32 Ant_u32RxTimer;                              /*!< @brief Dedicated timer for receiving bytes */
   \                     Ant_u32RxTimer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    129          static u32 Ant_u32TxTimer;                              /*!< @brief Dedicated timer for transmitting bytes */
   \                     Ant_u32TxTimer:
   \   00000000                      DS8 4
    130          

   \                                 In section .bss, align 4
    131          static u32 Ant_u32TxByteCounter = 0;                    /*!< @brief Counter counts callbacks on sent bytes */
   \                     Ant_u32TxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    132          static u32 Ant_u32RxByteCounter = 0;                    /*!< @brief Counter counts callbacks on received bytes */
   \                     Ant_u32RxByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    133          static u32 Ant_u32RxTimeoutCounter = 0;                 /*!< @brief Increments any time an ANT reception times out */
   \                     Ant_u32RxTimeoutCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    134          static u32 Ant_u32UnexpectedByteCounter = 0;            /*!< @brief Increments any time a byte is received that was not expected value */
   \                     Ant_u32UnexpectedByteCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    135          static u32 Ant_u32CurrentTxMessageToken = 0;            /*!< @brief Token for message currently being sent to ANT */
   \                     Ant_u32CurrentTxMessageToken:
   \   00000000                      DS8 4
    136          

   \                                 In section .bss, align 4
    137          static SspConfigurationType Ant_sSspConfig;             /*!< @brief Configuration information for SSP peripheral */
   \                     Ant_sSspConfig:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    138          static SspPeripheralType* Ant_Ssp;                      /*!< @brief Pointer to Ant's SSP peripheral object */
   \                     Ant_Ssp:
   \   00000000                      DS8 4
    139          

   \                                 In section .bss, align 4
    140          static u8 Ant_u8AntVersion[MESG_VERSION_SIZE];          /*!< @brief ANT device version string */
   \                     Ant_u8AntVersion:
   \   00000000                      DS8 12
    141          

   \                                 In section .bss, align 4
    142          static u8 Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE];       /*!< @brief Space for received ANT message bytes used by SSP */
   \                     Ant_au8AntRxBuffer:
   \   00000000                      DS8 256

   \                                 In section .bss, align 4
    143          static u8 *Ant_pu8AntRxBufferNextChar;                  /*!< @brief Pointer to next char to be written in the AntRxBuffer used by SSP */
   \                     Ant_pu8AntRxBufferNextChar:
   \   00000000                      DS8 4
    144          

   \                                 In section .bss, align 4
    145          static u8 *Ant_pu8AntRxBufferCurrentChar;               /*!< @brief Pointer to the current char in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferCurrentChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    146          static u8 *Ant_pu8AntRxBufferUnreadMsg;                 /*!< @brief Pointer to unread chars in the AntRxBuffer */
   \                     Ant_pu8AntRxBufferUnreadMsg:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    147          static u8 Ant_u8AntNewRxMessages;                       /*!< @brief Counter for number of new messages in AntRxBuffer */
   \                     Ant_u8AntNewRxMessages:
   \   00000000                      DS8 1
    148          

   \                                 In section .bss, align 4
    149          static u32 Ant_u32ApplicationMessageCount = 0;          /*!< @brief Counts messages queued on G_psAntApplicationMsgList */
   \                     Ant_u32ApplicationMessageCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    150          static AntOutgoingMessageListType *Ant_psOutgoingMsgList; /*!< @brief Linked list of outgoing ANT-formatted messages */
   \                     Ant_psOutgoingMsgList:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    151          static u32 Ant_u32OutgoingMessageCount = 0;             /*!< @brief Counts messages queued on Ant_psOutgoingMsgList */
   \                     Ant_u32OutgoingMessageCount:
   \   00000000                      DS8 4
    152          

   \                                 In section .bss, align 1
    153          static u8 Ant_u8SlaveMissedMessageHigh = 0;             /*!< @brief Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageHigh:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    154          static u8 Ant_u8SlaveMissedMessageMid = 0;              /*!< @brief Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageMid:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    155          static u8 Ant_u8SlaveMissedMessageLow = 0;              /*!< @brief Counter for missed messages if device is a slave */
   \                     Ant_u8SlaveMissedMessageLow:
   \   00000000                      DS8 1
    156          

   \                                 In section .data, align 4
    157          static u8 Ant_au8AddMessageFailMsg[] = "\n\rNo space in AntQueueOutgoingMessage\n\r";
   \                     Ant_au8AddMessageFailMsg:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueOutgoingMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x4F 0x75    
   \              0x74 0x67    
   \              0x6F 0x69    
   \              0x6E 0x67    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    
    158          
    159          
    160          /* Debug variables */

   \                                 In section .bss, align 4
    161          static u32 Ant_DebugRxMessageCounter   = 0;             /*!< @brief Number of visits to the RxMessage state */
   \                     Ant_DebugRxMessageCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    162          static u32 Ant_DebugTotalRxMessages    = 0;             /*!< @brief Number of message received in AntRxMessage */
   \                     Ant_DebugTotalRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    163          static u32 Ant_DebugProcessRxMessages  = 0;             /*!< @brief Calls to AntProcessMessage */
   \                     Ant_DebugProcessRxMessages:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    164          static u32 Ant_DebugQueuedDataMessages = 0;             /*!< @brief Calls to AntQueueOutgoingMessage */
   \                     Ant_DebugQueuedDataMessages:
   \   00000000                      DS8 4
    165          
    166          
    167          /***********************************************************************************************************************
    168          Function definitions
    169          ***********************************************************************************************************************/
    170          
    171          /*--------------------------------------------------------------------------------------------------------------------*/
    172          /*! @publicsection */                                                                                            
    173          /*--------------------------------------------------------------------------------------------------------------------*/
    174          /* Public Interface-Layer functions */
    175          
    176          
    177          /*!------------------------------------------------------------------------------
    178          @fn u8 AntCalculateTxChecksum(u8* pu8Message_)
    179          
    180          @brief Calculates and returns the checksum for a Host to ANT message.
    181          
    182          Requires:
    183          - the message to transmit is a complete ANT message without the SYNC byte 
    184          (it starts with length byte)
    185          
    186          @param pu8Message_ points to the message to transmit
    187          
    188          Promises:
    189          - Returns the ANT checksum for the Tx message
    190          
    191          */

   \                                 In section .text, align 2, keep-with-next
    192          u8 AntCalculateTxChecksum(u8* pu8Message_)
    193          {
   \                     AntCalculateTxChecksum: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    194            /* Adjust for the true size and automatically include MESG_RX_SYNC */ 
    195            u8 u8Size = *pu8Message_ + 2;
   \   00000004   0x7808             LDRB     R0,[R1, #+0]
   \   00000006   0x1C82             ADDS     R2,R0,#+2
    196            u8 u8Checksum = MESG_RX_SYNC;
   \   00000008   0x20A5             MOVS     R0,#+165
    197            
    198            /* Find the checksum per the ANT checksum algorithm */
    199            for(u8 i = 0; i < u8Size; i++)
   \   0000000A   0x2300             MOVS     R3,#+0
   \                     ??AntCalculateTxChecksum_0: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000000E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000010   0x4293             CMP      R3,R2
   \   00000012   0xD204             BCS.N    ??AntCalculateTxChecksum_1
    200            {
    201              u8Checksum ^= *pu8Message_;
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x4060             EORS     R0,R4,R0
    202              pu8Message_++;
   \   00000018   0x1C49             ADDS     R1,R1,#+1
    203            }
   \   0000001A   0x1C5B             ADDS     R3,R3,#+1
   \   0000001C   0xE7F6             B.N      ??AntCalculateTxChecksum_0
    204            
    205            return(u8Checksum);
   \                     ??AntCalculateTxChecksum_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    206            
    207          } /* end AntCalculateTxChecksum() */
    208          
    209          
    210          /*!-----------------------------------------------------------------------------
    211          @fn bool AntQueueOutgoingMessage(u8 *pu8Message_)
    212          
    213          @brief Creates a new ANT message structure and adds it into Ant_psOutgoingMsgList.
    214          
    215          If the list is full, the message is not added.
    216          The Outgoing message list is the list of messages sent from the Host to the ANT chip.
    217          
    218          Requires:
    219          - Enough space is available on the heap
    220          
    221          @param pu8Message_ is an ANT-formatted message starting with LENGTH and ending with CHECKSUM
    222          
    223          Promises:
    224          - A new list item in the outgoing message linked list is created and inserted at the end
    225            of the list as long as there is enough room.
    226          - Returns TRUE if the entry is added successfully.
    227          - Returns FALSE on error.
    228          
    229          */

   \                                 In section .text, align 2, keep-with-next
    230          bool AntQueueOutgoingMessage(u8 *pu8Message_)
    231          {
   \                     AntQueueOutgoingMessage: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
    232            u8 u8Length;
    233            u8 u8MessageCount = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    234            AntOutgoingMessageListType *psNewDataMessage;
    235            AntOutgoingMessageListType *psListParser;
    236            
    237            /* Allocate space for the new message - always do maximum message size */
    238            psNewDataMessage = malloc( sizeof(AntOutgoingMessageListType) );
   \   00000008   0x201C             MOVS     R0,#+28
   \   0000000A   0x.... 0x....      BL       malloc
   \   0000000E   0x0007             MOVS     R7,R0
    239            if (psNewDataMessage == NULL)
   \   00000010   0x2F00             CMP      R7,#+0
   \   00000012   0xD105             BNE.N    ??AntQueueOutgoingMessage_0
    240            {
    241              DebugPrintf(Ant_au8AddMessageFailMsg);
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable13
   \   00000018   0x.... 0x....      BL       DebugPrintf
    242              return(FALSE);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE04B             B.N      ??AntQueueOutgoingMessage_1
    243            }
    244            
    245            /* Add to the number of queued message */
    246            Ant_DebugQueuedDataMessages++;
   \                     ??AntQueueOutgoingMessage_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable11
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    247          
    248            /* Fill in all the fields of the newly allocated message structure */
    249            u8Length = *pu8Message_ + 3;
   \   0000002E   0x7820             LDRB     R0,[R4, #+0]
   \   00000030   0x1CC0             ADDS     R0,R0,#+3
   \   00000032   0x0005             MOVS     R5,R0
    250            for(u8 i = 0; i < u8Length; i++)
   \   00000034   0x2000             MOVS     R0,#+0
   \                     ??AntQueueOutgoingMessage_2: (+1)
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000003A   0x42A8             CMP      R0,R5
   \   0000003C   0xD206             BCS.N    ??AntQueueOutgoingMessage_3
    251            {
    252              psNewDataMessage->au8MessageData[i] = *(pu8Message_ + i);
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x5D01             LDRB     R1,[R0, R4]
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x19C2             ADDS     R2,R0,R7
   \   00000046   0x7111             STRB     R1,[R2, #+4]
    253            }
   \   00000048   0x1C40             ADDS     R0,R0,#+1
   \   0000004A   0xE7F4             B.N      ??AntQueueOutgoingMessage_2
    254            
    255            psNewDataMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueOutgoingMessage_3: (+1)
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0x6038             STR      R0,[R7, #+0]
    256            psNewDataMessage->psNextMessage = NULL;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x61B8             STR      R0,[R7, #+24]
    257          
    258            /* Insert into an empty list */
    259            if(Ant_psOutgoingMsgList == NULL)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD10A             BNE.N    ??AntQueueOutgoingMessage_4
    260            {
    261              Ant_psOutgoingMsgList = psNewDataMessage;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000066   0x6007             STR      R7,[R0, #+0]
    262              Ant_u32OutgoingMessageCount++;
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000074   0x6008             STR      R0,[R1, #+0]
   \   00000076   0xE01E             B.N      ??AntQueueOutgoingMessage_5
    263            }
    264          
    265            /* Otherwise traverse the list to find the end where the new message will be inserted */
    266            else
    267            {
    268              psListParser = Ant_psOutgoingMsgList;
   \                     ??AntQueueOutgoingMessage_4: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x4680             MOV      R8,R0
    269              while(psListParser->psNextMessage != NULL)  
   \                     ??AntQueueOutgoingMessage_6: (+1)
   \   00000080   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD003             BEQ.N    ??AntQueueOutgoingMessage_7
    270              {
    271                psListParser = psListParser->psNextMessage;
   \   00000088   0xF8D8 0x8018      LDR      R8,[R8, #+24]
    272                u8MessageCount++;
   \   0000008C   0x1C76             ADDS     R6,R6,#+1
   \   0000008E   0xE7F7             B.N      ??AntQueueOutgoingMessage_6
    273              }
    274              
    275              /* Check for a full list */
    276              if(u8MessageCount < ANT_OUTGOING_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueOutgoingMessage_7: (+1)
   \   00000090   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000092   0x2E20             CMP      R6,#+32
   \   00000094   0xD209             BCS.N    ??AntQueueOutgoingMessage_8
    277              {
    278                /* Insert the new message at the end of the list */
    279                psListParser->psNextMessage = psNewDataMessage;
   \   00000096   0xF8C8 0x7018      STR      R7,[R8, #+24]
    280                Ant_u32OutgoingMessageCount++;
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000A6   0x6008             STR      R0,[R1, #+0]
   \   000000A8   0xE005             B.N      ??AntQueueOutgoingMessage_5
    281              }
    282              else
    283              {
    284                DebugPrintf(Ant_au8AddMessageFailMsg);
   \                     ??AntQueueOutgoingMessage_8: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable13
   \   000000AE   0x.... 0x....      BL       DebugPrintf
    285                return(FALSE);
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0xE000             B.N      ??AntQueueOutgoingMessage_1
    286              }
    287            }
    288              
    289            return(TRUE);
   \                     ??AntQueueOutgoingMessage_5: (+1)
   \   000000B6   0x2001             MOVS     R0,#+1
   \                     ??AntQueueOutgoingMessage_1: (+1)
   \   000000B8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    290            
    291          } /* end AntQueueOutgoingMessage() */
    292          
    293          
    294          /*!-----------------------------------------------------------------------------
    295          @fn void AntDeQueueApplicationMessage(void)
    296          
    297          @brief Releases the first message in G_psAntApplicationMsgList 
    298          
    299          Requires:
    300          - G_psAntApplicationMsgList points to the start of the list which is the entry to remove
    301          
    302          Promises:
    303          - G_psAntApplicationMsgList = G_psAntApplicationMsgList.
    304          
    305          */

   \                                 In section .text, align 2, keep-with-next
    306          void AntDeQueueApplicationMessage(void)
    307          {
   \                     AntDeQueueApplicationMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    308            AntApplicationMsgListType *psMessageToKill;
    309            
    310            if(G_psAntApplicationMsgList != NULL)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??AntDeQueueApplicationMessage_0
    311            {
    312              psMessageToKill = G_psAntApplicationMsgList;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x0004             MOVS     R4,R0
    313              G_psAntApplicationMsgList = G_psAntApplicationMsgList->psNextMessage;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable12
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x6980             LDR      R0,[R0, #+24]
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000020   0x6008             STR      R0,[R1, #+0]
    314          
    315              /* The doomed message is properly disconnected, so kill it */
    316              free(psMessageToKill);
   \   00000022   0x0020             MOVS     R0,R4
   \   00000024   0x.... 0x....      BL       free
    317              Ant_u32ApplicationMessageCount--;
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable15
   \   00000034   0x6008             STR      R0,[R1, #+0]
    318            }
    319            
    320          } /* end AntDeQueueApplicationMessage() */
   \                     ??AntDeQueueApplicationMessage_0: (+1)
   \   00000036   0xBD10             POP      {R4,PC}          ;; return
    321          
    322          
    323          /*--------------------------------------------------------------------------------------------------------------------*/
    324          /*! @protectedsection */                                                                                            
    325          /*--------------------------------------------------------------------------------------------------------------------*/
    326          /* Protected Interface-Layer Functions */
    327          
    328          
    329          /*!------------------------------------------------------------------------------
    330          @fn void AntInitialize(void)
    331          
    332          @brief Initialize the ANT system.  
    333          
    334          The ANT device is reset and communication checked through a version request.  
    335          The main channel parameters are then set up to default values.
    336          
    337          The user can override this function by holding BUTTON3
    338          during startup. 
    339            
    340          Requires:
    341          - ANT_SPI peripheral is correctly configured
    342          - Debug system is initialized so debug messages can be sent to UART
    343          
    344          Promises:
    345          
    346          If successful:
    347          - G_stAntSetupData set to default ANT values
    348          - G_u32ApplicationFlags _APPLICATION_FLAGS_ANT bit is set
    349          - Ant_pfnStateMachine = AntSM_Idle
    350          
    351          If failed or override:
    352          - G_u32SystemFlags _SYSTEM_STARTUP_NO_ANT is set;
    353          - G_u32ApplicationFlags  _APPLICATION_FLAGS_ANT bit remains clear
    354          - Ant_pfnStateMachine = AntSM_NoResponse
    355          
    356          */

   \                                 In section .text, align 2, keep-with-next
    357          void AntInitialize(void)
    358          {
   \                     AntInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    359            /* Check for manual disabling of ANT */
    360            if( ANT_BOOT_DISABLE() )
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable12_1  ;; 0x400e0e3c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD425             BMI.N    ??AntInitialize_0
    361            {
    362              G_u32SystemFlags |= _SYSTEM_STARTUP_NO_ANT;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable12_2
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable12_2
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    363              DebugPrintf(G_au8AntMessageNoAnt);
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable12_3
   \   00000020   0x.... 0x....      BL       DebugPrintf
    364          
    365              /* Float all of the ANT interface lines so that the J-Link programmer 
    366              or other firmware will not be impacted by the Host MCU */
    367              AT91C_BASE_PIOA->PIO_PER = ANT_PIOA_PINS;
   \   00000024   0xF05F 0x7030      MOVS     R0,#+46137344
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable12_4  ;; 0x400e0c00
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    368              AT91C_BASE_PIOB->PIO_PER = ANT_PIOB_PINS;
   \   0000002E   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   00000032   0x.... 0x....      LDR.W    R1,??DataTable12_5  ;; 0x400e0e00
   \   00000036   0x6008             STR      R0,[R1, #+0]
    369          
    370              /* Disable all outputs (set to HiZ input) */
    371              AT91C_BASE_PIOA->PIO_ODR = ANT_PIOA_PINS;
   \   00000038   0xF05F 0x7030      MOVS     R0,#+46137344
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable12_6  ;; 0x400e0c14
   \   00000040   0x6008             STR      R0,[R1, #+0]
    372              AT91C_BASE_PIOB->PIO_ODR = ANT_PIOB_PINS;
   \   00000042   0xF05F 0x70F0      MOVS     R0,#+31457280
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable12_7  ;; 0x400e0e14
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    373              
    374              Ant_pfnStateMachine = AntSM_NoResponse;
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable16
   \   00000054   0x6008             STR      R0,[R1, #+0]
   \   00000056   0xE0EB             B.N      ??AntInitialize_1
    375            }
    376            /* Otherwise try to start up ANT normally */
    377            else
    378            {
    379              /* Give PIO control of ANT_RESET line */
    380              AT91C_BASE_PIOB->PIO_OER = PB_21_ANT_RESET;
   \                     ??AntInitialize_0: (+1)
   \   00000058   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable12_8  ;; 0x400e0e10
   \   00000060   0x6008             STR      R0,[R1, #+0]
    381              
    382              /* Announce on the debug port that ANT setup is starting and intialize pointers */
    383              DebugPrintf(G_au8AntMessageInit);
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable13_2
   \   00000066   0x.... 0x....      BL       DebugPrintf
    384              G_psAntApplicationMsgList = 0;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable12
   \   00000070   0x6008             STR      R0,[R1, #+0]
    385              Ant_psOutgoingMsgList = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000078   0x6008             STR      R0,[R1, #+0]
    386            
    387              /* Initialize the G_asAntChannelConfiguration data struct */
    388              for(u8 i = 0; i < ANT_NUM_CHANNELS; i++)
   \   0000007A   0x2000             MOVS     R0,#+0
   \                     ??AntInitialize_2: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2808             CMP      R0,#+8
   \   00000080   0xDA70             BGE.N    ??AntInitialize_3
    389              {
    390                G_asAntChannelConfiguration[i].AntChannel          = (AntChannelNumberType)i;
   \   00000082   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0x2214             MOVS     R2,#+20
   \   0000008A   0xFB02 0x1100      MLA      R1,R2,R0,R1
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    391                G_asAntChannelConfiguration[i].AntChannelType      = ANT_CHANNEL_TYPE_DEFAULT;
   \   00000090   0x2110             MOVS     R1,#+16
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2314             MOVS     R3,#+20
   \   0000009A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000009E   0x7051             STRB     R1,[R2, #+1]
    392                G_asAntChannelConfiguration[i].AntNetwork          = ANT_NETWORK_DEFAULT;
   \   000000A0   0x2100             MOVS     R1,#+0
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000A6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000A8   0x2314             MOVS     R3,#+20
   \   000000AA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000AE   0x7091             STRB     R1,[R2, #+2]
    393                G_asAntChannelConfiguration[i].AntDeviceIdLo       = ANT_DEVICE_ID_LO_DEFAULT;
   \   000000B0   0x2100             MOVS     R1,#+0
   \   000000B2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000B6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000B8   0x2314             MOVS     R3,#+20
   \   000000BA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000BE   0x72D1             STRB     R1,[R2, #+11]
    394                G_asAntChannelConfiguration[i].AntDeviceIdHi       = ANT_DEVICE_ID_HI_DEFAULT;
   \   000000C0   0x2120             MOVS     R1,#+32
   \   000000C2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000C6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000C8   0x2314             MOVS     R3,#+20
   \   000000CA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000CE   0x7311             STRB     R1,[R2, #+12]
    395                G_asAntChannelConfiguration[i].AntDeviceType       = ANT_DEVICE_TYPE_DEFAULT;
   \   000000D0   0x2101             MOVS     R1,#+1
   \   000000D2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000D6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000D8   0x2314             MOVS     R3,#+20
   \   000000DA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000DE   0x7351             STRB     R1,[R2, #+13]
    396                G_asAntChannelConfiguration[i].AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
   \   000000E0   0x2101             MOVS     R1,#+1
   \   000000E2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000E6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000E8   0x2314             MOVS     R3,#+20
   \   000000EA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000EE   0x7391             STRB     R1,[R2, #+14]
    397                G_asAntChannelConfiguration[i].AntChannelPeriodLo  = ANT_CHANNEL_PERIOD_LO_DEFAULT;
   \   000000F0   0x2100             MOVS     R1,#+0
   \   000000F2   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   000000F6   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000F8   0x2314             MOVS     R3,#+20
   \   000000FA   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000FE   0x73D1             STRB     R1,[R2, #+15]
    398                G_asAntChannelConfiguration[i].AntChannelPeriodHi  = ANT_CHANNEL_PERIOD_HI_DEFAULT;
   \   00000100   0x2120             MOVS     R1,#+32
   \   00000102   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000106   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000108   0x2314             MOVS     R3,#+20
   \   0000010A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000010E   0x7411             STRB     R1,[R2, #+16]
    399                G_asAntChannelConfiguration[i].AntFrequency        = ANT_FREQUENCY_DEFAULT;
   \   00000110   0x2137             MOVS     R1,#+55
   \   00000112   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000116   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000118   0x2314             MOVS     R3,#+20
   \   0000011A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000011E   0x7451             STRB     R1,[R2, #+17]
    400                G_asAntChannelConfiguration[i].AntTxPower          = ANT_TX_POWER_DEFAULT;
   \   00000120   0x2104             MOVS     R1,#+4
   \   00000122   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000126   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000128   0x2314             MOVS     R3,#+20
   \   0000012A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000012E   0x7491             STRB     R1,[R2, #+18]
    401                G_asAntChannelConfiguration[i].AntFlags            = 0;
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   00000136   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000138   0x2314             MOVS     R3,#+20
   \   0000013A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000013E   0x74D1             STRB     R1,[R2, #+19]
    402                
    403                for(u8 j = 0; j < ANT_NETWORK_NUMBER_BYTES; j++)
   \   00000140   0x2100             MOVS     R1,#+0
   \                     ??AntInitialize_4: (+1)
   \   00000142   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000144   0x2908             CMP      R1,#+8
   \   00000146   0xDA0B             BGE.N    ??AntInitialize_5
    404                {
    405                  G_asAntChannelConfiguration[i].AntNetworkKey[j] = 0;
   \   00000148   0x.... 0x....      LDR.W    R2,??DataTable16_1
   \   0000014C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014E   0x2314             MOVS     R3,#+20
   \   00000150   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000154   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000156   0x188A             ADDS     R2,R1,R2
   \   00000158   0x2300             MOVS     R3,#+0
   \   0000015A   0x70D3             STRB     R3,[R2, #+3]
    406                }
   \   0000015C   0x1C49             ADDS     R1,R1,#+1
   \   0000015E   0xE7F0             B.N      ??AntInitialize_4
    407              } 
   \                     ??AntInitialize_5: (+1)
   \   00000160   0x1C40             ADDS     R0,R0,#+1
   \   00000162   0xE78B             B.N      ??AntInitialize_2
    408              
    409              /* Configure the SSP resource to be used for the application */
    410              Ant_sSspConfig.SspPeripheral      = ANT_SPI;
   \                     ??AntInitialize_3: (+1)
   \   00000164   0x2004             MOVS     R0,#+4
   \   00000166   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000016A   0x7008             STRB     R0,[R1, #+0]
    411              Ant_sSspConfig.pCsGpioAddress     = ANT_SPI_CS_GPIO;
   \   0000016C   0x.... 0x....      LDR.W    R0,??DataTable12_5  ;; 0x400e0e00
   \   00000170   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000174   0x6048             STR      R0,[R1, #+4]
    412              Ant_sSspConfig.u32CsPin           = ANT_SPI_CS_PIN;
   \   00000176   0xF45F 0x0080      MOVS     R0,#+4194304
   \   0000017A   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000017E   0x6088             STR      R0,[R1, #+8]
    413              Ant_sSspConfig.eBitOrder          = SSP_LSB_FIRST;
   \   00000180   0x2001             MOVS     R0,#+1
   \   00000182   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000186   0x7308             STRB     R0,[R1, #+12]
    414              Ant_sSspConfig.eSspMode           = SSP_SLAVE_FLOW_CONTROL;
   \   00000188   0x2003             MOVS     R0,#+3
   \   0000018A   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000018E   0x7348             STRB     R0,[R1, #+13]
    415              Ant_sSspConfig.fnSlaveTxFlowCallback = AntTxFlowControlCallback;
   \   00000190   0x.... 0x....      ADR.W    R0,AntTxFlowControlCallback
   \   00000194   0x.... 0x....      LDR.W    R1,??DataTable14
   \   00000198   0x6108             STR      R0,[R1, #+16]
    416              Ant_sSspConfig.fnSlaveRxFlowCallback = AntRxFlowControlCallback;
   \   0000019A   0x.... 0x....      ADR.W    R0,AntRxFlowControlCallback
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000001A2   0x6148             STR      R0,[R1, #+20]
    417              Ant_sSspConfig.pu8RxBufferAddress = Ant_au8AntRxBuffer;
   \   000001A4   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000001AC   0x6188             STR      R0,[R1, #+24]
    418              Ant_sSspConfig.ppu8RxNextByte     = &Ant_pu8AntRxBufferNextChar;
   \   000001AE   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000001B6   0x61C8             STR      R0,[R1, #+28]
    419              Ant_sSspConfig.u16RxBufferSize    = ANT_RX_BUFFER_SIZE;
   \   000001B8   0xF44F 0x7080      MOV      R0,#+256
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable14
   \   000001C0   0x8408             STRH     R0,[R1, #+32]
    420          
    421              Ant_Ssp = SspRequest(&Ant_sSspConfig);
   \   000001C2   0x.... 0x....      LDR.W    R0,??DataTable14
   \   000001C6   0x.... 0x....      BL       SspRequest
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable16_4
   \   000001CE   0x6008             STR      R0,[R1, #+0]
    422              ANT_SSP_FLAGS = 0;
   \   000001D0   0x2000             MOVS     R0,#+0
   \   000001D2   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000001D6   0x6008             STR      R0,[R1, #+0]
    423              
    424              /* Reset ANT, activate SPI interface and get a test message */
    425              AntSyncSerialInitialize();
   \   000001D8   0x.... 0x....      BL       AntSyncSerialInitialize
    426              
    427              /* Report status out the debug port */
    428              if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)  
   \   000001DC   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000001E0   0x6800             LDR      R0,[R0, #+0]
   \   000001E2   0x0640             LSLS     R0,R0,#+25
   \   000001E4   0xD51B             BPL.N    ??AntInitialize_6
    429              {
    430                DebugPrintf(G_au8AntMessageOk);
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001EA   0x.... 0x....      BL       DebugPrintf
    431                DebugPrintf("ANT version: ");
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   000001F2   0x.... 0x....      BL       DebugPrintf
    432                DebugPrintf(Ant_u8AntVersion);
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   000001FA   0x.... 0x....      BL       DebugPrintf
    433                DebugLineFeed();
   \   000001FE   0x.... 0x....      BL       DebugLineFeed
    434                
    435                G_u32AntFlags &= ~_ANT_FLAGS_RESTART;
   \   00000202   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000206   0x6800             LDR      R0,[R0, #+0]
   \   00000208   0xF430 0x3080      BICS     R0,R0,#0x10000
   \   0000020C   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000210   0x6008             STR      R0,[R1, #+0]
    436                Ant_pfnStateMachine = AntSM_Idle;
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   00000216   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000021A   0x6008             STR      R0,[R1, #+0]
   \   0000021C   0xE008             B.N      ??AntInitialize_1
    437              }
    438              else
    439              {
    440                /* The ANT device is not responding -- it may be dead, or it may not yet
    441                be loaded with any firmware */
    442                DebugPrintf(G_au8AntMessageInitFail);
   \                     ??AntInitialize_6: (+1)
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable16_7
   \   00000222   0x.... 0x....      BL       DebugPrintf
    443          
    444                Ant_pfnStateMachine = AntSM_NoResponse;
   \   00000226   0x.... 0x....      LDR.W    R0,??DataTable13_1
   \   0000022A   0x.... 0x....      LDR.W    R1,??DataTable16
   \   0000022E   0x6008             STR      R0,[R1, #+0]
    445              }
    446            }
    447            
    448          } /* end AntInitialize() */
   \                     ??AntInitialize_1: (+1)
   \   00000230   0xBD01             POP      {R0,PC}          ;; return
    449          
    450          
    451          /*!----------------------------------------------------------------------------------------------------------------------
    452          @fn void AntRunActiveState(void)
    453          
    454          @brief Selects and runs one iteration of the current state in the state machine.
    455          
    456          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    457          may take 1ms / n to execute.
    458          
    459          Requires:
    460          - State machine function pointer points at current state
    461          
    462          Promises:
    463          - Calls the function to pointed by the state machine function pointer
    464          
    465          */

   \                                 In section .text, align 2, keep-with-next
    466          void AntRunActiveState(void)
    467          {
   \                     AntRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    468            Ant_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    469          
    470          } /* end AntRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    471          
    472          
    473          /*!-----------------------------------------------------------------------------
    474          @fn void AntTxFlowControlCallback(void)
    475          
    476          @brief Callback function to toggle flow control during transmission.  
    477          
    478          The peripheral task sending the message must invoke this function after each byte.  
    479          
    480          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    481          
    482          Requires:
    483          - NONE 
    484          
    485          Promises:
    486          - SRDY is toggled
    487          - Ant_u32TxByteCounter incremented
    488          
    489          */

   \                                 In section .text, align 4, keep-with-next
    490          void AntTxFlowControlCallback(void)
    491          {
   \                     AntTxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    492            /* Count the byte and toggle flow control lines */
    493            Ant_u32TxByteCounter++; 
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_2
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable18_2
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    494            AntSrdyPulse();
   \   00000010   0x.... 0x....      BL       AntSrdyPulse
    495          
    496          } /* end AntTxFlowControlCallback() */
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    497          
    498          
    499          /*!-----------------------------------------------------------------------------
    500          @fn void AntRxFlowControlCallback(void)
    501          
    502          @brief Callback function used during ANT data reception.  
    503          
    504          The peripheral task receiving the message must invoke this function after each byte.  
    505          
    506          Note: Since this function is called from an ISR, it should execute as quickly as possible. 
    507          Unfortunately, AntSrdyPulse() takes some time but the duty cycle of this interrupt
    508          is low enough that we can survive (this interrupt priority could be dropped below everything
    509          else to mitigate any issues).
    510          
    511          Requires:
    512          - G_u32AntFlags _ANT_FLAGS_RX_IN_PROGRESS is correctly set
    513          - A received byte was just written to the Rx buffer
    514          - _SSP_CS_ASSERTED already in correct state: should be set on first byte, but application should 
    515            clear it for all subsequent bytes so flow control is handled entirely by this function
    516          - ISRs are off already since this is totally not re-entrant
    517          
    518          Promises:
    519          - Ant_pu8AntRxBufferNextChar is advanced safely so it is ready to receive the next byte
    520          - Ant_u32RxByteCounter incremented
    521          - SRDY is toggled if _ANT_FLAGS_RX_IN_PROGRESS is set
    522          
    523          */

   \                                 In section .text, align 4, keep-with-next
    524          void AntRxFlowControlCallback(void)
    525          {
   \                     AntRxFlowControlCallback: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    526            /* Count the byte and safely advance the receive buffer pointer; this is called from the
    527            RX ISR, so it won't be interrupted and break Ant_pu8AntRxBufferNextChar */
    528            Ant_u32RxByteCounter++;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    529            Ant_pu8AntRxBufferNextChar++;
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    530            if(Ant_pu8AntRxBufferNextChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000028   0x4288             CMP      R0,R1
   \   0000002A   0xD104             BNE.N    ??AntRxFlowControlCallback_0
    531            {
    532              Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000034   0x6008             STR      R0,[R1, #+0]
    533            }
    534            
    535            /* Only toggle SRDY if a reception is flagged in progress */
    536            if( G_u32AntFlags & _ANT_FLAGS_RX_IN_PROGRESS )
   \                     ??AntRxFlowControlCallback_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x01C0             LSLS     R0,R0,#+7
   \   0000003E   0xD501             BPL.N    ??AntRxFlowControlCallback_1
    537            {
    538              AntSrdyPulse();
   \   00000040   0x.... 0x....      BL       AntSrdyPulse
    539            }
    540            
    541          } /* end AntRxFlowControlCallback() */
   \                     ??AntRxFlowControlCallback_1: (+1)
   \   00000044   0xBD01             POP      {R0,PC}          ;; return
    542          
    543          
    544          /*--------------------------------------------------------------------------------------------------------------------*/
    545          /*! @privatesection */                                                                                            
    546          /*--------------------------------------------------------------------------------------------------------------------*/
    547          /* ANT private Interface-layer Functions */
    548          
    549                                             
    550          /*!-----------------------------------------------------------------------------
    551          @fn bool AntTxMessage(u8 *pu8AntTxMessage_)
    552          
    553          @brief Send a message from the Host to the ANT device.  
    554          
    555          To do this, we must tell ANT that we have a message to send by asserting MRDY, 
    556          wait for ANT to acknowledge with SEN, then read a byte from ANT to confirm the 
    557          transmission can proceed.  If ANT wants to send a message at the
    558          same time, the byte it sends will be an Rx byte so the AntTxMessage must suspend 
    559          and go read the incoming message first.  The Tx process would restart after 
    560          ANT's message has been received by the host.
    561          
    562          Once ANT confirms that the Host may transmit, the message to transmit is queued 
    563          and data is sent byte-by-byte with SRDY used for flow control after each byte.  
    564          Due to the speed of the chip-to-chip communications, even the longest ANT message
    565          should be able to send in less than 500us so it will likely be done on the main 
    566          program cycle that immediately follows this call.  
    567          
    568          Requires:
    569          @param pu8AntTxMessage_ points to an Ant formatted message where the first data byte
    570                 is the length byte (since ANT sends the SYNC byte) and the last byte is
    571                 the checksum.
    572          
    573          Promises:
    574          - MRDY is de-asserted
    575          - Returns TRUE if the transmit message is queued successfully; Ant_u32CurrentTxMessageToken holds the message token
    576          - Returns FALSE if the transfer couldn't start or if receive message interrupted
    577            (G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set;  AntRxBufferCurrentChar pointing to the received byte).
    578          
    579          */

   \                                 In section .text, align 2, keep-with-next
    580          static bool AntTxMessage(u8 *pu8AntTxMessage_)
    581          {
   \                     AntTxMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB09A             SUB      SP,SP,#+104
   \   00000004   0x0004             MOVS     R4,R0
    582            u8 u8Byte;
    583            u32 u32Length;
    584            u8 au8TxInProgressMsg[] = "AntTx: msg already in progress\n\r";
   \   00000006   0xA810             ADD      R0,SP,#+64
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable16_10
   \   0000000C   0x2221             MOVS     R2,#+33
   \   0000000E   0x.... 0x....      BL       __aeabi_memcpy
    585            u8 au8TxTimeoutMsg[]    = "AntTx: SEN timeout\n\r";
   \   00000012   0xA80A             ADD      R0,SP,#+40
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \   00000018   0x2215             MOVS     R2,#+21
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy
    586            u8 au8TxNoTokenMsg[]    = "AntTx: No token\n\r";
   \   0000001E   0xA805             ADD      R0,SP,#+20
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable16_12
   \   00000024   0x2212             MOVS     R2,#+18
   \   00000026   0x.... 0x....      BL       __aeabi_memcpy
    587            u8 au8TxNoSyncMsg[]     = "AntTx: No SYNC\n\r";
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   00000030   0x2211             MOVS     R2,#+17
   \   00000032   0x.... 0x....      BL       __aeabi_memcpy
    588          
    589            /* Check G_u32AntFlags first to ensure a transmission is not already taking place */
    590            if(G_u32AntFlags & (_ANT_FLAGS_TX_IN_PROGRESS | _ANT_FLAGS_RX_IN_PROGRESS) )
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0xF010 0x7F40      TST      R0,#0x3000000
   \   00000040   0xD004             BEQ.N    ??AntTxMessage_0
    591            {
    592              DebugPrintf(au8TxInProgressMsg);
   \   00000042   0xA810             ADD      R0,SP,#+64
   \   00000044   0x.... 0x....      BL       DebugPrintf
    593              return FALSE;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xE09A             B.N      ??AntTxMessage_1
    594            }
    595            
    596            /* Initialize the timeout timer and notify ANT that the Host wishes to send a message */
    597            Ant_u32RxTimer = 0;
   \                     ??AntTxMessage_0: (+1)
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   00000052   0x6008             STR      R0,[R1, #+0]
    598            SYNC_MRDY_ASSERT();                          
   \   00000054   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable20  ;; 0x400e0e34
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    599          
    600            /* Wait for SEN to be asserted indicating ANT is ready for a message */
    601            while ( !IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_2: (+1)
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x07C0             LSLS     R0,R0,#+31
   \   00000066   0xD40E             BMI.N    ??AntTxMessage_3
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD207             BCS.N    ??AntTxMessage_3
    602            {
    603              Ant_u32RxTimer++;
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x1C40             ADDS     R0,R0,#+1
   \   0000007E   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   00000082   0x6008             STR      R0,[R1, #+0]
   \   00000084   0xE7EB             B.N      ??AntTxMessage_2
    604            }
    605            
    606            /* If we timed out, then clear MRDY and exit */
    607            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntTxMessage_3: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0xF242 0x7111      MOVW     R1,#+10001
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD309             BCC.N    ??AntTxMessage_4
    608            {
    609              SYNC_MRDY_DEASSERT();                          
   \   00000094   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0x400e0e30
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    610              DebugPrintf(au8TxTimeoutMsg);
   \   0000009E   0xA80A             ADD      R0,SP,#+40
   \   000000A0   0x.... 0x....      BL       DebugPrintf
    611              return(FALSE);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE06C             B.N      ??AntTxMessage_1
    612            }
    613            
    614            /* Else we have SEN flag; queue to read 1 byte after a short delay before toggling SRDY */
    615            AntSrdyPulse();
   \                     ??AntTxMessage_4: (+1)
   \   000000A8   0x.... 0x....      BL       AntSrdyPulse
    616          
    617            /* Wait for the first byte to come in via the ISR / Rx Callback*/
    618            while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntTxMessage_5: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x0740             LSLS     R0,R0,#+29
   \   000000B4   0xD40E             BMI.N    ??AntTxMessage_6
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000000BA   0x6800             LDR      R0,[R0, #+0]
   \   000000BC   0xF242 0x7110      MOVW     R1,#+10000
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xD207             BCS.N    ??AntTxMessage_6
    619            {
    620              Ant_u32RxTimer++;
   \   000000C4   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x1C40             ADDS     R0,R0,#+1
   \   000000CC   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   000000D0   0x6008             STR      R0,[R1, #+0]
   \   000000D2   0xE7EB             B.N      ??AntTxMessage_5
    621            }
    622          
    623            /* Ok to deassert MRDY now */
    624            SYNC_MRDY_DEASSERT();                     
   \                     ??AntTxMessage_6: (+1)
   \   000000D4   0xF45F 0x0000      MOVS     R0,#+8388608
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable20_1  ;; 0x400e0e30
   \   000000DC   0x6008             STR      R0,[R1, #+0]
    625          
    626            /* If we timed out now, then clear MRDY and exit.  Because CS is still asserted, the task
    627            will attempt to read a message but fail and eventually abort. */
    628            if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \   000000DE   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000000E2   0x6800             LDR      R0,[R0, #+0]
   \   000000E4   0xF242 0x7111      MOVW     R1,#+10001
   \   000000E8   0x4288             CMP      R0,R1
   \   000000EA   0xD304             BCC.N    ??AntTxMessage_7
    629            {
    630             DebugPrintf(au8TxTimeoutMsg);
   \   000000EC   0xA80A             ADD      R0,SP,#+40
   \   000000EE   0x.... 0x....      BL       DebugPrintf
    631             return(FALSE);
   \   000000F2   0x2000             MOVS     R0,#+0
   \   000000F4   0xE045             B.N      ??AntTxMessage_1
    632            }
    633                    
    634            /* When the byte comes in, the SSP module will set the _SSP_RX_COMPLETE flag and also call the 
    635            Rx callback but does not toggle SRDY at this time.  We must look at this byte to determine if ANT 
    636            initiated this particular communication and is telling us that a message is coming in, or if we 
    637            initiated the communication and ANT is allowing us to transmit. */
    638          
    639            /* Read the byte - don't advance the pointer yet */
    640            u8Byte = *Ant_pu8AntRxBufferCurrentChar;                       
   \                     ??AntTxMessage_7: (+1)
   \   000000F6   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x7800             LDRB     R0,[R0, #+0]
   \   000000FE   0x0005             MOVS     R5,R0
    641          
    642            /* If the byte is TX_SYNC, then ANT wants to send a message which must be done first */
    643            if (u8Byte == MESG_TX_SYNC)                     
   \   00000100   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000102   0x2DA4             CMP      R5,#+164
   \   00000104   0xD109             BNE.N    ??AntTxMessage_8
    644            {
    645              G_u32AntFlags |= _ANT_FLAGS_TX_INTERRUPTED;
   \   00000106   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000114   0x6008             STR      R0,[R1, #+0]
    646              return(FALSE);
   \   00000116   0x2000             MOVS     R0,#+0
   \   00000118   0xE033             B.N      ??AntTxMessage_1
    647            }
    648          
    649            /* Since the Rx byte is in our Rx buffer, advance both pointers since it's not an incoming message */
    650            AdvanceAntRxBufferCurrentChar();
   \                     ??AntTxMessage_8: (+1)
   \   0000011A   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    651            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000011E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
    652          
    653            /* Clear the status flag and process the byte */
    654            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \   00000122   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000126   0x6800             LDR      R0,[R0, #+0]
   \   00000128   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000012C   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000130   0x6008             STR      R0,[R1, #+0]
    655            
    656            /* If the byte is RX_SYNC, then proceed to send the message */
    657            if (u8Byte == MESG_RX_SYNC)                     
   \   00000132   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000134   0x2DA5             CMP      R5,#+165
   \   00000136   0xD120             BNE.N    ??AntTxMessage_9
    658            {
    659              /* Flag that a transmit is in progress */
    660              G_u32AntFlags |= _ANT_FLAGS_TX_IN_PROGRESS;
   \   00000138   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000013C   0x6800             LDR      R0,[R0, #+0]
   \   0000013E   0xF050 0x7000      ORRS     R0,R0,#0x2000000
   \   00000142   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000146   0x6008             STR      R0,[R1, #+0]
    661              
    662              /* Read the message length and add three for the length, message ID and checksum */
    663              u32Length = (u32)(pu8AntTxMessage_[0] + 3); 
   \   00000148   0x7820             LDRB     R0,[R4, #+0]
   \   0000014A   0x1CC0             ADDS     R0,R0,#+3
   \   0000014C   0x0006             MOVS     R6,R0
    664              
    665              /* Queue the message to the peripheral and capture the token */ 
    666              Ant_u32CurrentTxMessageToken = SspWriteData(Ant_Ssp, u32Length, pu8AntTxMessage_);
   \   0000014E   0x0022             MOVS     R2,R4
   \   00000150   0x0031             MOVS     R1,R6
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable16_4
   \   00000156   0x6800             LDR      R0,[R0, #+0]
   \   00000158   0x.... 0x....      BL       SspWriteData
   \   0000015C   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   00000160   0x6008             STR      R0,[R1, #+0]
    667          
    668              /* Return TRUE only if we received a message token indicating the message has been queued */
    669              if(Ant_u32CurrentTxMessageToken != 0)
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x2800             CMP      R0,#+0
   \   0000016A   0xD001             BEQ.N    ??AntTxMessage_10
    670              {
    671                return(TRUE);
   \   0000016C   0x2001             MOVS     R0,#+1
   \   0000016E   0xE008             B.N      ??AntTxMessage_1
    672              }
    673              else
    674              {
    675                DebugPrintf(au8TxNoTokenMsg);
   \                     ??AntTxMessage_10: (+1)
   \   00000170   0xA805             ADD      R0,SP,#+20
   \   00000172   0x.... 0x....      BL       DebugPrintf
    676                return(FALSE);
   \   00000176   0x2000             MOVS     R0,#+0
   \   00000178   0xE003             B.N      ??AntTxMessage_1
    677              }
    678            }
    679          
    680            /* If we get here, not a sync byte, so return */
    681            DebugPrintf(au8TxNoSyncMsg);
   \                     ??AntTxMessage_9: (+1)
   \   0000017A   0xA800             ADD      R0,SP,#+0
   \   0000017C   0x.... 0x....      BL       DebugPrintf
    682            return(FALSE);
   \   00000180   0x2000             MOVS     R0,#+0
   \                     ??AntTxMessage_1: (+1)
   \   00000182   0xB01A             ADD      SP,SP,#+104
   \   00000184   0xBD70             POP      {R4-R6,PC}       ;; return
    683          
    684          } /* end AntTxMessage() */
    685          
    686          
    687          /*!-----------------------------------------------------------------------------
    688          @fn static void AntRxMessage(void)
    689          
    690          @brief Completely receive a message from ANT to the Host.  
    691          
    692          Incoming bytes are deposited directly into the receive buffer from the SSP ISR 
    693          which should be extremely fast and complete in a maximum of 500us.  
    694          
    695          Requires:
    696          - _SSP_CS_ASSERTED is set indicating a message is ready to come in 
    697          - ANT SSP receive interrupt is active
    698          - G_u32AntFlags _ANT_FLAGS_TX_INTERRUPTED is set if the system wanted to transmit
    699            but ANT wanted to send a message at the same time (so MESG_TX_SYNC has already 
    700            been received); _SSP_RX_COMPLETE must still be set from this.
    701          - Ant_pu8AntRxBufferCurrentChar points to the first byte of the message
    702          
    703          Promises:
    704          - If a good new message has been received, then Ant_u8AntNewMessages is incremented
    705            and the message is at Ant_pu8AntRxBufferUnreadMsg in Ant_au8AntRxBuffer
    706          - If a good message is not received, then Ant_u8AntNewMessages is unchanged.
    707          - In both cases, Ant_pu8AntRxBufferNextChar points at the next empty buffer location
    708          
    709          */

   \                                 In section .text, align 2, keep-with-next
    710          static void AntRxMessage(void)
    711          {
   \                     AntRxMessage: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    712            u8 u8Checksum;
    713            u8 u8Length;
    714            u32 u32CurrentRxByteCount;
    715            u8 au8RxTimeoutMsg[] = "AntRx: timeout\n\r";
   \   00000004   0xA806             ADD      R0,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable20_2
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    716            u8 au8RxFailMsg[]    = "AntRx: message failed\n\r";
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   00000016   0x2218             MOVS     R2,#+24
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    717            bool bReceptionError = FALSE;
   \   0000001C   0x2700             MOVS     R7,#+0
    718            
    719            /* Ensure we have SEN */
    720            if( !( IS_SEN_ASSERTED() ) )
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x07C0             LSLS     R0,R0,#+31
   \   00000026   0xF140 0x810B      BPL.W    ??AntRxMessage_0
    721            {
    722              return;
    723            }
    724           
    725            /* Initialize the receive timer and get a snapshot of current byte count */
    726            u32CurrentRxByteCount = Ant_u32RxByteCounter;
   \                     ??AntRxMessage_1: (+1)
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0006             MOVS     R6,R0
    727            Ant_u32RxTimer = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   00000038   0x6008             STR      R0,[R1, #+0]
    728            
    729            /* If the Global _ANT_FLAGS_TX_INTERRUPTED flag has been set, then we have already read the TX_SYNC byte */
    730            if(G_u32AntFlags & _ANT_FLAGS_TX_INTERRUPTED)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x0140             LSLS     R0,R0,#+5
   \   00000042   0xD509             BPL.N    ??AntRxMessage_2
    731            {
    732              /* Clear flag and adjust the starting byte counter since the message came in during AntTxMessage*/
    733              G_u32AntFlags &= ~_ANT_FLAGS_TX_INTERRUPTED;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF030 0x6080      BICS     R0,R0,#0x4000000
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000052   0x6008             STR      R0,[R1, #+0]
    734              u32CurrentRxByteCount--;
   \   00000054   0x1E76             SUBS     R6,R6,#+1
   \   00000056   0xE015             B.N      ??AntRxMessage_3
    735              
    736            }
    737            /* Otherwise we need to first read the sync byte  */
    738            else
    739            {
    740              /* Cycle SRDY to get the first byte */
    741              AntSrdyPulse();
   \                     ??AntRxMessage_2: (+1)
   \   00000058   0x.... 0x....      BL       AntSrdyPulse
    742          
    743              /* Begin the receive cycle that takes place using interrupts and callbacks and is monitored by a timeout of 
    744              about 500us - this should be plenty of time to receive even the longest ANT message but still only half the 
    745              allowed 1ms loop time for the system. */
    746              
    747              /* Read the first byte when it comes in */
    748              while( !(ANT_SSP_FLAGS & _SSP_RX_COMPLETE) &&
    749                     (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x0740             LSLS     R0,R0,#+29
   \   00000064   0xD40E             BMI.N    ??AntRxMessage_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0xF242 0x7110      MOVW     R1,#+10000
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD207             BCS.N    ??AntRxMessage_3
    750              {
    751                Ant_u32RxTimer++;
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   00000080   0x6008             STR      R0,[R1, #+0]
   \   00000082   0xE7EB             B.N      ??AntRxMessage_4
    752              }
    753            }
    754            
    755            if( Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT) 
   \                     ??AntRxMessage_3: (+1)
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   00000088   0x6800             LDR      R0,[R0, #+0]
   \   0000008A   0xF242 0x7111      MOVW     R1,#+10001
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD305             BCC.N    ??AntRxMessage_5
    756            {
    757              AntAbortMessage();
   \   00000092   0x.... 0x....      BL       AntAbortMessage
    758              DebugPrintf(au8RxTimeoutMsg);
   \   00000096   0xA806             ADD      R0,SP,#+24
   \   00000098   0x.... 0x....      BL       DebugPrintf
    759              return;
   \   0000009C   0xE0D0             B.N      ??AntRxMessage_0
    760            }
    761          
    762            /* _SSP_RX_COMPLETE flag will be set and the Rx callback will have run.  
    763            The callback does NOT toggle SRDY yet.  _SSP_RX_COMPLETE should still
    764            be set from AntTxMessage if that's what got us here. */
    765            ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \                     ??AntRxMessage_5: (+1)
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF030 0x0004      BICS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable18
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    766             
    767            /* One way or the other, we now have a potential SYNC byte at Ant_pu8AntRxBufferCurrentChar.  
    768            Proceed to test it and receive the rest of the message */
    769            if (*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC)                     
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x7800             LDRB     R0,[R0, #+0]
   \   000000B6   0x28A4             CMP      R0,#+164
   \   000000B8   0xF040 0x8086      BNE.W    ??AntRxMessage_6
    770            {
    771              /* Flag that a reception is in progress */
    772              G_u32AntFlags |= _ANT_FLAGS_RX_IN_PROGRESS;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   000000C0   0x6800             LDR      R0,[R0, #+0]
   \   000000C2   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   000000CA   0x6008             STR      R0,[R1, #+0]
    773              
    774              /* Cycle SRDY to get the next byte (length) */
    775              AntSrdyPulse();
   \   000000CC   0x.... 0x....      BL       AntSrdyPulse
    776              
    777              /* We block here while the SSP interrupts and Rx callback handle the rest of the reception until a full 
    778              message is received. We know it is received when SEN is deasserted. This takes about 500us */
    779              while( IS_SEN_ASSERTED() && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_7: (+1)
   \   000000D0   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x07C0             LSLS     R0,R0,#+31
   \   000000D8   0xD50E             BPL.N    ??AntRxMessage_8
   \   000000DA   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000E4   0x4288             CMP      R0,R1
   \   000000E6   0xD207             BCS.N    ??AntRxMessage_8
    780              {
    781                Ant_u32RxTimer++;
   \   000000E8   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000000EC   0x6800             LDR      R0,[R0, #+0]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   000000F4   0x6008             STR      R0,[R1, #+0]
   \   000000F6   0xE7EB             B.N      ??AntRxMessage_7
    782              }
    783            
    784              /* One way or another, this Rx is done! */
    785              G_u32AntFlags &= ~_ANT_FLAGS_RX_IN_PROGRESS;
   \                     ??AntRxMessage_8: (+1)
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   00000106   0x6008             STR      R0,[R1, #+0]
    786              ANT_SSP_FLAGS &= ~_SSP_RX_COMPLETE;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000116   0x6008             STR      R0,[R1, #+0]
    787          
    788              /* Check that the above loop ended as expected and didn't time out */
    789              if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT)
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000122   0x4288             CMP      R0,R1
   \   00000124   0xD246             BCS.N    ??AntRxMessage_9
    790              {  
    791                /* Update counter to see how many bytes we should have */
    792                u32CurrentRxByteCount = Ant_u32RxByteCounter - u32CurrentRxByteCount;
   \   00000126   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1B86             SUBS     R6,R0,R6
    793              
    794                /* RxBufferCurrentChar is still pointing to the SYNC byte. Validate what should be a complete message now. */
    795                u8Checksum = *Ant_pu8AntRxBufferCurrentChar;
   \   0000012E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x7800             LDRB     R0,[R0, #+0]
   \   00000136   0x0004             MOVS     R4,R0
    796                AdvanceAntRxBufferCurrentChar();
   \   00000138   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    797                
    798                /* Read the length byte and add two to count the length byte and message ID but not checksum as length will be our checksum counter */
    799                u8Length = *Ant_pu8AntRxBufferCurrentChar + 2;  
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000140   0x6800             LDR      R0,[R0, #+0]
   \   00000142   0x7800             LDRB     R0,[R0, #+0]
   \   00000144   0x1C80             ADDS     R0,R0,#+2
   \   00000146   0x0005             MOVS     R5,R0
    800                
    801                /* Optional check (u8Length does not include the SYNC byte or Checksum byte so add 2) */
    802                if(u32CurrentRxByteCount != (u8Length + 2) )
   \   00000148   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000014A   0x1CA8             ADDS     R0,R5,#+2
   \   0000014C   0x4286             CMP      R6,R0
   \   0000014E   0xD007             BEQ.N    ??AntRxMessage_10
    803                {
    804                  /* Could throw out the message right away - this could save some potential weird memory accesses
    805                  if there was any corruption or a wild u8Length value */
    806                  G_u32AntFlags |= _ANT_FLAGS_LENGTH_MISMATCH;
   \   00000150   0x.... 0x....      LDR.W    R0,??DataTable17_2
   \   00000154   0x6800             LDR      R0,[R0, #+0]
   \   00000156   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000015A   0x.... 0x....      LDR.W    R1,??DataTable17_2
   \   0000015E   0x6008             STR      R0,[R1, #+0]
    807                }
    808           
    809                /* Validate the remaining bytes based on u8Length*/
    810                do
    811                {
    812                  u8Checksum ^= *Ant_pu8AntRxBufferCurrentChar;                     
   \                     ??AntRxMessage_10: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000164   0x6800             LDR      R0,[R0, #+0]
   \   00000166   0x7800             LDRB     R0,[R0, #+0]
   \   00000168   0x4044             EORS     R4,R0,R4
    813                  AdvanceAntRxBufferCurrentChar();
   \   0000016A   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    814                } while (--u8Length);
   \   0000016E   0x1E6D             SUBS     R5,R5,#+1
   \   00000170   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000172   0x2D00             CMP      R5,#+0
   \   00000174   0xD1F4             BNE.N    ??AntRxMessage_10
    815                
    816                /* AntRxBufferCurrentChar is pointing to the last received byte that should be the checksum. */
    817                if (u8Checksum == *Ant_pu8AntRxBufferCurrentChar)      
   \   00000176   0x.... 0x....      LDR.W    R0,??DataTable21
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x7800             LDRB     R0,[R0, #+0]
   \   0000017E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000180   0x4284             CMP      R4,R0
   \   00000182   0xD10E             BNE.N    ??AntRxMessage_11
    818                {
    819                  Ant_u8AntNewRxMessages++;
   \   00000184   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000188   0x7800             LDRB     R0,[R0, #+0]
   \   0000018A   0x1C40             ADDS     R0,R0,#+1
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000190   0x7008             STRB     R0,[R1, #+0]
    820                  Ant_DebugTotalRxMessages++;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   00000196   0x6800             LDR      R0,[R0, #+0]
   \   00000198   0x1C40             ADDS     R0,R0,#+1
   \   0000019A   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   0000019E   0x6008             STR      R0,[R1, #+0]
   \   000001A0   0xE01B             B.N      ??AntRxMessage_12
    821                }
    822                /* If the message was not good, then move Ant_pu8AntRxBufferUnreadMsg passed the garbage data */
    823                else
    824                {
    825                  Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferCurrentChar;
   \                     ??AntRxMessage_11: (+1)
   \   000001A2   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000001A6   0x6800             LDR      R0,[R0, #+0]
   \   000001A8   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   000001AC   0x6008             STR      R0,[R1, #+0]
    826                  AdvanceAntRxBufferUnreadMsgPointer();
   \   000001AE   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   \   000001B2   0xE012             B.N      ??AntRxMessage_12
    827                }
    828              } /* end if(Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) */
    829              else
    830              {
    831                /* Advance the timeout tick */
    832                Ant_u32RxTimeoutCounter++;
   \                     ??AntRxMessage_9: (+1)
   \   000001B4   0x.... 0x....      LDR.W    R0,??DataTable21_5
   \   000001B8   0x6800             LDR      R0,[R0, #+0]
   \   000001BA   0x1C40             ADDS     R0,R0,#+1
   \   000001BC   0x.... 0x....      LDR.W    R1,??DataTable21_5
   \   000001C0   0x6008             STR      R0,[R1, #+0]
    833                bReceptionError = TRUE;
   \   000001C2   0x2001             MOVS     R0,#+1
   \   000001C4   0x0007             MOVS     R7,R0
   \   000001C6   0xE008             B.N      ??AntRxMessage_12
    834              }
    835            } /* end if(*Ant_pu8AntRxBufferCurrentChar == MESG_TX_SYNC) */
    836            else
    837            {
    838              /* Otherwise we have received an unexpected byte -- flag it, clear Ssp flags and abandon the byte */
    839              Ant_u32UnexpectedByteCounter++;
   \                     ??AntRxMessage_6: (+1)
   \   000001C8   0x.... 0x....      LDR.W    R0,??DataTable21_6
   \   000001CC   0x6800             LDR      R0,[R0, #+0]
   \   000001CE   0x1C40             ADDS     R0,R0,#+1
   \   000001D0   0x.... 0x....      LDR.W    R1,??DataTable21_6
   \   000001D4   0x6008             STR      R0,[R1, #+0]
    840              bReceptionError = TRUE;
   \   000001D6   0x2001             MOVS     R0,#+1
   \   000001D8   0x0007             MOVS     R7,R0
    841            }
    842          
    843            /* Handle a reception error if it occured */
    844            if(bReceptionError)
   \                     ??AntRxMessage_12: (+1)
   \   000001DA   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   000001DC   0x2F00             CMP      R7,#+0
   \   000001DE   0xD02D             BEQ.N    ??AntRxMessage_13
    845            {
    846              /* Toggle SRDY until CS deasserts and throw out the message */
    847              DebugPrintf(au8RxFailMsg);
   \   000001E0   0xA800             ADD      R0,SP,#+0
   \   000001E2   0x.... 0x....      BL       DebugPrintf
    848              while( IS_SEN_ASSERTED()  && (Ant_u32RxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntRxMessage_14: (+1)
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x07C0             LSLS     R0,R0,#+31
   \   000001EE   0xD510             BPL.N    ??AntRxMessage_15
   \   000001F0   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   000001F4   0x6800             LDR      R0,[R0, #+0]
   \   000001F6   0xF242 0x7110      MOVW     R1,#+10000
   \   000001FA   0x4288             CMP      R0,R1
   \   000001FC   0xD209             BCS.N    ??AntRxMessage_15
    849              {
    850                Ant_u32RxTimer++;
   \   000001FE   0x.... 0x....      LDR.W    R0,??DataTable18_3
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x1C40             ADDS     R0,R0,#+1
   \   00000206   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   0000020A   0x6008             STR      R0,[R1, #+0]
    851                AntSrdyPulse();
   \   0000020C   0x.... 0x....      BL       AntSrdyPulse
   \   00000210   0xE7E9             B.N      ??AntRxMessage_14
    852              }
    853             
    854              /* Since we have flow control, we can safely assume that no other messages
    855              have come in and Ant_pu8AntRxBufferNextChar is pointing to where the next 
    856              valid message WILL come in - so push all the pointers there. */
    857              Ant_pu8AntRxBufferCurrentChar = Ant_pu8AntRxBufferNextChar;
   \                     ??AntRxMessage_15: (+1)
   \   00000212   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000216   0x6800             LDR      R0,[R0, #+0]
   \   00000218   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000021C   0x6008             STR      R0,[R1, #+0]
    858              Ant_pu8AntRxBufferUnreadMsg = Ant_pu8AntRxBufferNextChar;
   \   0000021E   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   00000222   0x6800             LDR      R0,[R0, #+0]
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000228   0x6008             STR      R0,[R1, #+0]
    859              ANT_SSP_FLAGS &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000022A   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000022E   0x6800             LDR      R0,[R0, #+0]
   \   00000230   0xF030 0x0006      BICS     R0,R0,#0x6
   \   00000234   0x.... 0x....      LDR.W    R1,??DataTable18
   \   00000238   0x6008             STR      R0,[R1, #+0]
   \   0000023A   0xE001             B.N      ??AntRxMessage_16
    860          
    861            }
    862            /* No reception error: */
    863            else
    864            {
    865              /* Finish by advancing the current byte pointer */
    866              AdvanceAntRxBufferCurrentChar();
   \                     ??AntRxMessage_13: (+1)
   \   0000023C   0x.... 0x....      BL       AdvanceAntRxBufferCurrentChar
    867            }
    868            
    869          } /* end AntRxMessage() */
   \                     ??AntRxMessage_16: (+1)
   \                     ??AntRxMessage_0: (+1)
   \   00000240   0xB00B             ADD      SP,SP,#+44
   \   00000242   0xBDF0             POP      {R4-R7,PC}       ;; return
    870          
    871          
    872          /*!-----------------------------------------------------------------------------
    873          @fn static void AntAbortMessage(void)
    874          
    875          @brief Kills the current message in progress with ANT and resets all of the pointers.
    876          
    877          Any existing received buffer data is lost.  Interrupts are disabled
    878          during this time to ensure pointers do not get moved by
    879          an outside function.  
    880          
    881          Requires:
    882          - NONE 
    883          
    884          Promises:
    885          - Ant_pu8AntRxBufferNextChar, Ant_pu8AntRxBufferCurrentChar, Ant_pu8AntRxBufferUnreadMsg,
    886            and Ant_u8AntNewRxMessages reset.
    887          
    888          */

   \                                 In section .text, align 2, keep-with-next
    889          static void AntAbortMessage(void)
    890          {
    891            __disable_irq();
   \                     AntAbortMessage: (+1)
   \   00000000   0xB672             CPSID    I
    892            Ant_pu8AntRxBufferNextChar = &Ant_au8AntRxBuffer[0];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    893            Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000014   0x6008             STR      R0,[R1, #+0]
    894            Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   0000001E   0x6008             STR      R0,[R1, #+0]
    895            Ant_u8AntNewRxMessages = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    896            __enable_irq();
   \   00000028   0xB662             CPSIE    I
    897            
    898          } /* end AntAbortMessage() */
   \   0000002A   0x4770             BX       LR               ;; return
    899          
    900          
    901          /*!-----------------------------------------------------------------------------
    902          @fn static void AdvanceAntRxBufferCurrentChar(void)
    903          
    904          @brief Safely advances Ant_pu8AntRxBufferCurrentChar within the circular buffer
    905          
    906          Requires:
    907          - No interrupt functions may use Ant_pu8AntRxBufferCurrentChar 
    908          
    909          Promises:
    910          - Ant_pu8AntRxBufferCurrentChar points to the next char to write in Ant_au8AntRxBuffer
    911          
    912          */

   \                                 In section .text, align 2, keep-with-next
    913          static void AdvanceAntRxBufferCurrentChar(void)
    914          {
    915            Ant_pu8AntRxBufferCurrentChar++;
   \                     AdvanceAntRxBufferCurrentChar: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable21
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    916            if(Ant_pu8AntRxBufferCurrentChar == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable21
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferCurrentChar_0
    917            {
    918              Ant_pu8AntRxBufferCurrentChar = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21
   \   00000024   0x6008             STR      R0,[R1, #+0]
    919            }
    920            
    921          } /* end AdvanceAntRxBufferCurrentChar() */
   \                     ??AdvanceAntRxBufferCurrentChar_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    922          
    923          
    924          /*!-----------------------------------------------------------------------------/
    925          @fn static void AdvanceAntRxBufferUnreadMsgPointer(void)
    926          
    927          @brief Increments Ant_pu8AntRxBufferUnreadMsg and handles the wrap-around.
    928          
    929          Requires:
    930          - Ant_pu8AntRxBufferUnreadMsg cannot be moved in an ISR
    931          
    932          Promises:
    933          - Ant_pu8AntRxBufferUnreadMsg points to the next char in the circular buffer
    934          
    935          */

   \                                 In section .text, align 2, keep-with-next
    936          static void AdvanceAntRxBufferUnreadMsgPointer(void)
    937          {
    938            Ant_pu8AntRxBufferUnreadMsg++;
   \                     AdvanceAntRxBufferUnreadMsgPointer: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    939            if (Ant_pu8AntRxBufferUnreadMsg == &Ant_au8AntRxBuffer[ANT_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_9
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??AdvanceAntRxBufferUnreadMsgPointer_0
    940            {
    941              Ant_pu8AntRxBufferUnreadMsg = &Ant_au8AntRxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable16_2
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000024   0x6008             STR      R0,[R1, #+0]
    942            }
    943            
    944          } /* end AdvanceAntRxBufferUnreadMsgPointer() */
   \                     ??AdvanceAntRxBufferUnreadMsgPointer_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    945          
    946          
    947          /*!------------------------------------------------------------------------------
    948          @fn u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    949          
    950          @brief Waits a specified amount of time for a particular message to arrive from ANT in 
    951          response to a message sent to ANT. ***This function violates the 1ms system rule, 
    952          so should only be used during initialization.***
    953          
    954          The expected message could be a response event, or it could be the complete
    955          message that was expected.
    956            
    957          Requires:
    958          - A message had been sent to ANT to which a response should be coming in
    959          - Ant_u8AntNewRxMessages == 0 as this function is meant to run one-to-one with
    960            transmitted messages.
    961          - SSP task should be in manual mode so it is busy sending the Tx message to which
    962            this function will wait for the ANT response.
    963          
    964          @param u8ExpectedMessageID_ is the ID of a message to which a response is expected
    965          @param u32TimeoutMS_ is the maximum value in ms to wait for the response 
    966          
    967          Promises:
    968          - Returns 0 if the message is received and was successful
    969          - Returns 1 if a response is never received or if the response indicates the
    970            message was not successful.
    971          
    972          */

   \                                 In section .text, align 2, keep-with-next
    973          static u8 AntExpectResponse(u8 u8ExpectedMessageID_, u32 u32TimeoutMS_) 
    974          {
   \                     AntExpectResponse: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    975            bool bTimeout = FALSE;
   \   00000006   0x2600             MOVS     R6,#+0
    976            u8 u8ReturnValue = 1;
   \   00000008   0x2701             MOVS     R7,#+1
    977            u32 u32StartTime = G_u32SystemTime1ms;
   \   0000000A   0x....             LDR.N    R0,??DataTable11_1
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    978          
    979            /* Wait for current message to send */
    980            while( IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_0: (+1)
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD509             BPL.N    ??AntExpectResponse_1
   \   0000001A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD106             BNE.N    ??AntExpectResponse_1
    981            {
    982              bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000020   0xF44F 0x717A      MOV      R1,#+1000
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       IsTimeUp
   \   0000002A   0x0006             MOVS     R6,R0
   \   0000002C   0xE7F0             B.N      ??AntExpectResponse_0
    983            }
    984          
    985            if( !bTimeout )
   \                     ??AntExpectResponse_1: (+1)
   \   0000002E   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000030   0x2E00             CMP      R6,#+0
   \   00000032   0xD11F             BNE.N    ??AntExpectResponse_2
    986            {
    987              /* Done with this message token, so it can be cleared */
    988              G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable21_7
   \   00000042   0x6008             STR      R0,[R1, #+0]
    989              AntDeQueueOutgoingMessage();
   \   00000044   0x.... 0x....      BL       AntDeQueueOutgoingMessage
    990              Ant_u32CurrentTxMessageToken = 0;
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable21_1
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    991              
    992              /* Wait for SEN */
    993              u32StartTime = G_u32SystemTime1ms;
   \   00000050   0x....             LDR.N    R0,??DataTable11_1
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x9000             STR      R0,[SP, #+0]
    994              while( !IS_SEN_ASSERTED() && !bTimeout )
   \                     ??AntExpectResponse_3: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x07C0             LSLS     R0,R0,#+31
   \   0000005E   0xD409             BMI.N    ??AntExpectResponse_2
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD106             BNE.N    ??AntExpectResponse_2
    995              {
    996                bTimeout = IsTimeUp(&u32StartTime, ANT_MSG_TIMEOUT_MS);
   \   00000066   0xF44F 0x717A      MOV      R1,#+1000
   \   0000006A   0xA800             ADD      R0,SP,#+0
   \   0000006C   0x.... 0x....      BL       IsTimeUp
   \   00000070   0x0006             MOVS     R6,R0
   \   00000072   0xE7F0             B.N      ??AntExpectResponse_3
    997              }
    998            }
    999            
   1000            /* If no timeout then read the incoming message */
   1001            if( !bTimeout )
   \                     ??AntExpectResponse_2: (+1)
   \   00000074   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000076   0x2E00             CMP      R6,#+0
   \   00000078   0xD125             BNE.N    ??AntExpectResponse_4
   1002            {
   1003              AntRxMessage();
   \   0000007A   0x.... 0x....      BL       AntRxMessage
   1004          
   1005              /* If there is a new message in the receive buffer, then check that it is a response to the expected
   1006              message and that the response is no error */
   1007              if(Ant_u8AntNewRxMessages)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000082   0x7800             LDRB     R0,[R0, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD01E             BEQ.N    ??AntExpectResponse_4
   1008              {
   1009          #if 0 
   1010               /* Check if the response is an Event, the event is a reply to the expected message, and the reply is good.
   1011                Since Ant_pu8AntRxBufferUnreadMsg is pointing to the SYNC byte, add 1 when using BUFFER_INDEX values. */
   1012                if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID) &&    
   1013                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
   1014                    (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET) == RESPONSE_NO_ERROR) )
   1015                {
   1016                  u8ReturnValue = 0;
   1017                }
   1018          #endif
   1019                /* 2017-11-18 Fix to handle Events and responses but also just message replys so ExpectResponse will
   1020                still return correctly for regular messages */
   1021          
   1022                /* Check if the response is an Event */
   1023                if( *(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == MESG_RESPONSE_EVENT_ID )
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x7880             LDRB     R0,[R0, #+2]
   \   00000090   0x2840             CMP      R0,#+64
   \   00000092   0xD10F             BNE.N    ??AntExpectResponse_5
   1024                {
   1025                  /* For Event messages, check if it is a reply to the expected message and the reply is good. */
   1026                  if( (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_MESG_ID_OFFSET) == u8ExpectedMessageID_) &&
   1027                      (*(Ant_pu8AntRxBufferUnreadMsg + MESG_RESPONSE_CODE_OFFSET)    == RESPONSE_NO_ERROR   ) )
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x7900             LDRB     R0,[R0, #+4]
   \   0000009C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000009E   0x42A0             CMP      R0,R4
   \   000000A0   0xD111             BNE.N    ??AntExpectResponse_4
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x7940             LDRB     R0,[R0, #+5]
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD10B             BNE.N    ??AntExpectResponse_4
   1028                  {
   1029                    u8ReturnValue = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x0007             MOVS     R7,R0
   \   000000B2   0xE008             B.N      ??AntExpectResponse_4
   1030                  }
   1031                }
   1032                /* If not an event, the message should be a response to the requested message */
   1033                else if ( *(Ant_pu8AntRxBufferUnreadMsg + MESG_ID_OFFSET) == u8ExpectedMessageID_)
   \                     ??AntExpectResponse_5: (+1)
   \   000000B4   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x7880             LDRB     R0,[R0, #+2]
   \   000000BC   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000BE   0x42A0             CMP      R0,R4
   \   000000C0   0xD101             BNE.N    ??AntExpectResponse_4
   1034                {
   1035                  u8ReturnValue = 0;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0x0007             MOVS     R7,R0
   1036                }
   1037                  
   1038              } /* end if(!bTimeout) */
   1039            }
   1040            
   1041            /* Process any message in the RxBuffer and return the result value */
   1042            AntProcessMessage();
   \                     ??AntExpectResponse_4: (+1)
   \   000000C6   0x.... 0x....      BL       AntProcessMessage
   1043            return(u8ReturnValue);
   \   000000CA   0x0038             MOVS     R0,R7
   \   000000CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1044          
   1045          } /* end AntExpectResponse */
   1046          
   1047          
   1048          /*!------------------------------------------------------------------------------
   1049          @fn static u8 AntProcessMessage(void)
   1050          
   1051          @brief Reads the latest received Ant message and updates system information accordingly. 
   1052            
   1053          Requires:
   1054          - Ant_u8AntNewRxMessages holds the number of unprocessed messages in the message queue
   1055          - Ant_pu8AntRxBufferUnreadMsg points to the first byte of an unread verified ANT message
   1056          
   1057          Promises:
   1058          - Returns 1 if Ant_u8AntNewRxMessages == 0 or the message exceeds the maximum allowed length
   1059          - Returns 0 otherwise and:
   1060            - Ant_u8AntNewRxMessages--
   1061            - Ant_pu8AntRxBufferUnreadMsg points to the first byte of the next unread verified ANT message
   1062            - System flags are updated
   1063          
   1064          */

   \                                 In section .text, align 2, keep-with-next
   1065          static u8 AntProcessMessage(void)
   1066          {
   \                     AntProcessMessage: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   1067            u8 u8MessageLength;
   1068            u8 u8Channel;
   1069            u8 au8MessageCopy[MESG_MAX_SIZE];
   1070            AntExtendedDataType sExtendedData;
   1071            
   1072            /* Exit immediately if there are no messages in the RxBuffer */
   1073          	if (!Ant_u8AntNewRxMessages)
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD101             BNE.N    ??AntProcessMessage_0
   1074            {
   1075              return(1);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xE1BE             B.N      ??AntProcessMessage_1
   1076            }
   1077            
   1078            Ant_DebugProcessRxMessages++;
   \                     ??AntProcessMessage_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21_8
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable21_8
   \   0000001E   0x6008             STR      R0,[R1, #+0]
   1079            
   1080            /* Otherwise decrement the new message counter, and get a copy of the message 
   1081            since the rx buffer is circular and we want to index the various bytes using 
   1082            the ANT byte definitions. */  
   1083            Ant_u8AntNewRxMessages--;
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable21_2
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable21_2
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   1084            AdvanceAntRxBufferUnreadMsgPointer();
   \   0000002E   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1085            u8MessageLength = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0004             MOVS     R4,R0
   1086            
   1087            /* Check to ensure the message size is legit.  !!!!! Clean up pointers if not */
   1088            if(u8MessageLength > MESG_MAX_SIZE)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C12             CMP      R4,#+18
   \   00000040   0xDB01             BLT.N    ??AntProcessMessage_2
   1089            {
   1090              return(1);
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0xE1A4             B.N      ??AntProcessMessage_1
   1091            }
   1092            
   1093            /* Copy the message so it can be indexed easily */ 
   1094            for(u8 i = 0; i < (u8MessageLength + MESG_FRAME_SIZE - MESG_SYNC_SIZE); i++)
   \                     ??AntProcessMessage_2: (+1)
   \   00000046   0x2600             MOVS     R6,#+0
   \                     ??AntProcessMessage_3: (+1)
   \   00000048   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004C   0x1CE0             ADDS     R0,R4,#+3
   \   0000004E   0x4286             CMP      R6,R0
   \   00000050   0xDA0A             BGE.N    ??AntProcessMessage_4
   1095            {
   1096              au8MessageCopy[i] = *Ant_pu8AntRxBufferUnreadMsg;
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable21_4
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000005E   0x5470             STRB     R0,[R6, R1]
   1097              AdvanceAntRxBufferUnreadMsgPointer();
   \   00000060   0x.... 0x....      BL       AdvanceAntRxBufferUnreadMsgPointer
   1098            }
   \   00000064   0x1C76             ADDS     R6,R6,#+1
   \   00000066   0xE7EF             B.N      ??AntProcessMessage_3
   1099            /* Note: Ant_pu8AntRxBufferUnreadMsg is now pointing at the next unread message */
   1100            
   1101            /* Get the channel number since it is needed for many things below (this value
   1102            will NOT be the channel for messages that do not include the channel number,
   1103            but that should be fine as long as the value is used in the correct context. */
   1104            u8Channel = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM];
   \                     ??AntProcessMessage_4: (+1)
   \   00000068   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000006C   0x0005             MOVS     R5,R0
   1105            
   1106            /* Decide what to do based on the Message ID */
   1107            switch( au8MessageCopy[BUFFER_INDEX_MESG_ID] )
   \   0000006E   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   00000072   0x283E             CMP      R0,#+62
   \   00000074   0xF000 0x8163      BEQ.W    ??AntProcessMessage_5
   \   00000078   0x2840             CMP      R0,#+64
   \   0000007A   0xD00C             BEQ.N    ??AntProcessMessage_6
   \   0000007C   0x284E             CMP      R0,#+78
   \   0000007E   0xF000 0x8152      BEQ.W    ??AntProcessMessage_7
   \   00000082   0x284F             CMP      R0,#+79
   \   00000084   0xF000 0x814F      BEQ.W    ??AntProcessMessage_7
   \   00000088   0x2852             CMP      R0,#+82
   \   0000008A   0xF000 0x8157      BEQ.W    ??AntProcessMessage_8
   \   0000008E   0x286F             CMP      R0,#+111
   \   00000090   0xF000 0x816C      BEQ.W    ??AntProcessMessage_9
   \   00000094   0xE173             B.N      ??AntProcessMessage_10
   1108            {
   1109              case MESG_RESPONSE_EVENT_ID:
   1110              { 
   1111                /* Channel Message received: it is a Channel Response or Channel Event */
   1112                if( au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] != MESG_EVENT_ID )
   \                     ??AntProcessMessage_6: (+1)
   \   00000096   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   0000009A   0x2801             CMP      R0,#+1
   \   0000009C   0xF000 0x80B9      BEQ.W    ??AntProcessMessage_11
   1113                {
   1114                  /* We have a Channel Response: parse it out based on the message ID to which the 
   1115                  response applies and post the result */
   1116                  G_stAntMessageResponse.u8Channel = u8Channel;
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable21_9
   \   000000A4   0x7005             STRB     R5,[R0, #+0]
   1117                  G_stAntMessageResponse.u8MessageNumber = au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID];
   \   000000A6   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable21_9
   \   000000AE   0x7048             STRB     R0,[R1, #+1]
   1118                  G_stAntMessageResponse.u8ResponseCode  = au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE];      
   \   000000B0   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable21_9
   \   000000B8   0x7088             STRB     R0,[R1, #+2]
   1119                  
   1120                  switch(au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID])
   \   000000BA   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000BE   0x2841             CMP      R0,#+65
   \   000000C0   0xD042             BEQ.N    ??AntProcessMessage_12
   \   000000C2   0x284B             CMP      R0,#+75
   \   000000C4   0xD007             BEQ.N    ??AntProcessMessage_13
   \   000000C6   0x284C             CMP      R0,#+76
   \   000000C8   0xD033             BEQ.N    ??AntProcessMessage_14
   \   000000CA   0x285B             CMP      R0,#+91
   \   000000CC   0xD15B             BNE.N    ??AntProcessMessage_15
   1121                  {
   1122                    case MESG_OPEN_SCAN_CHANNEL_ID:
   1123                    {
   1124                      DebugPrintf("Scanning ");
   \                     ??AntProcessMessage_16: (+1)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable21_10
   \   000000D2   0x.... 0x....      BL       DebugPrintf
   1125                      /* Fall through */
   1126                    }
   1127                      
   1128                    case MESG_OPEN_CHANNEL_ID:
   1129                    {
   1130                      G_au8AntMessageOpen[12] = u8Channel + 0x30;
   \                     ??AntProcessMessage_13: (+1)
   \   000000D6   0xF115 0x0030      ADDS     R0,R5,#+48
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable21_11
   \   000000DE   0x7308             STRB     R0,[R1, #+12]
   1131                      DebugPrintf(G_au8AntMessageOpen);
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable21_11
   \   000000E4   0x.... 0x....      BL       DebugPrintf
   1132                      
   1133                      /* Only change the flags if the command was successful */
   1134                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   000000E8   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD11F             BNE.N    ??AntProcessMessage_17
   1135                      {
   1136                        G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000000F4   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000F6   0x2114             MOVS     R1,#+20
   \   000000F8   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000000FC   0x7CC0             LDRB     R0,[R0, #+19]
   \   000000FE   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000106   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000108   0x2214             MOVS     R2,#+20
   \   0000010A   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000010E   0x74C8             STRB     R0,[R1, #+19]
   1137                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   00000110   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000114   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000116   0x2114             MOVS     R1,#+20
   \   00000118   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000011C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000011E   0xF010 0x00FD      ANDS     R0,R0,#0xFD
   \   00000122   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   00000126   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000128   0x2214             MOVS     R2,#+20
   \   0000012A   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   0000012E   0x74C8             STRB     R0,[R1, #+19]
   1138                      }
   1139                      break;
   \                     ??AntProcessMessage_17: (+1)
   \   00000130   0xE059             B.N      ??AntProcessMessage_18
   1140                    }
   1141                    
   1142                    case MESG_CLOSE_CHANNEL_ID:
   1143                    {  
   1144                      G_au8AntMessageClose[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_14: (+1)
   \   00000132   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000136   0x3030             ADDS     R0,R0,#+48
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable21_12
   \   0000013C   0x7308             STRB     R0,[R1, #+12]
   1145                      DebugPrintf(G_au8AntMessageClose);
   \   0000013E   0x.... 0x....      LDR.W    R0,??DataTable21_12
   \   00000142   0x.... 0x....      BL       DebugPrintf
   1146          
   1147                      break;
   \   00000146   0xE04E             B.N      ??AntProcessMessage_18
   1148                    }
   1149                    
   1150                    case MESG_UNASSIGN_CHANNEL_ID:
   1151                    {
   1152                      G_au8AntMessageUnassign[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + 0x30;
   \                     ??AntProcessMessage_12: (+1)
   \   00000148   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000014C   0x3030             ADDS     R0,R0,#+48
   \   0000014E   0x.... 0x....      LDR.W    R1,??DataTable21_13
   \   00000152   0x7308             STRB     R0,[R1, #+12]
   1153                      DebugPrintf(G_au8AntMessageUnassign);
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable21_13
   \   00000158   0x.... 0x....      BL       DebugPrintf
   1154          
   1155                      /* Only change the flags if the command was successful */
   1156                      if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR )
   \   0000015C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000160   0x2800             CMP      R0,#+0
   \   00000162   0xD10F             BNE.N    ??AntProcessMessage_19
   1157                      {
   1158                        G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_CONFIGURED;
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000168   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000016A   0x2114             MOVS     R1,#+20
   \   0000016C   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   00000170   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000172   0xF010 0x00FE      ANDS     R0,R0,#0xFE
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable16_1
   \   0000017A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000017C   0x2214             MOVS     R2,#+20
   \   0000017E   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000182   0x74C8             STRB     R0,[R1, #+19]
   1159                      }
   1160                      break;
   \                     ??AntProcessMessage_19: (+1)
   \   00000184   0xE02F             B.N      ??AntProcessMessage_18
   1161                    }
   1162                    
   1163                    default:
   1164                    {
   1165                      G_au8AntMessageUnhandled[12] = au8MessageCopy[BUFFER_INDEX_CHANNEL_NUM] + NUMBER_ASCII_TO_DEC;
   \                     ??AntProcessMessage_15: (+1)
   \   00000186   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   0000018A   0x3030             ADDS     R0,R0,#+48
   \   0000018C   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   00000190   0x7308             STRB     R0,[R1, #+12]
   1166                      G_au8AntMessageUnhandled[24] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] >> 4) & 0x0F );
   \   00000192   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   00000196   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000198   0x0900             LSRS     R0,R0,#+4
   \   0000019A   0x.... 0x....      BL       HexToASCIICharLower
   \   0000019E   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   000001A2   0x7608             STRB     R0,[R1, #+24]
   1167                      G_au8AntMessageUnhandled[25] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_MESG_ID] & 0x0F) );
   \   000001A4   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000001A8   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001AC   0x.... 0x....      BL       HexToASCIICharLower
   \   000001B0   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   000001B4   0x7648             STRB     R0,[R1, #+25]
   1168                      G_au8AntMessageUnhandled[36] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] >> 4) & 0x0F );
   \   000001B6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001BA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001BC   0x0900             LSRS     R0,R0,#+4
   \   000001BE   0x.... 0x....      BL       HexToASCIICharLower
   \   000001C2   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   000001C6   0xF881 0x0024      STRB     R0,[R1, #+36]
   1169                      G_au8AntMessageUnhandled[37] = HexToASCIICharLower( (au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] & 0x0F) );
   \   000001CA   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001CE   0xF010 0x000F      ANDS     R0,R0,#0xF
   \   000001D2   0x.... 0x....      BL       HexToASCIICharLower
   \   000001D6   0x.... 0x....      LDR.W    R1,??DataTable21_14
   \   000001DA   0xF881 0x0025      STRB     R0,[R1, #+37]
   1170                      DebugPrintf(G_au8AntMessageUnhandled);
   \   000001DE   0x.... 0x....      LDR.W    R0,??DataTable21_14
   \   000001E2   0x.... 0x....      BL       DebugPrintf
   1171                      break;
   1172                    }
   1173                  } /* end switch */
   1174                  
   1175                  /* All messages print an "ok" or "fail" */
   1176                  if( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] == RESPONSE_NO_ERROR ) 
   \                     ??AntProcessMessage_18: (+1)
   \   000001E6   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xD104             BNE.N    ??AntProcessMessage_20
   1177                  {
   1178                    DebugPrintf(G_au8AntMessageOk);
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   000001F2   0x.... 0x....      BL       DebugPrintf
   \   000001F6   0xE095             B.N      ??AntProcessMessage_21
   1179                  }
   1180                  else
   1181                  {
   1182                    DebugPrintf(G_au8AntMessageFail);
   \                     ??AntProcessMessage_20: (+1)
   \   000001F8   0x.... 0x....      LDR.W    R0,??DataTable21_15
   \   000001FC   0x.... 0x....      BL       DebugPrintf
   1183                    G_u32AntFlags |= _ANT_FLAGS_CMD_ERROR;
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   00000204   0x6800             LDR      R0,[R0, #+0]
   \   00000206   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000020A   0x.... 0x....      LDR.W    R1,??DataTable21_7
   \   0000020E   0x6008             STR      R0,[R1, #+0]
   \   00000210   0xE088             B.N      ??AntProcessMessage_21
   1184                  }
   1185          
   1186                }
   1187                /* The message is a Channel Event, so the Event Code must be parsed out */
   1188                else 
   1189                { 
   1190                  switch ( au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE] )
   \                     ??AntProcessMessage_11: (+1)
   \   00000212   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000216   0x2800             CMP      R0,#+0
   \   00000218   0xD00E             BEQ.N    ??AntProcessMessage_22
   \   0000021A   0x2801             CMP      R0,#+1
   \   0000021C   0xD05B             BEQ.N    ??AntProcessMessage_23
   \   0000021E   0x2802             CMP      R0,#+2
   \   00000220   0xD00E             BEQ.N    ??AntProcessMessage_24
   \   00000222   0x2803             CMP      R0,#+3
   \   00000224   0xD033             BEQ.N    ??AntProcessMessage_25
   \   00000226   0x2805             CMP      R0,#+5
   \   00000228   0xD03E             BEQ.N    ??AntProcessMessage_26
   \   0000022A   0x2806             CMP      R0,#+6
   \   0000022C   0xD04F             BEQ.N    ??AntProcessMessage_27
   \   0000022E   0x2807             CMP      R0,#+7
   \   00000230   0xD055             BEQ.N    ??AntProcessMessage_28
   \   00000232   0x2808             CMP      R0,#+8
   \   00000234   0xD027             BEQ.N    ??AntProcessMessage_29
   \   00000236   0xE065             B.N      ??AntProcessMessage_30
   1191                  {
   1192                    case RESPONSE_NO_ERROR: 
   1193                    {
   1194                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_22: (+1)
   \   00000238   0xA800             ADD      R0,SP,#+0
   \   0000023A   0x.... 0x....      BL       AntTickExtended
   1195          #ifdef ANT_VERBOSE 
   1196                      DebugPrintf("\n\rRESPONSE_NO_ERROR\n\r");
   1197          #endif
   1198                      break;
   \   0000023E   0xE071             B.N      ??AntProcessMessage_21
   1199                    }
   1200          
   1201                    case EVENT_RX_FAIL: /* Slave did not receive a message when expected */
   1202                    {
   1203                      /* The Slave missed a message it was expecting: communicate this to the
   1204                      application in case it matters. Could also queue a debug message here. */
   1205                      Ant_u8SlaveMissedMessageLow++;
   \                     ??AntProcessMessage_24: (+1)
   \   00000240   0x.... 0x....      LDR.W    R0,??DataTable21_16
   \   00000244   0x7800             LDRB     R0,[R0, #+0]
   \   00000246   0x1C40             ADDS     R0,R0,#+1
   \   00000248   0x.... 0x....      LDR.W    R1,??DataTable21_16
   \   0000024C   0x7008             STRB     R0,[R1, #+0]
   1206                      if(Ant_u8SlaveMissedMessageLow == 0)
   \   0000024E   0x.... 0x....      LDR.W    R0,??DataTable21_16
   \   00000252   0x7800             LDRB     R0,[R0, #+0]
   \   00000254   0x2800             CMP      R0,#+0
   \   00000256   0xD112             BNE.N    ??AntProcessMessage_31
   1207                      {
   1208                        Ant_u8SlaveMissedMessageMid++;
   \   00000258   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   0000025C   0x7800             LDRB     R0,[R0, #+0]
   \   0000025E   0x1C40             ADDS     R0,R0,#+1
   \   00000260   0x.... 0x....      LDR.W    R1,??DataTable21_17
   \   00000264   0x7008             STRB     R0,[R1, #+0]
   1209                        if(Ant_u8SlaveMissedMessageMid == 0)
   \   00000266   0x.... 0x....      LDR.W    R0,??DataTable21_17
   \   0000026A   0x7800             LDRB     R0,[R0, #+0]
   \   0000026C   0x2800             CMP      R0,#+0
   \   0000026E   0xD106             BNE.N    ??AntProcessMessage_31
   1210                        {
   1211                          Ant_u8SlaveMissedMessageHigh++;
   \   00000270   0x.... 0x....      LDR.W    R0,??DataTable21_18
   \   00000274   0x7800             LDRB     R0,[R0, #+0]
   \   00000276   0x1C40             ADDS     R0,R0,#+1
   \   00000278   0x.... 0x....      LDR.W    R1,??DataTable21_18
   \   0000027C   0x7008             STRB     R0,[R1, #+0]
   1212                          /* Let this overflow without action */
   1213                        }
   1214                      }
   1215                      
   1216                      /* Queue an ANT_TICK message to the application message list. */
   1217                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_31: (+1)
   \   0000027E   0xA800             ADD      R0,SP,#+0
   \   00000280   0x.... 0x....      BL       AntTickExtended
   1218          #ifdef ANT_VERBOSE 
   1219                      DebugPrintf("\n\rEVENT_RX_FAIL\n\r");
   1220          #endif
   1221                      break;
   \   00000284   0xE04E             B.N      ??AntProcessMessage_21
   1222                    }
   1223          
   1224                    case EVENT_RX_FAIL_GO_TO_SEARCH: /* Slave has lost sync with Master (channel still open) */
   1225                    {
   1226                      /* The Slave missed enough consecutive messages so it goes back to search: communicate this to the
   1227                      application in case it matters. Could also queue a debug message here. */
   1228                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_29: (+1)
   \   00000286   0xA800             ADD      R0,SP,#+0
   \   00000288   0x.... 0x....      BL       AntTickExtended
   1229          #ifdef ANT_VERBOSE 
   1230                      DebugPrintf("\n\rEVENT_RX_FAIL_GO_TO_SEARCH\n\r");
   1231          #endif
   1232                      break;
   \   0000028C   0xE04A             B.N      ??AntProcessMessage_21
   1233                    }
   1234          
   1235                    case EVENT_TX: /* ANT has sent a data message */
   1236                    {
   1237                      /* If this is a Master device, then EVENT_TX means it's time to queue the 
   1238                      next message */
   1239                      if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_MASTER)
   \                     ??AntProcessMessage_25: (+1)
   \   0000028E   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   00000292   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000294   0x2114             MOVS     R1,#+20
   \   00000296   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000029A   0x7840             LDRB     R0,[R0, #+1]
   \   0000029C   0x2810             CMP      R0,#+16
   \   0000029E   0xD102             BNE.N    ??AntProcessMessage_32
   1240                      {
   1241                        AntTickExtended(au8MessageCopy);
   \   000002A0   0xA800             ADD      R0,SP,#+0
   \   000002A2   0x.... 0x....      BL       AntTickExtended
   1242                      }
   1243          #ifdef ANT_VERBOSE 
   1244                      DebugPrintf("\n\rEVENT_TX\n\r");
   1245          #endif
   1246                      break;
   \                     ??AntProcessMessage_32: (+1)
   \   000002A6   0xE03D             B.N      ??AntProcessMessage_21
   1247                    } 
   1248          
   1249                    case EVENT_TRANSFER_TX_COMPLETED: /* ACK received from an acknowledged data message */
   1250                    { 
   1251                      G_asAntChannelConfiguration[u8Channel].AntFlags |= _ANT_FLAGS_GOT_ACK;
   \                     ??AntProcessMessage_26: (+1)
   \   000002A8   0x.... 0x....      LDR.W    R0,??DataTable16_1
   \   000002AC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002AE   0x2114             MOVS     R1,#+20
   \   000002B0   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000002B4   0x7CC0             LDRB     R0,[R0, #+19]
   \   000002B6   0xF050 0x0010      ORRS     R0,R0,#0x10
   \   000002BA   0x....             LDR.N    R1,??DataTable16_1
   \   000002BC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002BE   0x2214             MOVS     R2,#+20
   \   000002C0   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   000002C4   0x74C8             STRB     R0,[R1, #+19]
   1252          
   1253                      AntTickExtended(au8MessageCopy);
   \   000002C6   0xA800             ADD      R0,SP,#+0
   \   000002C8   0x.... 0x....      BL       AntTickExtended
   1254          #ifdef ANT_VERBOSE 
   1255                      DebugPrintf("\n\rEVENT_TRANSFER_TX_COMPLETED\n\r");
   1256          #endif
   1257                      break;
   \   000002CC   0xE02A             B.N      ??AntProcessMessage_21
   1258                    } 
   1259          
   1260                    case EVENT_TRANSFER_TX_FAILED: /* ACK was not received from an acknowledged data message */
   1261                    { 
   1262                      /* Regardless of complete or fail, it is time to send the next message */
   1263                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_27: (+1)
   \   000002CE   0xA800             ADD      R0,SP,#+0
   \   000002D0   0x.... 0x....      BL       AntTickExtended
   1264          #ifdef ANT_VERBOSE 
   1265                      DebugPrintf("\n\rEVENT_TRANSFER_TX_FAILED\n\r");
   1266          #endif
   1267                      break;
   \   000002D4   0xE026             B.N      ??AntProcessMessage_21
   1268                    } 
   1269          
   1270                    case EVENT_RX_SEARCH_TIMEOUT: /* The ANT channel is going to close due to search timeout */
   1271                    {
   1272                      /* Forward this to application */
   1273                      AntTickExtended(au8MessageCopy);
   \                     ??AntProcessMessage_23: (+1)
   \   000002D6   0xA800             ADD      R0,SP,#+0
   \   000002D8   0x.... 0x....      BL       AntTickExtended
   1274          #ifdef ANT_VERBOSE 
   1275                      DebugPrintf("\n\rEVENT_RX_SEARCH_TIMEOUT\n\r");
   1276          #endif
   1277                      break;
   \   000002DC   0xE022             B.N      ??AntProcessMessage_21
   1278                    }
   1279           
   1280                    case EVENT_CHANNEL_CLOSED: /* The ANT channel is now closed */
   1281                    {
   1282                      DebugPrintf("Channel closed\n\r");
   \                     ??AntProcessMessage_28: (+1)
   \   000002DE   0x.... 0x....      LDR.W    R0,??DataTable21_19
   \   000002E2   0x.... 0x....      BL       DebugPrintf
   1283                      G_asAntChannelConfiguration[u8Channel].AntFlags &= ~_ANT_FLAGS_CHANNEL_OPEN;
   \   000002E6   0x....             LDR.N    R0,??DataTable16_1
   \   000002E8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002EA   0x2114             MOVS     R1,#+20
   \   000002EC   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   000002F0   0x7CC0             LDRB     R0,[R0, #+19]
   \   000002F2   0xF010 0x00FB      ANDS     R0,R0,#0xFB
   \   000002F6   0x....             LDR.N    R1,??DataTable16_1
   \   000002F8   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000002FA   0x2214             MOVS     R2,#+20
   \   000002FC   0xFB02 0x1105      MLA      R1,R2,R5,R1
   \   00000300   0x74C8             STRB     R0,[R1, #+19]
   1284          #ifdef ANT_VERBOSE 
   1285                      DebugPrintf("\n\rEVENT_CHANNEL_CLOSED\n\r");
   1286          #endif
   1287                      break;
   \   00000302   0xE00F             B.N      ??AntProcessMessage_21
   1288                    }
   1289                    
   1290                    /* All other messages are unexpected for now */
   1291                    default:
   1292                    {
   1293                      DebugPrintNumber(au8MessageCopy[BUFFER_INDEX_RESPONSE_CODE]);
   \                     ??AntProcessMessage_30: (+1)
   \   00000304   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000308   0x.... 0x....      BL       DebugPrintNumber
   1294                      DebugPrintf(": unexpected channel event\n\r");
   \   0000030C   0x.... 0x....      LDR.W    R0,??DataTable21_20
   \   00000310   0x.... 0x....      BL       DebugPrintf
   1295          
   1296                      G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_EVENT;
   \   00000314   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   00000318   0x6800             LDR      R0,[R0, #+0]
   \   0000031A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000031E   0x.... 0x....      LDR.W    R1,??DataTable21_7
   \   00000322   0x6008             STR      R0,[R1, #+0]
   1297                      break;
   1298                    }
   1299                  } /* end Ant_pu8AntRxBufferUnreadMsg[EVENT_CODE_INDEX] */
   1300                } /* end else RF event */
   1301                
   1302                break; 
   \                     ??AntProcessMessage_21: (+1)
   \   00000324   0xE033             B.N      ??AntProcessMessage_33
   1303              } /* end case MESG_RESPONSE_EVENT_ID */
   1304          
   1305              case MESG_ACKNOWLEDGED_DATA_ID: /* An acknowledged data message was received */
   1306              /* Fall through */
   1307                
   1308              case MESG_BROADCAST_DATA_ID: /* A broadcast data message was received */
   1309              { 
   1310                /* Parse the extended data and put the message to the application buffer */
   1311                AntParseExtendedData(au8MessageCopy, &sExtendedData);
   \                     ??AntProcessMessage_7: (+1)
   \   00000326   0xA905             ADD      R1,SP,#+20
   \   00000328   0xA800             ADD      R0,SP,#+0
   \   0000032A   0x.... 0x....      BL       AntParseExtendedData
   1312                AntQueueExtendedApplicationMessage(ANT_DATA, &au8MessageCopy[BUFFER_INDEX_MESG_DATA], &sExtendedData);
   \   0000032E   0xAA05             ADD      R2,SP,#+20
   \   00000330   0xF10D 0x0103      ADD      R1,SP,#+3
   \   00000334   0x2001             MOVS     R0,#+1
   \   00000336   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1313                
   1314          #if 0 
   1315          /* 2017-JUN-23 Don't think this should be here as it should be
   1316          the application looking for data messages and deciding what
   1317          that should be. If it is required, perhaps the call to AntTickExtended
   1318          should be modified since au8MessageCopy doesn't have an EVENT CODE. 
   1319                
   1320          There are some legacy applications that will fail if this is removed, so
   1321          we'll keep the code available until those can be updated.  Do not rely on
   1322          this for future development. */
   1323                
   1324                /* If this is a Slave device, then a data message received means it's time to send */
   1325                if(G_asAntChannelConfiguration[u8Channel].AntChannelType == CHANNEL_TYPE_SLAVE)
   1326                {
   1327                  AntTickExtended(au8MessageCopy);
   1328                }
   1329          #endif      
   1330                break;
   \   0000033A   0xE028             B.N      ??AntProcessMessage_33
   1331              } /* end case MESG_BROADCAST_DATA_ID */
   1332              
   1333              case MESG_CHANNEL_STATUS_ID: /* Message sent in response to a channel status request */
   1334              { 
   1335                break;
   \                     ??AntProcessMessage_8: (+1)
   \   0000033C   0xE027             B.N      ??AntProcessMessage_33
   1336              } /* end case ChannelStatus_CMD */
   1337              
   1338              case MESG_VERSION_ID:
   1339              {
   1340                for(u8 i = 0; i < MESG_VERSION_SIZE; i++)
   \                     ??AntProcessMessage_5: (+1)
   \   0000033E   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_34: (+1)
   \   00000340   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000342   0x280A             CMP      R0,#+10
   \   00000344   0xDA09             BGE.N    ??AntProcessMessage_35
   1341                {
   1342                  Ant_u8AntVersion[i] = au8MessageCopy[BUFFER_INDEX_VERSION_BYTE0 + i];
   \   00000346   0xA900             ADD      R1,SP,#+0
   \   00000348   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000034A   0x1841             ADDS     R1,R0,R1
   \   0000034C   0x7889             LDRB     R1,[R1, #+2]
   \   0000034E   0x.... 0x....      LDR.W    R2,??DataTable18_1
   \   00000352   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000354   0x5481             STRB     R1,[R0, R2]
   1343                }
   \   00000356   0x1C40             ADDS     R0,R0,#+1
   \   00000358   0xE7F2             B.N      ??AntProcessMessage_34
   1344                
   1345                /* If we get a version message, we know that ANT comms is good */
   1346                G_u32ApplicationFlags |= _APPLICATION_FLAGS_ANT;
   \                     ??AntProcessMessage_35: (+1)
   \   0000035A   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000035E   0x6800             LDR      R0,[R0, #+0]
   \   00000360   0xF050 0x0040      ORRS     R0,R0,#0x40
   \   00000364   0x.... 0x....      LDR.W    R1,??DataTable17
   \   00000368   0x6008             STR      R0,[R1, #+0]
   1347                
   1348                break;
   \   0000036A   0xE010             B.N      ??AntProcessMessage_33
   1349              } /* end case MESG_VERSION_ID */
   1350          
   1351              case MESG_RESTART_ID:
   1352              {
   1353                G_u32AntFlags |= _ANT_FLAGS_RESTART;  
   \                     ??AntProcessMessage_9: (+1)
   \   0000036C   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   00000370   0x6800             LDR      R0,[R0, #+0]
   \   00000372   0xF450 0x3080      ORRS     R0,R0,#0x10000
   \   00000376   0x.... 0x....      LDR.W    R1,??DataTable21_7
   \   0000037A   0x6008             STR      R0,[R1, #+0]
   1354                break;
   \   0000037C   0xE007             B.N      ??AntProcessMessage_33
   1355              } /* end case MESG_RESTART_ID */
   1356              
   1357              default:
   1358              {
   1359                G_u32AntFlags |= _ANT_FLAGS_UNEXPECTED_MSG;
   \                     ??AntProcessMessage_10: (+1)
   \   0000037E   0x.... 0x....      LDR.W    R0,??DataTable21_7
   \   00000382   0x6800             LDR      R0,[R0, #+0]
   \   00000384   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000388   0x.... 0x....      LDR.W    R1,??DataTable21_7
   \   0000038C   0x6008             STR      R0,[R1, #+0]
   1360                break;
   1361              }
   1362            } /* end switch( Ant_pu8AntRxBufferUnreadMsg[MESG_ID_OFFSET] ) */
   1363                     
   1364            return(0);
   \                     ??AntProcessMessage_33: (+1)
   \   0000038E   0x2000             MOVS     R0,#+0
   \                     ??AntProcessMessage_1: (+1)
   \   00000390   0xB008             ADD      SP,SP,#+32
   \   00000392   0xBD70             POP      {R4-R6,PC}       ;; return
   1365            
   1366          } /* end AntProcessMessage() */
   1367          
   1368          
   1369          /*!------------------------------------------------------------------------------
   1370          @fn static bool AntParseExtendedData(u8* pu8SourceMessage_, AntExtendedDataType* psExtDataTarget_)
   1371          
   1372          @brief Reads extended data based on the flags that are set.
   1373          
   1374          Loads AntExtendedDataType which currently has these fields:
   1375          {
   1376            u8 u8Channel;                        
   1377            u16 u16DeviceID;                         
   1378            u8 u8DeviceType;                         
   1379            u8 u8TransType;                          
   1380            u8 u8Flags;                             
   1381            s8 s8RSSI;                              
   1382          } AntExtendedDataType;
   1383          
   1384          For now we don't have a use for MeasurementType or Threshold from the RSSI
   1385          extended information, so this code is commented out but in the correct location if needed.
   1386          
   1387          Requires:
   1388          @param pu8SourceMessage_ points to an ANT message buffer that holds a complete ANT data
   1389                 message structure except for SYNC byte; therefore buffer indices from antmessage.h can be used.
   1390          @param psExtDataTarget_ points to the target AntExtendedDataType structure
   1391          
   1392          Promises:
   1393          - Returns TRUE if extended data is present; all values are read into local variables and then
   1394            loaded into psExtDataTarget_.
   1395          - Returns FALSE if no extended data is present; psExtDataTarget_ is set to default values
   1396          
   1397          */

   \                                 In section .text, align 2, keep-with-next
   1398          static bool AntParseExtendedData(u8* pu8SourceMessage_, AntExtendedDataType* psExtDataTarget_)
   1399          {
   \                     AntParseExtendedData: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1400            bool bReturnValue;
   1401            u8 u8MessageSize;
   1402            u8 u8Channel;                        
   1403            u8 u8Flags = 0;       
   \   00000008   0x2600             MOVS     R6,#+0
   1404            u8 u8BufferOffset = 0;
   \   0000000A   0xF05F 0x0B00      MOVS     R11,#+0
   1405            
   1406            /* Channel ID extended data */
   1407            u16 u16DeviceID = 0xFFFF;;                         
   \   0000000E   0xF64F 0x7AFF      MOVW     R10,#+65535
   1408            u8 u8DeviceType = 0xFF;                        
   \   00000012   0x20FF             MOVS     R0,#+255
   \   00000014   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1409            u8 u8TransType = 0xFF;                          
   \   00000018   0x27FF             MOVS     R7,#+255
   1410          
   1411            /* RSSI extended data */
   1412            s8 s8RSSI = 0xFF;   
   \   0000001A   0xF05F 0x38FF      MOVS     R8,#-1
   1413            //u8 u8MeasurementType = 0xFF;
   1414            //u8 u8Threshold = 0xFF;
   1415            
   1416            /* RF Timestamp data */
   1417            u16 u16RxTimestamp = 0xFFFF;
   \   0000001E   0xF64F 0x79FF      MOVW     R9,#+65535
   1418              
   1419            /* Get generic data */
   1420            u8MessageSize = *(pu8SourceMessage_ + BUFFER_INDEX_MESG_SIZE);
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1421            u8Channel = *(pu8SourceMessage_ + BUFFER_INDEX_CHANNEL_NUM);
   \   00000028   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002A   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1422          
   1423            /* Check to see if the message is the regular size (MESG_MAX_DATA_SIZE) */
   1424            if(u8MessageSize == MESG_MAX_DATA_SIZE)
   \   0000002E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000032   0x2809             CMP      R0,#+9
   \   00000034   0xD103             BNE.N    ??AntParseExtendedData_0
   1425            {
   1426              bReturnValue = FALSE;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000003C   0xE058             B.N      ??AntParseExtendedData_1
   1427            }
   1428            
   1429            /* Check for a message that is too big or too small */
   1430            else if( (u8MessageSize > MESG_MAX_SIZE) ||
   1431                     (u8MessageSize < MESG_MAX_DATA_SIZE) )
   \                     ??AntParseExtendedData_0: (+1)
   \   0000003E   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000042   0x2812             CMP      R0,#+18
   \   00000044   0xDA03             BGE.N    ??AntParseExtendedData_2
   \   00000046   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000004A   0x2809             CMP      R0,#+9
   \   0000004C   0xDA07             BGE.N    ??AntParseExtendedData_3
   1432            {
   1433              DebugPrintf("\n\rUnexpected ANT message size\n\n\r");
   \                     ??AntParseExtendedData_2: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable21_21
   \   00000052   0x.... 0x....      BL       DebugPrintf
   1434              bReturnValue = FALSE;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xF88D 0x0001      STRB     R0,[SP, #+1]
   \   0000005C   0xE048             B.N      ??AntParseExtendedData_1
   1435            }
   1436            
   1437            /* Otherwise we have some extended message data */
   1438            else 
   1439            {
   1440              /* The byte after data must be flag byte */
   1441              u8Flags = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA_FLAGS);
   \                     ??AntParseExtendedData_3: (+1)
   \   0000005E   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000060   0x0006             MOVS     R6,R0
   1442              bReturnValue = TRUE;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1443              
   1444              /* Channel ID information is always first if it's there */
   1445              if(u8Flags & LIB_CONFIG_CHANNEL_ID_FLAG)
   \   00000068   0x0630             LSLS     R0,R6,#+24
   \   0000006A   0xD521             BPL.N    ??AntParseExtendedData_4
   1446              {
   1447                u16DeviceID = (u16)(*(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   0000006C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000070   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000074   0x7B00             LDRB     R0,[R0, #+12]
   \   00000076   0x4682             MOV      R10,R0
   1448                u8BufferOffset++;
   \   00000078   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1449                u16DeviceID |= ( (u16)(*(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   0000007C   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000080   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000084   0x7B00             LDRB     R0,[R0, #+12]
   \   00000086   0xEA5A 0x2A00      ORRS     R10,R10,R0, LSL #+8
   1450                u8BufferOffset++;
   \   0000008A   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1451                u8DeviceType = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   0000008E   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   00000092   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   00000096   0x7B00             LDRB     R0,[R0, #+12]
   \   00000098   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1452                u8BufferOffset++;
   \   0000009C   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1453                u8TransType = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000A0   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000A4   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000A8   0x7B00             LDRB     R0,[R0, #+12]
   \   000000AA   0x0007             MOVS     R7,R0
   1454                u8BufferOffset++;
   \   000000AC   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1455              }
   1456              
   1457              /* RSSI information is always next if it's there */
   1458              if(u8Flags & LIB_CONFIG_RSSI_FLAG)
   \                     ??AntParseExtendedData_4: (+1)
   \   000000B0   0x0670             LSLS     R0,R6,#+25
   \   000000B2   0xD50C             BPL.N    ??AntParseExtendedData_5
   1459              {
   1460                //u8MeasurementType = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   1461                u8BufferOffset++;
   \   000000B4   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1462                s8RSSI = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   \   000000B8   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000BC   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000C0   0xF990 0x000C      LDRSB    R0,[R0, #+12]
   \   000000C4   0x4680             MOV      R8,R0
   1463                u8BufferOffset++;
   \   000000C6   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1464                //u8Threshold = *(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset);
   1465                u8BufferOffset++;
   \   000000CA   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1466              }   
   1467          
   1468              /* Timestamp information is always last */
   1469              if(u8Flags & LIB_CONFIG_RX_TIMESTAMP_FLAG)
   \                     ??AntParseExtendedData_5: (+1)
   \   000000CE   0x06B0             LSLS     R0,R6,#+26
   \   000000D0   0xD50E             BPL.N    ??AntParseExtendedData_1
   1470              {
   1471                u16RxTimestamp = (u16)(*(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) & 0x00FF;
   \   000000D2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000D6   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000DA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000DC   0x4681             MOV      R9,R0
   1472                u8BufferOffset++;
   \   000000DE   0xF11B 0x0B01      ADDS     R11,R11,#+1
   1473                u16RxTimestamp |= ( (u16)(*(pu8SourceMessage_ + BUFFER_INDEX_EXT_DATA + u8BufferOffset)) << 8 ) & 0xFF00;
   \   000000E2   0xFA5F 0xFB8B      UXTB     R11,R11          ;; ZeroExt  R11,R11,#+24,#+24
   \   000000E6   0xEB1B 0x0004      ADDS     R0,R11,R4
   \   000000EA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000EC   0xEA59 0x2900      ORRS     R9,R9,R0, LSL #+8
   1474              }
   1475            }
   1476            
   1477            /* Load psExtDataTarget_ (either real or default data) and return */
   1478            psExtDataTarget_->u8Flags      = u8Flags;
   \                     ??AntParseExtendedData_1: (+1)
   \   000000F0   0x706E             STRB     R6,[R5, #+1]
   1479            psExtDataTarget_->u8Channel    = u8Channel;
   \   000000F2   0xF89D 0x0003      LDRB     R0,[SP, #+3]
   \   000000F6   0x7028             STRB     R0,[R5, #+0]
   1480            psExtDataTarget_->u16DeviceID  = u16DeviceID;
   \   000000F8   0xF8A5 0xA002      STRH     R10,[R5, #+2]
   1481            psExtDataTarget_->u8DeviceType = u8DeviceType;
   \   000000FC   0xF89D 0x0002      LDRB     R0,[SP, #+2]
   \   00000100   0x7128             STRB     R0,[R5, #+4]
   1482            psExtDataTarget_->u8TransType  = u8TransType;
   \   00000102   0x716F             STRB     R7,[R5, #+5]
   1483            psExtDataTarget_->s8RSSI       = s8RSSI;
   \   00000104   0xF885 0x8006      STRB     R8,[R5, #+6]
   1484          
   1485            return bReturnValue;
   \   00000108   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000010C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   1486            
   1487          } /* end AntParseExtendedData */
   1488          
   1489          
   1490          /*!-----------------------------------------------------------------------------/
   1491          @fn static bool AntQueueExtendedApplicationMessage(AntApplicationMessageType eMessageType_, u8* pu8DataSource_, AntExtendedDataType* psExtData_)
   1492          
   1493          @brief Creates a new ANT message structure and adds it to G_psAntApplicationMsgList.
   1494          
   1495          The Application list is used to communicate message information between the ANT driver and
   1496          the ANT_API simplified interface task.  It has room for ANT_APPLICATION_MESSAGE_BUFFER_SIZE
   1497          messages. The messages are either ANT_DATA or ANT_TICK messsage and include
   1498          all information and data from the original ANT message.
   1499          
   1500          Requires:
   1501          - Enough space is available on the heap
   1502          
   1503          @param eMessageType_ specifies the type of message
   1504          @param pu8DataSource_ is a pointer to the first element of an array of 8 data bytes
   1505          @param psTargetList_ is a pointer to the list pointer that is being updated
   1506          
   1507          Promises:
   1508          - A new list item in the target linked list is created and inserted at the end
   1509            of the list.
   1510          - Returns TRUE if the entry is added successfully.
   1511          - Returns FALSE if the malloc fails or the list is full.
   1512          
   1513          */

   \                                 In section .text, align 2, keep-with-next
   1514          static bool AntQueueExtendedApplicationMessage(AntApplicationMessageType eMessageType_, 
   1515                                                         u8* pu8DataSource_, 
   1516                                                         AntExtendedDataType* psExtData_)
   1517          {
   \                     AntQueueExtendedApplicationMessage: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB08B             SUB      SP,SP,#+44
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   1518            AntApplicationMsgListType *psNewMessage;
   1519            AntApplicationMsgListType *psListParser;
   1520            u8 u8MessageCount = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
   1521            u8 Ant_au8AddMessageFailMsg[] = "\n\rNo space in AntQueueApplicationMessage\n\r";
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable21_22
   \   00000016   0x222B             MOVS     R2,#+43
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy
   1522            
   1523            /* Allocate space for the new message - always do maximum message size */
   1524            psNewMessage = malloc( sizeof(AntApplicationMsgListType) );
   \   0000001C   0x201C             MOVS     R0,#+28
   \   0000001E   0x.... 0x....      BL       malloc
   \   00000022   0x0007             MOVS     R7,R0
   1525            if (psNewMessage == NULL)
   \   00000024   0x2F00             CMP      R7,#+0
   \   00000026   0xD104             BNE.N    ??AntQueueExtendedApplicationMessage_0
   1526            {
   1527              DebugPrintf(Ant_au8AddMessageFailMsg);
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       DebugPrintf
   1528              return(FALSE);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE04B             B.N      ??AntQueueExtendedApplicationMessage_1
   1529            }
   1530            
   1531            /* Fill in all the fields of the newly allocated message structure */
   1532            for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \                     ??AntQueueExtendedApplicationMessage_0: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \                     ??AntQueueExtendedApplicationMessage_2: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2808             CMP      R0,#+8
   \   00000038   0xDA06             BGE.N    ??AntQueueExtendedApplicationMessage_3
   1533            {
   1534              psNewMessage->au8MessageData[i] = *(pu8DataSource_ + i);
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0x5D41             LDRB     R1,[R0, R5]
   \   0000003E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000040   0x19C2             ADDS     R2,R0,R7
   \   00000042   0x7191             STRB     R1,[R2, #+6]
   1535            }
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0xE7F5             B.N      ??AntQueueExtendedApplicationMessage_2
   1536            
   1537            /* Fill basic items */
   1538            psNewMessage->u32TimeStamp  = G_u32SystemTime1ms;
   \                     ??AntQueueExtendedApplicationMessage_3: (+1)
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable21_23
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x6038             STR      R0,[R7, #+0]
   1539            psNewMessage->eMessageType  = eMessageType_;
   \   00000050   0x713C             STRB     R4,[R7, #+4]
   1540            
   1541            /* Copy all extended data fields */
   1542            psNewMessage->sExtendedData.u8Channel    = psExtData_->u8Channel;
   \   00000052   0x7830             LDRB     R0,[R6, #+0]
   \   00000054   0x73B8             STRB     R0,[R7, #+14]
   1543            psNewMessage->sExtendedData.u16DeviceID  = psExtData_->u16DeviceID;
   \   00000056   0x8870             LDRH     R0,[R6, #+2]
   \   00000058   0x8238             STRH     R0,[R7, #+16]
   1544            psNewMessage->sExtendedData.u8DeviceType = psExtData_->u8DeviceType;
   \   0000005A   0x7930             LDRB     R0,[R6, #+4]
   \   0000005C   0x74B8             STRB     R0,[R7, #+18]
   1545            psNewMessage->sExtendedData.u8TransType  = psExtData_->u8TransType;
   \   0000005E   0x7970             LDRB     R0,[R6, #+5]
   \   00000060   0x74F8             STRB     R0,[R7, #+19]
   1546            psNewMessage->sExtendedData.u8Flags      = psExtData_->u8Flags;
   \   00000062   0x7870             LDRB     R0,[R6, #+1]
   \   00000064   0x73F8             STRB     R0,[R7, #+15]
   1547            psNewMessage->sExtendedData.s8RSSI       = psExtData_->s8RSSI;
   \   00000066   0x79B0             LDRB     R0,[R6, #+6]
   \   00000068   0x7538             STRB     R0,[R7, #+20]
   1548              
   1549            psNewMessage->psNextMessage = NULL;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x61B8             STR      R0,[R7, #+24]
   1550          
   1551            /* Insert into an empty list */
   1552            if(G_psAntApplicationMsgList == NULL)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD108             BNE.N    ??AntQueueExtendedApplicationMessage_4
   1553            {
   1554              G_psAntApplicationMsgList = psNewMessage;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   0000007C   0x6007             STR      R7,[R0, #+0]
   1555              Ant_u32ApplicationMessageCount++;
   \   0000007E   0x....             LDR.N    R0,??DataTable15
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x1C40             ADDS     R0,R0,#+1
   \   00000084   0x....             LDR.N    R1,??DataTable15
   \   00000086   0x6008             STR      R0,[R1, #+0]
   \   00000088   0xE01E             B.N      ??AntQueueExtendedApplicationMessage_5
   1556            }
   1557          
   1558            /* Otherwise traverse the list to find the end where the new message will be inserted */
   1559            else
   1560            {
   1561              psListParser = G_psAntApplicationMsgList;
   \                     ??AntQueueExtendedApplicationMessage_4: (+1)
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable21_24
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x4680             MOV      R8,R0
   1562              while(psListParser->psNextMessage != NULL) 
   \                     ??AntQueueExtendedApplicationMessage_6: (+1)
   \   00000092   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD004             BEQ.N    ??AntQueueExtendedApplicationMessage_7
   1563              {
   1564                psListParser = psListParser->psNextMessage;
   \   0000009A   0xF8D8 0x8018      LDR      R8,[R8, #+24]
   1565                u8MessageCount++;
   \   0000009E   0xF119 0x0901      ADDS     R9,R9,#+1
   \   000000A2   0xE7F6             B.N      ??AntQueueExtendedApplicationMessage_6
   1566              }
   1567              
   1568              /* Check for full list */
   1569              if(u8MessageCount < ANT_APPLICATION_MESSAGE_BUFFER_SIZE)
   \                     ??AntQueueExtendedApplicationMessage_7: (+1)
   \   000000A4   0xFA5F 0xF989      UXTB     R9,R9            ;; ZeroExt  R9,R9,#+24,#+24
   \   000000A8   0xF1B9 0x0F20      CMP      R9,#+32
   \   000000AC   0xD207             BCS.N    ??AntQueueExtendedApplicationMessage_8
   1570              {
   1571                /* Insert the new message at the end of the list */
   1572                psListParser->psNextMessage = psNewMessage;
   \   000000AE   0xF8C8 0x7018      STR      R7,[R8, #+24]
   1573                Ant_u32ApplicationMessageCount++;
   \   000000B2   0x....             LDR.N    R0,??DataTable15
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x1C40             ADDS     R0,R0,#+1
   \   000000B8   0x....             LDR.N    R1,??DataTable15
   \   000000BA   0x6008             STR      R0,[R1, #+0]
   \   000000BC   0xE004             B.N      ??AntQueueExtendedApplicationMessage_5
   1574              }
   1575              /* Handle a full list */
   1576              else
   1577              {
   1578                DebugPrintf(Ant_au8AddMessageFailMsg);
   \                     ??AntQueueExtendedApplicationMessage_8: (+1)
   \   000000BE   0xA800             ADD      R0,SP,#+0
   \   000000C0   0x.... 0x....      BL       DebugPrintf
   1579                return(FALSE);
   \   000000C4   0x2000             MOVS     R0,#+0
   \   000000C6   0xE000             B.N      ??AntQueueExtendedApplicationMessage_1
   1580              }
   1581            }
   1582              
   1583            return(TRUE);
   \                     ??AntQueueExtendedApplicationMessage_5: (+1)
   \   000000C8   0x2001             MOVS     R0,#+1
   \                     ??AntQueueExtendedApplicationMessage_1: (+1)
   \   000000CA   0xB00B             ADD      SP,SP,#+44
   \   000000CC   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
   1584              
   1585          } /* end AntQueueExtendedApplicationMessage() */
   1586          
   1587          
   1588          /*!-----------------------------------------------------------------------------/
   1589          @fn static void AntTickExtended(u8* pu8AntMessage_)
   1590          
   1591          @brief Queues an ANT_TICK message to the application message queue.
   1592          
   1593          This is expected to run for a Channel Event ANT message though it will work
   1594          for a standard Channel Response (although the names of the indexes will not
   1595          be quite right).  Currently this function is only called for Channel Events,
   1596          so if that changes it should be thought about carefully.
   1597          
   1598          Requires:
   1599          @param pu8AntMessage_ points to an ANT message that starts with the LENGTH 
   1600          (i.e. no SYNC byte) 
   1601          
   1602          Promises:
   1603          - A MESSAGE_ANT_TICK is queued to G_psAntApplicationMsgList
   1604          
   1605          */

   \                                 In section .text, align 2, keep-with-next
   1606          static void AntTickExtended(u8* pu8AntMessage_)
   1607          {
   \                     AntTickExtended: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1608            u8 au8Message[ANT_APPLICATION_MESSAGE_BYTES];
   1609            AntExtendedDataType sExtData;
   1610          
   1611            /* Update data to communicate the ANT_TICK to the application */
   1612            au8Message[ANT_TICK_MSG_ID_INDEX]               = MESSAGE_ANT_TICK;
   \   00000004   0x20FF             MOVS     R0,#+255
   \   00000006   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1613            au8Message[ANT_TICK_MSG_CHANNEL_INDEX]          = *(pu8AntMessage_ + BUFFER_INDEX_CHANNEL_NUM);
   \   0000000A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000C   0xF88D 0x0001      STRB     R0,[SP, #+1]
   1614            au8Message[ANT_TICK_MSG_RESPONSE_TYPE_INDEX]    = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_MESG_ID);
   \   00000010   0x78E0             LDRB     R0,[R4, #+3]
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
   1615            au8Message[ANT_TICK_MSG_EVENT_CODE_INDEX]       = *(pu8AntMessage_ + BUFFER_INDEX_RESPONSE_CODE);
   \   00000016   0x7920             LDRB     R0,[R4, #+4]
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
   1616            au8Message[ANT_TICK_MSG_SENTINEL_INDEX]         = MESSAGE_ANT_TICK_SENTINEL;
   \   0000001C   0x20FF             MOVS     R0,#+255
   \   0000001E   0xF88D 0x0004      STRB     R0,[SP, #+4]
   1617            au8Message[ANT_TICK_MSG_MISSED_HIGH_BYTE_INDEX] = Ant_u8SlaveMissedMessageHigh;
   \   00000022   0x....             LDR.N    R0,??DataTable21_18
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xF88D 0x0005      STRB     R0,[SP, #+5]
   1618            au8Message[ANT_TICK_MSG_MISSED_MID_BYTE_INDEX]  = Ant_u8SlaveMissedMessageMid;
   \   0000002A   0x....             LDR.N    R0,??DataTable21_17
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xF88D 0x0006      STRB     R0,[SP, #+6]
   1619            au8Message[ANT_TICK_MSG_MISSED_LOW_BYTE_INDEX]  = Ant_u8SlaveMissedMessageLow;
   \   00000032   0x....             LDR.N    R0,??DataTable21_16
   \   00000034   0x7800             LDRB     R0,[R0, #+0]
   \   00000036   0xF88D 0x0007      STRB     R0,[SP, #+7]
   1620          
   1621            /* Extended data is not valid for an ANT_TICK message */
   1622            sExtData.u8Channel    = au8Message[ANT_TICK_MSG_CHANNEL_INDEX];
   \   0000003A   0xF89D 0x0001      LDRB     R0,[SP, #+1]
   \   0000003E   0xF88D 0x0008      STRB     R0,[SP, #+8]
   1623            sExtData.u16DeviceID  = 0xFF;
   \   00000042   0x20FF             MOVS     R0,#+255
   \   00000044   0xF8AD 0x000A      STRH     R0,[SP, #+10]
   1624            sExtData.u8DeviceType = 0xFF;
   \   00000048   0x20FF             MOVS     R0,#+255
   \   0000004A   0xF88D 0x000C      STRB     R0,[SP, #+12]
   1625            sExtData.u8TransType  = 0xFF;
   \   0000004E   0x20FF             MOVS     R0,#+255
   \   00000050   0xF88D 0x000D      STRB     R0,[SP, #+13]
   1626            sExtData.s8RSSI       = 0xFF;
   \   00000054   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000058   0xF88D 0x000E      STRB     R0,[SP, #+14]
   1627            sExtData.u8Flags      = 0xFF;
   \   0000005C   0x20FF             MOVS     R0,#+255
   \   0000005E   0xF88D 0x0009      STRB     R0,[SP, #+9]
   1628            
   1629            /* Data is ready so queue it in to the application buffer */
   1630            AntQueueExtendedApplicationMessage(ANT_TICK, 
   1631                                               &au8Message[ANT_TICK_MSG_ID_INDEX],
   1632                                               &sExtData);
   \   00000062   0xAA02             ADD      R2,SP,#+8
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0x2002             MOVS     R0,#+2
   \   00000068   0x.... 0x....      BL       AntQueueExtendedApplicationMessage
   1633          
   1634          } /* end AntTickExtended() */
   \   0000006C   0xBD1F             POP      {R0-R4,PC}       ;; return
   1635          
   1636          
   1637          /*!-----------------------------------------------------------------------------/
   1638          @fn static void AntDeQueueOutgoingMessage(void)
   1639          
   1640          @brief Removes the oldest entry of Ant_psOutgoingMsgList.
   1641          
   1642          Requires:
   1643          - NONE 
   1644          
   1645          Promises:
   1646          - Ant_psOutgoingMsgList = Ant_psOutgoingMsgList->psNextMessage 
   1647            and the memory is freed
   1648          
   1649          */

   \                                 In section .text, align 2, keep-with-next
   1650          static void AntDeQueueOutgoingMessage(void)
   1651          {
   \                     AntDeQueueOutgoingMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1652            AntOutgoingMessageListType *psMessageToKill;
   1653            
   1654            if(Ant_psOutgoingMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable21_25
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD00A             BEQ.N    ??AntDeQueueOutgoingMessage_0
   1655            {
   1656              psMessageToKill = Ant_psOutgoingMsgList;
   \   0000000A   0x....             LDR.N    R0,??DataTable21_25
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x0004             MOVS     R4,R0
   1657              Ant_psOutgoingMsgList = Ant_psOutgoingMsgList->psNextMessage;
   \   00000010   0x....             LDR.N    R0,??DataTable21_25
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6980             LDR      R0,[R0, #+24]
   \   00000016   0x....             LDR.N    R1,??DataTable21_25
   \   00000018   0x6008             STR      R0,[R1, #+0]
   1658            
   1659              /* The doomed message is properly disconnected, so kill it */
   1660              free(psMessageToKill);
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       free
   1661            }
   1662            
   1663          } /* end AntDeQueueOutgoingMessage() */
   \                     ??AntDeQueueOutgoingMessage_0: (+1)
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   1664          
   1665          
   1666          /* ANT Private Serial-layer Functions */
   1667          
   1668          /*!--------------------------------------------------------------------------------------------------------------------
   1669          @fn static void AntSyncSerialInitialize(void)
   1670          
   1671          @brief Properly sets up the ANT SPI interface and tests Host <-> ANT communications.
   1672          
   1673          Requires:
   1674          - ANT_SPI is configured
   1675          - !CS (SEN) interrupt should be enabled
   1676          
   1677          Promises:
   1678          - Ant_pu8AntRxBufferNextChar is initialized to start of AntRxBuffer
   1679          - Ant_pu8AntRxBufferUnreadMsg is initialized to start of AntRxBuffer
   1680          - Message counter Ant_u8AntNewRxMessages reset to 0;
   1681          - If ANT starts up correctly and responds to version request, then 
   1682            G_u32SystemFlags _APPLICATION_FLAGS_ANT is set and Ant_u8AntVersion is populated
   1683            with the returned version information from the ANT IC.  
   1684          
   1685          */

   \                                 In section .text, align 2, keep-with-next
   1686          static void AntSyncSerialInitialize(void)
   1687          {
   \                     AntSyncSerialInitialize: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1688            u32 u32EventTimer;
   1689            bool bErrorStatus = FALSE;
   \   00000004   0x2400             MOVS     R4,#+0
   1690            
   1691            /* Initialize buffer pointers */  
   1692            Ant_pu8AntRxBufferNextChar    = Ant_au8AntRxBuffer;
   \   00000006   0x....             LDR.N    R0,??DataTable21_26
   \   00000008   0x....             LDR.N    R1,??DataTable21_27
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1693            Ant_pu8AntRxBufferCurrentChar = Ant_au8AntRxBuffer;
   \   0000000C   0x....             LDR.N    R0,??DataTable21_26
   \   0000000E   0x....             LDR.N    R1,??DataTable21
   \   00000010   0x6008             STR      R0,[R1, #+0]
   1694            Ant_pu8AntRxBufferUnreadMsg   = Ant_au8AntRxBuffer;
   \   00000012   0x....             LDR.N    R0,??DataTable21_26
   \   00000014   0x....             LDR.N    R1,??DataTable21_4
   \   00000016   0x6008             STR      R0,[R1, #+0]
   1695            Ant_u8AntNewRxMessages = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x....             LDR.N    R1,??DataTable21_2
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   1696           
   1697            /* Reset the 51422 and initialize SRDY and MRDY */
   1698            u32EventTimer = G_u32SystemTime1ms;
   \   0000001E   0x....             LDR.N    R0,??DataTable21_23
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x9000             STR      R0,[SP, #+0]
   1699            ANT_RESET_ASSERT();
   \   00000024   0xF45F 0x1000      MOVS     R0,#+2097152
   \   00000028   0x....             LDR.N    R1,??DataTable20  ;; 0x400e0e34
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1700            SYNC_MRDY_DEASSERT();
   \   0000002C   0xF45F 0x0000      MOVS     R0,#+8388608
   \   00000030   0x....             LDR.N    R1,??DataTable20_1  ;; 0x400e0e30
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1701            SYNC_SRDY_DEASSERT();
   \   00000034   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000038   0x....             LDR.N    R1,??DataTable20_1  ;; 0x400e0e30
   \   0000003A   0x6008             STR      R0,[R1, #+0]
   1702            while( !IsTimeUp(&u32EventTimer, ANT_RESET_WAIT_MS) );
   \                     ??AntSyncSerialInitialize_0: (+1)
   \   0000003C   0x2164             MOVS     R1,#+100
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       IsTimeUp
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD0F9             BEQ.N    ??AntSyncSerialInitialize_0
   1703            ANT_RESET_DEASSERT();
   \   00000048   0xF45F 0x1000      MOVS     R0,#+2097152
   \   0000004C   0x....             LDR.N    R1,??DataTable20_1  ;; 0x400e0e30
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   1704            u32EventTimer = G_u32SystemTime1ms;
   \   00000050   0x....             LDR.N    R0,??DataTable21_23
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x9000             STR      R0,[SP, #+0]
   1705            while( !IsTimeUp(&u32EventTimer, ANT_RESTART_DELAY_MS) );
   \                     ??AntSyncSerialInitialize_1: (+1)
   \   00000056   0xF44F 0x717A      MOV      R1,#+1000
   \   0000005A   0xA800             ADD      R0,SP,#+0
   \   0000005C   0x.... 0x....      BL       IsTimeUp
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD0F8             BEQ.N    ??AntSyncSerialInitialize_1
   1706          
   1707            
   1708            /* ANT should want to send message 0x6F now to indicate it has reset */
   1709            u32EventTimer = G_u32SystemTime1ms;
   \   00000064   0x....             LDR.N    R0,??DataTable21_23
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x9000             STR      R0,[SP, #+0]
   1710            while( !IS_SEN_ASSERTED() && !bErrorStatus )
   \                     ??AntSyncSerialInitialize_2: (+1)
   \   0000006A   0x....             LDR.N    R0,??DataTable18
   \   0000006C   0x6800             LDR      R0,[R0, #+0]
   \   0000006E   0x07C0             LSLS     R0,R0,#+31
   \   00000070   0xD409             BMI.N    ??AntSyncSerialInitialize_3
   \   00000072   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD106             BNE.N    ??AntSyncSerialInitialize_3
   1711            {
   1712              bErrorStatus = IsTimeUp(&u32EventTimer, ANT_MSG_TIMEOUT_MS);
   \   00000078   0xF44F 0x717A      MOV      R1,#+1000
   \   0000007C   0xA800             ADD      R0,SP,#+0
   \   0000007E   0x.... 0x....      BL       IsTimeUp
   \   00000082   0x0004             MOVS     R4,R0
   \   00000084   0xE7F1             B.N      ??AntSyncSerialInitialize_2
   1713            }
   1714          
   1715            /* SEN is asserted if bErrorStatus is FALSE */
   1716            if (!bErrorStatus)
   \                     ??AntSyncSerialInitialize_3: (+1)
   \   00000086   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000088   0x2C00             CMP      R4,#+0
   \   0000008A   0xD110             BNE.N    ??AntSyncSerialInitialize_4
   1717            {
   1718              /* Receive and process what should be the restart message */
   1719              AntRxMessage();
   \   0000008C   0x.... 0x....      BL       AntRxMessage
   1720              AntProcessMessage();   
   \   00000090   0x.... 0x....      BL       AntProcessMessage
   1721          
   1722              /* Send out version request message and expect response */
   1723              G_au8ANTGetVersion[4] = AntCalculateTxChecksum(&G_au8ANTGetVersion[0]);
   \   00000094   0x....             LDR.N    R0,??DataTable21_28
   \   00000096   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000009A   0x....             LDR.N    R1,??DataTable21_28
   \   0000009C   0x7108             STRB     R0,[R1, #+4]
   1724              AntTxMessage(&G_au8ANTGetVersion[0]);   
   \   0000009E   0x....             LDR.N    R0,??DataTable21_28
   \   000000A0   0x.... 0x....      BL       AntTxMessage
   1725              
   1726              /* Process the message through AntExpectResponse */
   1727              AntExpectResponse(MESG_VERSION_ID, ANT_MSG_TIMEOUT_MS);
   \   000000A4   0xF44F 0x717A      MOV      R1,#+1000
   \   000000A8   0x203E             MOVS     R0,#+62
   \   000000AA   0x.... 0x....      BL       AntExpectResponse
   1728            }
   1729            
   1730            if(bErrorStatus)
   \                     ??AntSyncSerialInitialize_4: (+1)
   \   000000AE   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   000000B0   0x2C00             CMP      R4,#+0
   \   000000B2   0xD002             BEQ.N    ??AntSyncSerialInitialize_5
   1731            {
   1732              DebugPrintf("ANT failed boot\n\r");
   \   000000B4   0x....             LDR.N    R0,??DataTable21_29
   \   000000B6   0x.... 0x....      BL       DebugPrintf
   1733            }
   1734           
   1735          } /* end AntSyncSerialInitialize */
   \                     ??AntSyncSerialInitialize_5: (+1)
   \   000000BA   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   1736          
   1737          
   1738          /*!-----------------------------------------------------------------------------
   1739          @fn static void AntSrdyPulse(void)
   1740          
   1741          @brief Pulses Srdy with added delays on the front and middle. 
   1742          
   1743          1. A delay controlled by ANT_SRDY_DELAY is passed
   1744          2. SRDY is asserted
   1745          3. A delay of ANT_SRDY_PERIOD is passed
   1746          4. SRDY is deasserted
   1747          
   1748          Requires:
   1749          - NONE 
   1750          
   1751          Promises:
   1752          - SRDY pulsed and ends deasserted
   1753          
   1754          */

   \                                 In section .text, align 2, keep-with-next
   1755          static void AntSrdyPulse(void)
   1756          {
   1757            for(u32 i = 0; i < ANT_SRDY_DELAY; i++);
   \                     AntSrdyPulse: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_0: (+1)
   \   00000002   0x28C8             CMP      R0,#+200
   \   00000004   0xD201             BCS.N    ??AntSrdyPulse_1
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0xE7FB             B.N      ??AntSrdyPulse_0
   1758            SYNC_SRDY_ASSERT();
   \                     ??AntSrdyPulse_1: (+1)
   \   0000000A   0xF05F 0x7080      MOVS     R0,#+16777216
   \   0000000E   0x....             LDR.N    R1,??DataTable20  ;; 0x400e0e34
   \   00000010   0x6008             STR      R0,[R1, #+0]
   1759            
   1760            for(u32 i = 0; i < ANT_SRDY_PERIOD; i++);
   \   00000012   0x2000             MOVS     R0,#+0
   \                     ??AntSrdyPulse_2: (+1)
   \   00000014   0x2814             CMP      R0,#+20
   \   00000016   0xD201             BCS.N    ??AntSrdyPulse_3
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0xE7FB             B.N      ??AntSrdyPulse_2
   1761            SYNC_SRDY_DEASSERT();
   \                     ??AntSrdyPulse_3: (+1)
   \   0000001C   0xF05F 0x7080      MOVS     R0,#+16777216
   \   00000020   0x....             LDR.N    R1,??DataTable20_1  ;; 0x400e0e30
   \   00000022   0x6008             STR      R0,[R1, #+0]
   1762          
   1763          } /* end AntSrdyPulse() */
   \   00000024   0x4770             BX       LR               ;; return
   1764          
   1765          
   1766          /***********************************************************************************************************************
   1767          ##### ANT State Machine Definition                                             
   1768          ***********************************************************************************************************************/
   1769          
   1770          /*!------------------------------------------------------------------------------
   1771          @fn static void AntSM_Idle(void)
   1772          
   1773          @brief Idle state that will process new messages if any are present, monitors ANT
   1774          for incoming messages, and sends broadcast messages that are waiting to be sent.
   1775          Incoming messages from ANT always get priority.  
   1776          */

   \                                 In section .text, align 2, keep-with-next
   1777          static void AntSM_Idle(void)
   1778          {
   \                     AntSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1779            u32 u32MsgBitMask = 0x01;
   \   00000002   0x2401             MOVS     R4,#+1
   1780            u8 u8MsgIndex = 0;
   \   00000004   0x2500             MOVS     R5,#+0
   1781            static u8 au8AntFlagAlert[] = "ANT flags:\n\r"; 
   1782            
   1783            /* Error messages: must match order of G_u32AntFlags Error / event flags */
   1784            static u8 au8AntFlagMessages[][20] = 
   1785            {/* "012345678901234567\n\r" */
   1786                "Length mismatch\n\r",
   1787                "Command error\n\r",
   1788                "Unexpected event\n\r",
   1789                "Unexpected message\n\r"
   1790            };
   1791            
   1792            /* Check flags */
   1793            if(G_u32AntFlags & ANT_ERROR_FLAGS_MASK)
   \   00000006   0x....             LDR.N    R0,??DataTable21_7
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0400             LSLS     R0,R0,#+16
   \   0000000C   0xD01B             BEQ.N    ??AntSM_Idle_0
   1794            {
   1795              /* At least one flag is set, so print header and parse out */
   1796              DebugPrintf(au8AntFlagAlert);
   \   0000000E   0x....             LDR.N    R0,??DataTable21_30
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1797              for(u8 i = 0; i < ANT_ERROR_FLAGS_COUNT; i++)
   \   00000014   0x2600             MOVS     R6,#+0
   \                     ??AntSM_Idle_1: (+1)
   \   00000016   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000018   0x2E04             CMP      R6,#+4
   \   0000001A   0xDA0E             BGE.N    ??AntSM_Idle_2
   1798              {
   1799                /* Check if current flag is set */
   1800                if(G_u32AntFlags & u32MsgBitMask)
   \   0000001C   0x....             LDR.N    R0,??DataTable21_7
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4220             TST      R0,R4
   \   00000022   0xD006             BEQ.N    ??AntSM_Idle_3
   1801                {
   1802                  /* Print the error message */
   1803                  DebugPrintf(au8AntFlagMessages[u8MsgIndex]);
   \   00000024   0x....             LDR.N    R0,??DataTable21_31
   \   00000026   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000028   0x2114             MOVS     R1,#+20
   \   0000002A   0xFB01 0x0005      MLA      R0,R1,R5,R0
   \   0000002E   0x.... 0x....      BL       DebugPrintf
   1804                }
   1805                u32MsgBitMask <<= 1;
   \                     ??AntSM_Idle_3: (+1)
   \   00000032   0x0064             LSLS     R4,R4,#+1
   1806                u8MsgIndex++;
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   1807              }
   \   00000036   0x1C76             ADDS     R6,R6,#+1
   \   00000038   0xE7ED             B.N      ??AntSM_Idle_1
   1808              
   1809              /* Clear all the error flags now that they have been reported */
   1810              G_u32AntFlags &= ~ANT_ERROR_FLAGS_MASK;
   \                     ??AntSM_Idle_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable21_7
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x0C00             LSRS     R0,R0,#+16
   \   00000040   0x0400             LSLS     R0,R0,#+16
   \   00000042   0x....             LDR.N    R1,??DataTable21_7
   \   00000044   0x6008             STR      R0,[R1, #+0]
   1811            }
   1812            
   1813            /* Process messages received from ANT */
   1814            AntProcessMessage();
   \                     ??AntSM_Idle_0: (+1)
   \   00000046   0x.... 0x....      BL       AntProcessMessage
   1815          
   1816            /* Handle messages coming in from ANT */
   1817            if( IS_SEN_ASSERTED() )
   \   0000004A   0x....             LDR.N    R0,??DataTable21_32
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x07C0             LSLS     R0,R0,#+31
   \   00000050   0xD504             BPL.N    ??AntSM_Idle_4
   1818            {
   1819              Ant_pfnStateMachine = AntSM_ReceiveMessage;
   \   00000052   0x.... 0x....      ADR.W    R0,AntSM_ReceiveMessage
   \   00000056   0x....             LDR.N    R1,??DataTable21_33
   \   00000058   0x6008             STR      R0,[R1, #+0]
   \   0000005A   0xE01A             B.N      ??AntSM_Idle_5
   1820            }
   1821            
   1822            /* Send a message if the system is ready and there is one to send */ 
   1823            else if( (Ant_u32CurrentTxMessageToken == 0 ) && 
   1824                     (Ant_psOutgoingMsgList != NULL) )
   \                     ??AntSM_Idle_4: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable21_1
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD116             BNE.N    ??AntSM_Idle_5
   \   00000064   0x....             LDR.N    R0,??DataTable21_25
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD012             BEQ.N    ??AntSM_Idle_5
   1825            {
   1826              /* Give the message to AntTx which will set Ant_u32CurrentTxMessageToken */
   1827              if(AntTxMessage(Ant_psOutgoingMsgList->au8MessageData))
   \   0000006C   0x....             LDR.N    R0,??DataTable21_25
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x1D00             ADDS     R0,R0,#+4
   \   00000072   0x.... 0x....      BL       AntTxMessage
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD008             BEQ.N    ??AntSM_Idle_6
   1828              {
   1829                Ant_u32TxTimer = G_u32SystemTime1ms;
   \   0000007A   0x....             LDR.N    R0,??DataTable21_23
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x....             LDR.N    R1,??DataTable21_34
   \   00000080   0x6008             STR      R0,[R1, #+0]
   1830                Ant_pfnStateMachine = AntSM_TransmitMessage;
   \   00000082   0x.... 0x....      ADR.W    R0,AntSM_TransmitMessage
   \   00000086   0x....             LDR.N    R1,??DataTable21_33
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE002             B.N      ??AntSM_Idle_5
   1831              }
   1832              else
   1833              {
   1834                /* Transmit attempt failed.  !!!! Do something? */
   1835                DebugPrintf("\n\rANT transmit failed\n\r");
   \                     ??AntSM_Idle_6: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable21_35
   \   0000008E   0x.... 0x....      BL       DebugPrintf
   1836              }
   1837            }
   1838            
   1839          } /* end AntSM_Idle() */
   \                     ??AntSM_Idle_5: (+1)
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8AntFlagAlert:
   \   00000000   0x41 0x4E          DC8 "ANT flags:\012\015"
   \              0x54 0x20    
   \              0x66 0x6C    
   \              0x61 0x67    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8AntFlagMessages:
   \   00000000   0x4C 0x65          DC8 "Length mismatch\012\015"
   \              0x6E 0x67    
   \              0x74 0x68    
   \              0x20 0x6D    
   \              0x69 0x73    
   \              0x6D 0x61    
   \              0x74 0x63    
   \              0x68 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
   \   00000014   0x43 0x6F          DC8 "Command error\012\015"
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x0A    
   \              0x0D 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000028   0x55 0x6E          DC8 "Unexpected event\012\015"
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000003B   0x00               DC8 0
   \   0000003C   0x55 0x6E          DC8 55H, 6EH, 65H, 78H, 70H, 65H, 63H, 74H
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \   00000044   0x65 0x64          DC8 65H, 64H, 20H, 6DH, 65H, 73H, 73H, 61H
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \   0000004C   0x67 0x65          DC8 67H, 65H, 0AH, 0DH
   \              0x0A 0x0D    
   1840          
   1841          
   1842          /*!------------------------------------------------------------------------------
   1843          @fn static void AntSM_ReceiveMessage(void)
   1844          
   1845          @brief Completely receive an ANT message. Reception is very fast and should complete 
   1846          in less than 600us for a 15-byte message.  AntRxMessage could just be called from Idle,
   1847          but giving it its own state minimizes the total time and allows for easier future
   1848          updates should they be required.
   1849          */

   \                                 In section .text, align 4, keep-with-next
   1850          static void AntSM_ReceiveMessage(void)
   1851          {
   \                     AntSM_ReceiveMessage: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1852            Ant_DebugRxMessageCounter++;
   \   00000002   0x....             LDR.N    R0,??DataTable21_36
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable21_36
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1853            AntRxMessage();
   \   0000000C   0x.... 0x....      BL       AntRxMessage
   1854            
   1855            Ant_pfnStateMachine = AntSM_Idle;
   \   00000010   0x....             LDR.N    R0,??DataTable21_37
   \   00000012   0x....             LDR.N    R1,??DataTable21_33
   \   00000014   0x6008             STR      R0,[R1, #+0]
   1856          
   1857          } /* end AntSM_ReceiveMessage() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1858          
   1859          
   1860          /*!------------------------------------------------------------------------------
   1861          @fn static void AntSM_TransmitMessage(void)
   1862          
   1863          @brief Wait for an ANT message to be transmitted.  This state only occurs once the 
   1864          handshaking transaction has been completed and transmit to ANT is verified and underway.
   1865          */

   \                                 In section .text, align 4, keep-with-next
   1866          static void AntSM_TransmitMessage(void)
   1867          {
   \                     AntSM_TransmitMessage: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1868            MessageStateType eCurrentMsgStatus;
   1869            
   1870            eCurrentMsgStatus = QueryMessageStatus(Ant_u32CurrentTxMessageToken);
   \   00000002   0x....             LDR.N    R0,??DataTable21_1
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      BL       QueryMessageStatus
   \   0000000A   0x0004             MOVS     R4,R0
   1871            switch(eCurrentMsgStatus)
   \   0000000C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x2803             CMP      R0,#+3
   \   00000012   0xD004             BEQ.N    ??AntSM_TransmitMessage_0
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD12E             BNE.N    ??AntSM_TransmitMessage_1
   1872            {
   1873              case TIMEOUT:
   1874              {
   1875                 DebugPrintf("\n\rTransmit message timeout\n\r");
   \                     ??AntSM_TransmitMessage_2: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable21_38
   \   0000001A   0x.... 0x....      BL       DebugPrintf
   1876                /* Fall through */
   1877              }
   1878              
   1879              case COMPLETE:
   1880              {
   1881                /* Kill the message and update flags */
   1882                AntDeQueueOutgoingMessage();
   \                     ??AntSM_TransmitMessage_0: (+1)
   \   0000001E   0x.... 0x....      BL       AntDeQueueOutgoingMessage
   1883                Ant_u32CurrentTxMessageToken = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x....             LDR.N    R1,??DataTable21_1
   \   00000026   0x6008             STR      R0,[R1, #+0]
   1884                G_u32AntFlags &= ~_ANT_FLAGS_TX_IN_PROGRESS;
   \   00000028   0x....             LDR.N    R0,??DataTable21_7
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF030 0x7000      BICS     R0,R0,#0x2000000
   \   00000030   0x....             LDR.N    R1,??DataTable21_7
   \   00000032   0x6008             STR      R0,[R1, #+0]
   1885          
   1886                /* Wait for SEN to deassert so we know ANT is totally ready for the next
   1887                transaction.  This takes about 170us, so block in this state until that's over */
   1888                while ( IS_SEN_ASSERTED() && (Ant_u32TxTimer < ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntSM_TransmitMessage_3: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable21_32
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x07C0             LSLS     R0,R0,#+31
   \   0000003A   0xD50B             BPL.N    ??AntSM_TransmitMessage_4
   \   0000003C   0x....             LDR.N    R0,??DataTable21_34
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0xF242 0x7110      MOVW     R1,#+10000
   \   00000044   0x4288             CMP      R0,R1
   \   00000046   0xD205             BCS.N    ??AntSM_TransmitMessage_4
   1889                {
   1890                  Ant_u32TxTimer++;
   \   00000048   0x....             LDR.N    R0,??DataTable21_34
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable21_34
   \   00000050   0x6008             STR      R0,[R1, #+0]
   \   00000052   0xE7EF             B.N      ??AntSM_TransmitMessage_3
   1891                }
   1892          
   1893                /* If we timed out, then ANT is likely stuck */
   1894                if(Ant_u32RxTimer > ANT_ACTIVITY_TIME_COUNT)
   \                     ??AntSM_TransmitMessage_4: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable21_39
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0xF242 0x7111      MOVW     R1,#+10001
   \   0000005C   0x4288             CMP      R0,R1
   \   0000005E   0xD306             BCC.N    ??AntSM_TransmitMessage_5
   1895                {
   1896                  /* Try to unstick ANT !!!! Should have a timeout for this */
   1897                  while( IS_SEN_ASSERTED() )
   \                     ??AntSM_TransmitMessage_6: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable21_32
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x07C0             LSLS     R0,R0,#+31
   \   00000066   0xD502             BPL.N    ??AntSM_TransmitMessage_5
   1898                  {
   1899                    AntSrdyPulse();
   \   00000068   0x.... 0x....      BL       AntSrdyPulse
   \   0000006C   0xE7F8             B.N      ??AntSM_TransmitMessage_6
   1900                  }
   1901                }
   1902                
   1903                Ant_pfnStateMachine = AntSM_Idle;
   \                     ??AntSM_TransmitMessage_5: (+1)
   \   0000006E   0x....             LDR.N    R0,??DataTable21_37
   \   00000070   0x....             LDR.N    R1,??DataTable21_33
   \   00000072   0x6008             STR      R0,[R1, #+0]
   1904                break;
   \   00000074   0xE7FF             B.N      ??AntSM_TransmitMessage_7
   1905              }
   1906              
   1907              default:
   1908              {
   1909                /* Do nothing for now */
   1910                break;
   1911              }  
   1912            } /* end switch */
   1913            
   1914          } /* end AntSM_TransmitMessage() */
   \                     ??AntSM_TransmitMessage_1: (+1)
   \                     ??AntSM_TransmitMessage_7: (+1)
   \   00000076   0xBD10             POP      {R4,PC}          ;; return
   1915          
   1916          
   1917          /*!------------------------------------------------------------------------------
   1918          @fn static void AntSM_NoResponse(void)
   1919          
   1920          @brief Do-nothing state if ANT is dead (requires restart to retry initialization)
   1921          */

   \                                 In section .text, align 2, keep-with-next
   1922          static void AntSM_NoResponse(void)
   1923          {
   1924            
   1925          } /* end AntSM_NoResponse() */
   \                     AntSM_NoResponse: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     Ant_DebugQueuedDataMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     Ant_psOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     Ant_u32OutgoingMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     G_psAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x400E0E3C         DC32     0x400e0e3c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     G_au8AntMessageNoAnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x400E0C00         DC32     0x400e0c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x400E0E00         DC32     0x400e0e00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x400E0C14         DC32     0x400e0c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x400E0E14         DC32     0x400e0e14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x400E0E10         DC32     0x400e0e10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     Ant_au8AddMessageFailMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     AntSM_NoResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x........         DC32     G_au8AntMessageInit

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     Ant_sSspConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     Ant_u32ApplicationMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     Ant_Ssp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     G_au8AntMessageInitFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     Ant_u32RxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer+0x100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     Ant_u8AntVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x........         DC32     Ant_u32TxByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x400E0E34         DC32     0x400e0e34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x400E0E30         DC32     0x400e0e30

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferCurrentChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     Ant_u32CurrentTxMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     Ant_u8AntNewRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     Ant_DebugTotalRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferUnreadMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x........         DC32     Ant_u32RxTimeoutCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x........         DC32     Ant_u32UnexpectedByteCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x........         DC32     G_u32AntFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x........         DC32     Ant_DebugProcessRxMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x........         DC32     G_stAntMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_11:
   \   00000000   0x........         DC32     G_au8AntMessageOpen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_12:
   \   00000000   0x........         DC32     G_au8AntMessageClose

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_13:
   \   00000000   0x........         DC32     G_au8AntMessageUnassign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_14:
   \   00000000   0x........         DC32     G_au8AntMessageUnhandled

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_15:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_16:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageLow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_17:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageMid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_18:
   \   00000000   0x........         DC32     Ant_u8SlaveMissedMessageHigh

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_19:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_20:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_21:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_22:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_23:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_24:
   \   00000000   0x........         DC32     G_psAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_25:
   \   00000000   0x........         DC32     Ant_psOutgoingMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_26:
   \   00000000   0x........         DC32     Ant_au8AntRxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_27:
   \   00000000   0x........         DC32     Ant_pu8AntRxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_28:
   \   00000000   0x........         DC32     G_au8ANTGetVersion

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_29:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_30:
   \   00000000   0x........         DC32     ??au8AntFlagAlert

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_31:
   \   00000000   0x........         DC32     ??au8AntFlagMessages

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_32:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_33:
   \   00000000   0x........         DC32     Ant_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_34:
   \   00000000   0x........         DC32     Ant_u32TxTimer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_35:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_36:
   \   00000000   0x........         DC32     Ant_DebugRxMessageCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_37:
   \   00000000   0x........         DC32     AntSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_38:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_39:
   \   00000000   0x........         DC32     Ant_u32RxTimer

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x4E          DC8 "ANT version: "
   \              0x54 0x20    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x6E          DC8 "AntTx: msg already in progress\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x73 0x67    
   \              0x20 0x61    
   \              0x6C 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x6F 0x67    
   \              0x72 0x65    
   \              0x73 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x6E          DC8 "AntTx: SEN timeout\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x53    
   \              0x45 0x4E    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x6E          DC8 "AntTx: No token\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x74 0x6F    
   \              0x6B 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntTx: No SYNC\012\015"
   \              0x74 0x54    
   \              0x78 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x53 0x59    
   \              0x4E 0x43    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x6E          DC8 "AntRx: timeout\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x6E          DC8 "AntRx: message failed\012\015"
   \              0x74 0x52    
   \              0x78 0x3A    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x53 0x63          DC8 "Scanning "
   \              0x61 0x6E    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x43 0x68          DC8 "Channel closed\012\015"
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x63 0x6C    
   \              0x6F 0x73    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x3A 0x20          DC8 ": unexpected channel event\012\015"
   \              0x75 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x76 0x65    
   \              0x6E 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0A 0x0D          DC8 "\012\015Unexpected ANT message size\012\012\015"
   \              0x55 0x6E    
   \              0x65 0x78    
   \              0x70 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x20 0x41    
   \              0x4E 0x54    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x73    
   \              0x69 0x7A    
   \              0x65 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x0A 0x0D          DC8 "\012\015No space in AntQueueApplicationMessage\012\015"
   \              0x4E 0x6F    
   \              0x20 0x73    
   \              0x70 0x61    
   \              0x63 0x65    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x41 0x6E    
   \              0x74 0x51    
   \              0x75 0x65    
   \              0x75 0x65    
   \              0x41 0x70    
   \              0x70 0x6C    
   \              0x69 0x63    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x41 0x4E          DC8 "ANT failed boot\012\015"
   \              0x54 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x62    
   \              0x6F 0x6F    
   \              0x74 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x0A 0x0D          DC8 "\012\015ANT transmit failed\012\015"
   \              0x41 0x4E    
   \              0x54 0x20    
   \              0x74 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0A 0x0D          DC8 "\012\015Transmit message timeout\012\015"
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceAntRxBufferCurrentChar
       0   AdvanceAntRxBufferUnreadMsgPointer
       0   AntAbortMessage
       4   AntCalculateTxChecksum
       8   AntDeQueueApplicationMessage
         8   -> free
       8   AntDeQueueOutgoingMessage
         8   -> free
      24   AntExpectResponse
        24   -> AntDeQueueOutgoingMessage
        24   -> AntProcessMessage
        24   -> AntRxMessage
        24   -> IsTimeUp
       8   AntInitialize
         8   -> AntSyncSerialInitialize
         8   -> DebugLineFeed
         8   -> DebugPrintf
         8   -> SspRequest
      40   AntParseExtendedData
        40   -> DebugPrintf
      48   AntProcessMessage
        48   -> AdvanceAntRxBufferUnreadMsgPointer
        48   -> AntParseExtendedData
        48   -> AntQueueExtendedApplicationMessage
        48   -> AntTickExtended
        48   -> DebugPrintNumber
        48   -> DebugPrintf
        48   -> HexToASCIICharLower
      72   AntQueueExtendedApplicationMessage
        72   -> DebugPrintf
        72   -> __aeabi_memcpy
        72   -> malloc
      24   AntQueueOutgoingMessage
        24   -> DebugPrintf
        24   -> malloc
       8   AntRunActiveState
         8   -- Indirect call
       8   AntRxFlowControlCallback
         8   -> AntSrdyPulse
      64   AntRxMessage
        64   -> AdvanceAntRxBufferCurrentChar
        64   -> AdvanceAntRxBufferUnreadMsgPointer
        64   -> AntAbortMessage
        64   -> AntSrdyPulse
        64   -> DebugPrintf
        64   -> __aeabi_memcpy
        64   -> __aeabi_memcpy4
      16   AntSM_Idle
        16   -> AntProcessMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
       0   AntSM_NoResponse
       8   AntSM_ReceiveMessage
         8   -> AntRxMessage
       8   AntSM_TransmitMessage
         8   -> AntDeQueueOutgoingMessage
         8   -> AntSrdyPulse
         8   -> DebugPrintf
         8   -> QueryMessageStatus
       0   AntSrdyPulse
      16   AntSyncSerialInitialize
        16   -> AntCalculateTxChecksum
        16   -> AntExpectResponse
        16   -> AntProcessMessage
        16   -> AntRxMessage
        16   -> AntTxMessage
        16   -> DebugPrintf
        16   -> IsTimeUp
      24   AntTickExtended
        24   -> AntQueueExtendedApplicationMessage
       8   AntTxFlowControlCallback
         8   -> AntSrdyPulse
     120   AntTxMessage
       120   -> AdvanceAntRxBufferCurrentChar
       120   -> AdvanceAntRxBufferUnreadMsgPointer
       120   -> AntSrdyPulse
       120   -> DebugPrintf
       120   -> SspWriteData
       120   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_11
       4  ??DataTable21_12
       4  ??DataTable21_13
       4  ??DataTable21_14
       4  ??DataTable21_15
       4  ??DataTable21_16
       4  ??DataTable21_17
       4  ??DataTable21_18
       4  ??DataTable21_19
       4  ??DataTable21_2
       4  ??DataTable21_20
       4  ??DataTable21_21
       4  ??DataTable21_22
       4  ??DataTable21_23
       4  ??DataTable21_24
       4  ??DataTable21_25
       4  ??DataTable21_26
       4  ??DataTable21_27
       4  ??DataTable21_28
       4  ??DataTable21_29
       4  ??DataTable21_3
       4  ??DataTable21_30
       4  ??DataTable21_31
       4  ??DataTable21_32
       4  ??DataTable21_33
       4  ??DataTable21_34
       4  ??DataTable21_35
       4  ??DataTable21_36
       4  ??DataTable21_37
       4  ??DataTable21_38
       4  ??DataTable21_39
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
      16  ?_0
      36  ?_1
      36  ?_10
      44  ?_11
      20  ?_12
      24  ?_13
      32  ?_14
      24  ?_2
      20  ?_3
      20  ?_4
      20  ?_5
      24  ?_6
      12  ?_7
      20  ?_8
      32  ?_9
      40  AdvanceAntRxBufferCurrentChar
      40  AdvanceAntRxBufferUnreadMsgPointer
      44  AntAbortMessage
      36  AntCalculateTxChecksum
      56  AntDeQueueApplicationMessage
      34  AntDeQueueOutgoingMessage
     208  AntExpectResponse
     562  AntInitialize
     272  AntParseExtendedData
     916  AntProcessMessage
     208  AntQueueExtendedApplicationMessage
     188  AntQueueOutgoingMessage
      12  AntRunActiveState
      70  AntRxFlowControlCallback
     580  AntRxMessage
     148  AntSM_Idle
       2  AntSM_NoResponse
      24  AntSM_ReceiveMessage
     120  AntSM_TransmitMessage
      38  AntSrdyPulse
     188  AntSyncSerialInitialize
     110  AntTickExtended
      22  AntTxFlowControlCallback
     390  AntTxMessage
       4  Ant_DebugProcessRxMessages
       4  Ant_DebugQueuedDataMessages
       4  Ant_DebugRxMessageCounter
       4  Ant_DebugTotalRxMessages
       4  Ant_Ssp
      40  Ant_au8AddMessageFailMsg
     256  Ant_au8AntRxBuffer
       4  Ant_pfnStateMachine
       4  Ant_psOutgoingMsgList
       4  Ant_pu8AntRxBufferCurrentChar
       4  Ant_pu8AntRxBufferNextChar
       4  Ant_pu8AntRxBufferUnreadMsg
      36  Ant_sSspConfig
       4  Ant_u32ApplicationMessageCount
       4  Ant_u32CurrentTxMessageToken
       4  Ant_u32OutgoingMessageCount
       4  Ant_u32RxByteCounter
       4  Ant_u32RxTimeoutCounter
       4  Ant_u32RxTimer
       4  Ant_u32TxByteCounter
       4  Ant_u32TxTimer
       4  Ant_u32UnexpectedByteCounter
       1  Ant_u8AntNewRxMessages
      12  Ant_u8AntVersion
       1  Ant_u8SlaveMissedMessageHigh
       1  Ant_u8SlaveMissedMessageLow
       1  Ant_u8SlaveMissedMessageMid
     160  G_asAntChannelConfiguration
       8  G_au8ANTGetVersion
      12  G_au8AntAckDataMessage
       8  G_au8AntAssignChannel
      12  G_au8AntBroadcastDataMessage
       8  G_au8AntLibConfig
      24  G_au8AntMessageAssign
      24  G_au8AntMessageClose
       8  G_au8AntMessageFail
      24  G_au8AntMessageInit
      32  G_au8AntMessageInitFail
      60  G_au8AntMessageNoAnt
       8  G_au8AntMessageOk
      20  G_au8AntMessageOpen
      24  G_au8AntMessageSetup
      24  G_au8AntMessageUnassign
      40  G_au8AntMessageUnhandled
       8  G_au8AntSetChannelID
       8  G_au8AntSetChannelPeriod
       8  G_au8AntSetChannelPower
       8  G_au8AntSetChannelRFFreq
      12  G_au8AntSetNetworkKey
       8  G_au8AntSetSearchTimeout
       4  G_psAntApplicationMsgList
       4  G_stAntMessageResponse
       4  G_u32AntFlags
      16  au8AntFlagAlert
      80  au8AntFlagMessages

 
   556 bytes in section .bss
   524 bytes in section .data
   380 bytes in section .rodata
 4 640 bytes in section .text
 
 4 640 bytes of CODE  memory
   380 bytes of CONST memory
 1 080 bytes of DATA  memory

Errors: none
Warnings: none
