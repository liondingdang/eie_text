###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_i2c.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_i2c.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\sam3u_i2c.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_i2c.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_i2c.c
      1          /*!**********************************************************************************************************************
      2          @file sam3u_i2c.c                                                                
      3          @brief MASTER ONLY.  Provides a driver to use TWI0 (IIC/I2C) peripheral to send and receive data using 
      4          interrupts and PDC direct memory access.
      5          
      6          Currently Set at 200kHz Master Mode.
      7          
      8          Due to the nature of I2C use-cases, this driver does not require tasks to request and release it.
      9          Read / write messages information is queued locally with all required details.  The driver will
     10          continually cycle through the local message buffer and perform the reads or writes on a FIFO basis.
     11          Read messages stand alone.  Write messages will have associated Message task messages.
     12          
     13          Clock stretching is supported automatically by the peripheral in Master mode for both read and write.
     14          
     15          ------------------------------------------------------------------------------------------------------------------------
     16          GLOBALS
     17          - G_u32Twi0ApplicationFlags
     18          
     19          CONSTANTS
     20          - NONE
     21          
     22          TYPES
     23          - TwiStopType
     24          - TwiDirectionType
     25          - TwiPeripheralType
     26          - TwiMessageQueueType
     27          
     28          PUBLIC FUNCTIONS
     29          - bool TwiReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_)
     30          - u32 TwiWriteData(u8 u8SlaveAddress_, u32 u32Size_, u8* pu8Data_, TwiStopType Send_)
     31          
     32          PROTECTED FUNCTIONS
     33          - void SspInitialize(void)
     34          - void SspRunActiveState(void)
     35          - void SspManualMode(void)
     36          - void SSP0_IRQHandler(void)
     37          
     38          
     39          **********************************************************************************************************************/
     40          
     41          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     42          
     43          /***********************************************************************************************************************
     44          Global variable definitions with scope across entire project.
     45          All Global variable names shall start with "G_<type>Twi"
     46          ***********************************************************************************************************************/
     47          /* New variables */
     48          
     49          /*--------------------------------------------------------------------------------------------------------------------*/
     50          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     51          extern volatile u32 G_u32SystemTime1ms;          /*!< @brief From main.c */
     52          extern volatile u32 G_u32SystemTime1s;           /*!< @brief From main.c */
     53          extern volatile u32 G_u32SystemFlags;            /*!< @brief From main.c */
     54          extern volatile u32 G_u32ApplicationFlags;       /*!< @brief From main.c */
     55          
     56          
     57          /***********************************************************************************************************************
     58          Global variable definitions with scope limited to this local application.
     59          Variable names shall start with "TWI_<type>" and be declared as static.
     60          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     61          static fnCode_type TWI_pfnStateMachine;           /*!< @brief The application state machine */
   \                     TWI_pfnStateMachine:
   \   00000000                      DS8 4
     62          

   \                                 In section .bss, align 4
     63          static u32 TWI_u32Timer;                          /*!< @brief Timeout counter used across states */
   \                     TWI_u32Timer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     64          static u32 TWI_u32Flags;                          /*!< @brief Application flags */
   \                     TWI_u32Flags:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          static TwiPeripheralType TWI_Peripheral0;         /*!< @brief TWI0 peripheral object */
   \                     TWI_Peripheral0:
   \   00000000                      DS8 12
     67          

   \                                 In section .bss, align 4
     68          static TwiMessageQueueType TWI_asMessageBuffer[U8_TWI_MSG_BUFFER_SIZE]; /*!< @brief Local circular buffer for TWI msgs */
   \                     TWI_asMessageBuffer:
   \   00000000                      DS8 512

   \                                 In section .bss, align 4
     69          static TwiMessageQueueType* TWI_psMsgBufferNext;                        /*!< @brief Next position to place a message */
   \                     TWI_psMsgBufferNext:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          static TwiMessageQueueType* TWI_psMsgBufferCurrent;                     /*!< @brief Current message that is being processed */
   \                     TWI_psMsgBufferCurrent:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     71          static u8 TWI_u8MsgQueueCount;                                          /*!< @brief Counter to track the number of messages in the queue */
   \                     TWI_u8MsgQueueCount:
   \   00000000                      DS8 1
     72          
     73          
     74          /***********************************************************************************************************************
     75          Function Definitions
     76          ***********************************************************************************************************************/
     77          
     78          /*--------------------------------------------------------------------------------------------------------------------*/
     79          /*! @publicsection */                                                                                            
     80          /*--------------------------------------------------------------------------------------------------------------------*/
     81          
     82          /*!--------------------------------------------------------------------------------------------------------------------
     83          @fn bool TwiReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_)
     84          
     85          @brief Queues a TWI Read Message into TWI_asMessageBuffer
     86          
     87          Read operations do not have an associated message in the Message task queue.
     88          
     89          Requires:
     90          - Master mode
     91          
     92          @param u8SlaveAddress_ holds the target's IC address
     93          @param pu8RxBuffer_ has the space to save the data
     94          @param u32Size_ is the number of bytes to receive
     95          
     96          Promises:
     97          - Queues a multi byte command into the command array
     98          - Returns TRUE if the queue was successful
     99          
    100          */

   \                                 In section .text, align 2, keep-with-next
    101          bool TwiReadData(u8 u8SlaveAddress_, u8* pu8RxBuffer_, u32 u32Size_)
    102          {
   \                     TwiReadData: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    103            if(TWI_u8MsgQueueCount == U8_TWI_MSG_BUFFER_SIZE)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0x2820             CMP      R0,#+32
   \   00000010   0xD101             BNE.N    ??TwiReadData_0
    104            {
    105              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
    106              return FALSE;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE05C             B.N      ??TwiReadData_1
    107            }
    108            
    109            /* Critical section: TWI buffer management must be done with interrutps off since 
    110            an ISR can also manage the buffer values and pointers */
    111            __disable_irq();
   \                     ??TwiReadData_0: (+1)
   \   00000016   0xB672             CPSID    I
    112          
    113            /* Queue Relevant data for TWI register setup */
    114            TWI_psMsgBufferNext->eDirection = TWI_READ;
   \   00000018   0x2002             MOVS     R0,#+2
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x7348             STRB     R0,[R1, #+13]
    115            TWI_psMsgBufferNext->u32Size = u32Size_;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6046             STR      R6,[R0, #+4]
    116            TWI_psMsgBufferNext->u8Address = u8SlaveAddress_;
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x7304             STRB     R4,[R0, #+12]
    117            TWI_psMsgBufferNext->pu8RxBuffer = pu8RxBuffer_;
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6085             STR      R5,[R0, #+8]
    118            
    119            /* Stop condition type and message token do not apply for Rx */
    120            TWI_psMsgBufferNext->eStopType  = TWI_NA; 
   \   0000003A   0x2002             MOVS     R0,#+2
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0x7388             STRB     R0,[R1, #+14]
    121            TWI_psMsgBufferNext->u32MessageTaskToken = 0;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    122                
    123            /* Update array indexers and size */
    124            TWI_u8MsgQueueCount++;
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   0000005A   0x7008             STRB     R0,[R1, #+0]
    125            TWI_psMsgBufferNext++;
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x3010             ADDS     R0,R0,#+16
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000068   0x6008             STR      R0,[R1, #+0]
    126            if( TWI_psMsgBufferNext == &TWI_asMessageBuffer[U8_TWI_MSG_BUFFER_SIZE] )
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD104             BNE.N    ??TwiReadData_2
    127            {
    128              TWI_psMsgBufferNext = &TWI_asMessageBuffer[0];
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000080   0x6008             STR      R0,[R1, #+0]
    129            }
    130            
    131            /* Clear the new location to avoid confusion */
    132            TWI_psMsgBufferNext->eDirection = TWI_EMPTY;
   \                     ??TwiReadData_2: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x7348             STRB     R0,[R1, #+13]
    133            TWI_psMsgBufferNext->u32Size = 0;
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000092   0x6809             LDR      R1,[R1, #+0]
   \   00000094   0x6048             STR      R0,[R1, #+4]
    134            TWI_psMsgBufferNext->u8Address = 0;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000009C   0x6809             LDR      R1,[R1, #+0]
   \   0000009E   0x7308             STRB     R0,[R1, #+12]
    135            TWI_psMsgBufferNext->pu8RxBuffer = NULL;
   \   000000A0   0x2000             MOVS     R0,#+0
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x6088             STR      R0,[R1, #+8]
    136            TWI_psMsgBufferNext->eStopType = TWI_NA; 
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0x7388             STRB     R0,[R1, #+14]
    137            TWI_psMsgBufferNext->u32MessageTaskToken = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000BA   0x6809             LDR      R1,[R1, #+0]
   \   000000BC   0x6008             STR      R0,[R1, #+0]
    138          
    139            /* End of critical section */
    140            __enable_irq();
   \   000000BE   0xB662             CPSIE    I
    141              
    142            /* If the system is initializing, manually cycle the TWI task through one iteration to send the message */
    143            if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x2800             CMP      R0,#+0
   \   000000C8   0xD501             BPL.N    ??TwiReadData_3
    144            {
    145              TwiManualMode();
   \   000000CA   0x.... 0x....      BL       TwiManualMode
    146            }
    147          
    148            return TRUE;
   \                     ??TwiReadData_3: (+1)
   \   000000CE   0x2001             MOVS     R0,#+1
   \                     ??TwiReadData_1: (+1)
   \   000000D0   0xBD70             POP      {R4-R6,PC}       ;; return
    149            
    150          } /* end TwiReadData() */
    151          
    152          
    153          /*!--------------------------------------------------------------------------------------------------------------------
    154          @fn u32 TwiWriteData(u8 u8SlaveAddress_, u32 u32Size_, u8* pu8Data_, TwiStopType eStop_)
    155          
    156          @brief Queues a data array for transfer on the TWI0 peripheral.  
    157          
    158          Requires:
    159          - if a transmission is in progress, the node in the buffer that is currently being sent will not 
    160            be destroyed during this function.
    161          
    162          @param u8SlaveAddress_ holds the target's IC address
    163          @param u32Size_ is the number of bytes to send
    164          @param pu8Data_ points to the start of the data
    165          @param eStop_ is the type of operation
    166          
    167          Promises:
    168          - adds the data message at TWI_Peripheral0.pTransmitBuffer buffer that will be sent by the TWI application
    169            when it is available.
    170          - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    171            G_u32MessagingFlags can be checked for the reason
    172          
    173          */

   \                                 In section .text, align 2, keep-with-next
    174          u32 TwiWriteData(u8 u8SlaveAddress_, u32 u32Size_, u8* pu8Data_, TwiStopType eStop_)
    175          {
   \                     TwiWriteData: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   \   0000000A   0x001F             MOVS     R7,R3
    176            u32 u32Token;
    177              
    178            if(TWI_u8MsgQueueCount == U8_TWI_MSG_BUFFER_SIZE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x2820             CMP      R0,#+32
   \   00000014   0xD101             BNE.N    ??TwiWriteData_0
    179            {
    180              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
    181              return 0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE068             B.N      ??TwiWriteData_1
    182            }
    183          
    184            /* Queue Message in message system */
    185            u32Token = QueueMessage(&TWI_Peripheral0.pTransmitBuffer, u32Size_, pu8Data_);
   \                     ??TwiWriteData_0: (+1)
   \   0000001A   0x0032             MOVS     R2,R6
   \   0000001C   0x0029             MOVS     R1,R5
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable15_7
   \   00000022   0x.... 0x....      BL       QueueMessage
   \   00000026   0x4680             MOV      R8,R0
    186            if(u32Token == 0)
   \   00000028   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000002C   0xD101             BNE.N    ??TwiWriteData_2
    187            {
    188              /* TWI Message Task Queue Full or the Tx transmit isn't complete */
    189              return 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE05C             B.N      ??TwiWriteData_1
    190            }
    191          
    192            /* Critical section: TWI buffer management must be done with interrutps off since 
    193            an ISR can also manage the buffer values and pointers */
    194            __disable_irq();
   \                     ??TwiWriteData_2: (+1)
   \   00000032   0xB672             CPSID    I
    195          
    196            /* Queue Relevant data for TWI register setup */
    197            TWI_psMsgBufferNext->u32MessageTaskToken = u32Token;
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0xF8C0 0x8000      STR      R8,[R0, #+0]
    198            TWI_psMsgBufferNext->eDirection = TWI_WRITE;
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x7348             STRB     R0,[R1, #+13]
    199            TWI_psMsgBufferNext->u32Size    = u32Size_;
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x6045             STR      R5,[R0, #+4]
    200            TWI_psMsgBufferNext->u8Address  = u8SlaveAddress_;
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x7304             STRB     R4,[R0, #+12]
    201            TWI_psMsgBufferNext->eStopType  = eStop_; 
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x7387             STRB     R7,[R0, #+14]
    202            
    203            /* Not used by Transmit */
    204            TWI_psMsgBufferNext->pu8RxBuffer = NULL;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x6088             STR      R0,[R1, #+8]
    205            
    206            /* Update array pointers and size */
    207            TWI_u8MsgQueueCount++;
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable15_2
   \   0000006E   0x7800             LDRB     R0,[R0, #+0]
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000076   0x7008             STRB     R0,[R1, #+0]
    208            TWI_psMsgBufferNext++;
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x3010             ADDS     R0,R0,#+16
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000084   0x6008             STR      R0,[R1, #+0]
    209            if( TWI_psMsgBufferNext == &TWI_asMessageBuffer[U8_TWI_MSG_BUFFER_SIZE] )
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD104             BNE.N    ??TwiWriteData_3
    210            {
    211              TWI_psMsgBufferNext = &TWI_asMessageBuffer[0];
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    212            }
    213          
    214            /* Clear the new location to avoid confusion */
    215            TWI_psMsgBufferNext->eDirection  = TWI_EMPTY;
   \                     ??TwiWriteData_3: (+1)
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x7348             STRB     R0,[R1, #+13]
    216            TWI_psMsgBufferNext->u32Size     = 0;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000AE   0x6809             LDR      R1,[R1, #+0]
   \   000000B0   0x6048             STR      R0,[R1, #+4]
    217            TWI_psMsgBufferNext->u8Address   = 0;
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000B8   0x6809             LDR      R1,[R1, #+0]
   \   000000BA   0x7308             STRB     R0,[R1, #+12]
    218            TWI_psMsgBufferNext->pu8RxBuffer = NULL;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0x6088             STR      R0,[R1, #+8]
    219            TWI_psMsgBufferNext->eStopType   = TWI_NA; 
   \   000000C6   0x2002             MOVS     R0,#+2
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x7388             STRB     R0,[R1, #+14]
    220            TWI_psMsgBufferNext->u32MessageTaskToken = 0;
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   000000D6   0x6809             LDR      R1,[R1, #+0]
   \   000000D8   0x6008             STR      R0,[R1, #+0]
    221          
    222            /* End of critical section */
    223            __enable_irq();
   \   000000DA   0xB662             CPSIE    I
    224          
    225            /* If the system is initializing, manually cycle the TWI task through one iteration to send the message */
    226            if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   000000DC   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x2800             CMP      R0,#+0
   \   000000E4   0xD501             BPL.N    ??TwiWriteData_4
    227            {
    228              TwiManualMode();
   \   000000E6   0x.... 0x....      BL       TwiManualMode
    229            }
    230          
    231            return(u32Token);
   \                     ??TwiWriteData_4: (+1)
   \   000000EA   0x4640             MOV      R0,R8
   \                     ??TwiWriteData_1: (+1)
   \   000000EC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    232            
    233          } /* end TwiWriteData() */
    234          
    235          
    236          /*--------------------------------------------------------------------------------------------------------------------*/
    237          /*! @protectedsection */                                                                                            
    238          /*--------------------------------------------------------------------------------------------------------------------*/
    239          
    240          /*!--------------------------------------------------------------------------------------------------------------------
    241          @fn void TwiInitialize(void)
    242          
    243          @brief Initializes the TWI application and its variables. 
    244          
    245          Requires:
    246          - NONE 
    247          
    248          Promises:
    249          - TWI peripheral objects are ready 
    250          - TWI application set to Idle
    251          
    252          */

   \                                 In section .text, align 2, keep-with-next
    253          void TwiInitialize(void)
    254          {
   \                     TwiInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    255            /* Enable the peripheral */
    256            AT91C_BASE_PMC->PMC_PCER |= (1 << AT91C_ID_TWI0);
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0x400e0410
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF450 0x2080      ORRS     R0,R0,#0x40000
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_8  ;; 0x400e0410
   \   00000010   0x6008             STR      R0,[R1, #+0]
    257            
    258            /* Init flags, pointers and globals */
    259            TWI_u32Flags = 0;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   00000018   0x6008             STR      R0,[R1, #+0]
    260            TWI_psMsgBufferNext = TWI_asMessageBuffer;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    261            TWI_psMsgBufferCurrent = TWI_asMessageBuffer;
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_5
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    262            TWI_u8MsgQueueCount = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable15_2
   \   00000034   0x7008             STRB     R0,[R1, #+0]
    263            
    264            /* Clear the local message buffer */
    265            for(u8 i = 0; i < U8_TWI_MSG_BUFFER_SIZE; i++)
   \   00000036   0x2000             MOVS     R0,#+0
   \                     ??TwiInitialize_0: (+1)
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x2820             CMP      R0,#+32
   \   0000003C   0xDA2A             BGE.N    ??TwiInitialize_1
    266            {
    267              TWI_asMessageBuffer[i].eDirection = TWI_EMPTY;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   0000004A   0x7351             STRB     R1,[R2, #+13]
    268              TWI_asMessageBuffer[i].eStopType = TWI_NA;
   \   0000004C   0x2102             MOVS     R1,#+2
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   00000058   0x7391             STRB     R1,[R2, #+14]
    269              TWI_asMessageBuffer[i].pu8RxBuffer = NULL ;
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   00000060   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000062   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   00000066   0x6091             STR      R1,[R2, #+8]
    270              TWI_asMessageBuffer[i].u32MessageTaskToken = 0;
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x0103             LSLS     R3,R0,#+4
   \   00000072   0x5099             STR      R1,[R3, R2]
    271              TWI_asMessageBuffer[i].u32Size = 0;
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   0000007A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007C   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   00000080   0x6051             STR      R1,[R2, #+4]
    272              TWI_asMessageBuffer[i].u8Address = 0;
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable15_5
   \   00000088   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008A   0xEB12 0x1200      ADDS     R2,R2,R0, LSL #+4
   \   0000008E   0x7311             STRB     R1,[R2, #+12]
    273            }
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0xE7D1             B.N      ??TwiInitialize_0
    274             
    275            /* Initialize the TWI peripheral structures */
    276            TWI_Peripheral0.pBaseAddress    = AT91C_BASE_TWI0;
   \                     ??TwiInitialize_1: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable15_11  ;; 0x40084000
   \   00000098   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    277            TWI_Peripheral0.pTransmitBuffer = NULL;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000A4   0x6048             STR      R0,[R1, #+4]
    278            TWI_Peripheral0.u32PrivateFlags = 0;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000AC   0x6088             STR      R0,[R1, #+8]
    279          
    280            /* Software reset of peripheral */
    281            TWI_Peripheral0.pBaseAddress->TWI_CR = AT91C_TWI_SWRST;
   \   000000AE   0x2080             MOVS     R0,#+128
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    282            TWI_u32Timer = G_u32SystemTime1ms;
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x.... 0x....      LDR.W    R1,??DataTable15_14
   \   000000C2   0x6008             STR      R0,[R1, #+0]
    283            while( !IsTimeUp(&TWI_u32Timer, 1) );
   \                     ??TwiInitialize_2: (+1)
   \   000000C4   0x2101             MOVS     R1,#+1
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable15_14
   \   000000CA   0x.... 0x....      BL       IsTimeUp
   \   000000CE   0x2800             CMP      R0,#+0
   \   000000D0   0xD0F8             BEQ.N    ??TwiInitialize_2
    284            
    285            /* Configure Peripheral for Master mode */
    286            TWI_Peripheral0.pBaseAddress->TWI_CWGR = TWI0_CWGR_INIT;
   \   000000D2   0x.... 0x....      LDR.W    R0,??DataTable15_15  ;; 0x21d1d
   \   000000D6   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000DA   0x6809             LDR      R1,[R1, #+0]
   \   000000DC   0x6108             STR      R0,[R1, #+16]
    287            TWI_Peripheral0.pBaseAddress->TWI_CR   = TWI0_CR_INIT;
   \   000000DE   0x2024             MOVS     R0,#+36
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000E4   0x6809             LDR      R1,[R1, #+0]
   \   000000E6   0x6008             STR      R0,[R1, #+0]
    288            TWI_Peripheral0.pBaseAddress->TWI_MMR  = TWI0_MMR_INIT;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000EE   0x6809             LDR      R1,[R1, #+0]
   \   000000F0   0x6048             STR      R0,[R1, #+4]
    289            TWI_Peripheral0.pBaseAddress->TWI_IER  = TWI0_IER_INIT;
   \   000000F2   0xF44F 0x7080      MOV      R0,#+256
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   000000FA   0x6809             LDR      R1,[R1, #+0]
   \   000000FC   0x6248             STR      R0,[R1, #+36]
    290            TWI_Peripheral0.pBaseAddress->TWI_IDR  = ~TWI0_IER_INIT;
   \   000000FE   0xF47F 0x7080      MVNS     R0,#+256
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0x6288             STR      R0,[R1, #+40]
    291            
    292            /* Enable TWI interrupts */
    293            NVIC_ClearPendingIRQ( (IRQn_Type)AT91C_ID_TWI0 );
   \   0000010A   0x2012             MOVS     R0,#+18
   \   0000010C   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    294            NVIC_EnableIRQ( (IRQn_Type)AT91C_ID_TWI0 );
   \   00000110   0x2012             MOVS     R0,#+18
   \   00000112   0x.... 0x....      BL       NVIC_EnableIRQ
    295          
    296            /* Set application pointer */
    297            TWI_pfnStateMachine = TwiSM_Idle;
   \   00000116   0x.... 0x....      ADR.W    R0,TwiSM_Idle
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable15_16
   \   0000011E   0x6008             STR      R0,[R1, #+0]
    298            DebugPrintf("TWI Peripheral Ready\n\r");
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable15_17
   \   00000124   0x.... 0x....      BL       DebugPrintf
    299            
    300          } /* end TwiInitialize() */
   \   00000128   0xBD01             POP      {R0,PC}          ;; return
    301          
    302          
    303          /*!----------------------------------------------------------------------------------------------------------------------
    304          @fn void TwiRunActiveState(void)
    305          
    306          @brief Selects and runs one iteration of the current state in the state machine.
    307          
    308          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    309          may take 1ms / n to execute.
    310          
    311          Requires:
    312          - State machine function pointer points at current state
    313          
    314          Promises:
    315          - Calls the function to pointed by the state machine function pointer
    316          
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void TwiRunActiveState(void)
    319          {
   \                     TwiRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    320            TWI_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    321          
    322          } /* end TwiRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    323          
    324          
    325          /*!----------------------------------------------------------------------------------------------------------------------
    326          @fn void TwiManualMode(void)
    327          
    328          @brief Runs a transmit cycle of the TWI application to clock a message.  
    329          This function is used only during initialization.
    330          
    331          Requires:
    332          - G_u32SystemFlags _SYSTEM_INITIALIZING is set
    333          - TWI application has been initialized.
    334          
    335          Promises:
    336          - All pending messages sent
    337          - TWI_u8MsgQueueCount = 0
    338              
    339          */

   \                                 In section .text, align 2, keep-with-next
    340          void TwiManualMode(void)
    341          {
   \                     TwiManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    342            u32 u32Timer;
    343            
    344            TWI_u32Flags |=_TWI_INIT_MODE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   00000010   0x6008             STR      R0,[R1, #+0]
    345            
    346            while(TWI_u32Flags &_TWI_INIT_MODE)
   \                     ??TwiManualMode_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD517             BPL.N    ??TwiManualMode_1
    347            {
    348              WATCHDOG_BONE();
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_18  ;; 0xa5000001
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable15_19  ;; 0x400e1250
   \   00000024   0x6008             STR      R0,[R1, #+0]
    349              TWI_pfnStateMachine();
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_16
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x4780             BLX      R0
    350              MessagingRunActiveState();
   \   0000002E   0x.... 0x....      BL       MessagingRunActiveState
    351              DebugRunActiveState();
   \   00000032   0x.... 0x....      BL       DebugRunActiveState
    352              
    353              u32Timer = G_u32SystemTime1ms;
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x9000             STR      R0,[SP, #+0]
    354              while( !IsTimeUp(&u32Timer, 1) );
   \                     ??TwiManualMode_2: (+1)
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       IsTimeUp
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD1E3             BNE.N    ??TwiManualMode_0
   \   0000004A   0xE7F8             B.N      ??TwiManualMode_2
    355            }
    356                
    357          } /* end TwiManualMode() */
   \                     ??TwiManualMode_1: (+1)
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
    358          
    359          
    360          /*!----------------------------------------------------------------------------------------------------------------------
    361          @fn ISR void TWI0_IrqHandler(void)
    362          
    363          @brief Handles the TWI0 Peripheral interrupts
    364          
    365          Requires:
    366          - NONE
    367          
    368          Promises:
    369          - NACK: flags error, disables ENDTX and sets Error state
    370          - ENDTX: disables interrupt & PDC, writes STOP (if applicable), and clears _TWI_TRANSMITTING
    371          - ENDRX: disables interrupt & PDC and writes STOP
    372          
    373          */

   \                                 In section .text, align 2, keep-with-next
    374          void TWI0_IrqHandler(void)
    375          {
    376            u32 u32InterruptStatus;
    377            
    378            /* Grab active interrupts and compare with status */
    379            u32InterruptStatus = AT91C_BASE_TWI0->TWI_IMR;
   \                     TWI0_IrqHandler: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable15_20  ;; 0x4008402c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x0008             MOVS     R0,R1
    380            u32InterruptStatus &= AT91C_BASE_TWI0->TWI_SR;
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable15_21  ;; 0x40084020
   \   0000000C   0x6809             LDR      R1,[R1, #+0]
   \   0000000E   0x4008             ANDS     R0,R1,R0
    381            
    382            /*** NACK Received (Master only) ***/
    383            if(u32InterruptStatus & AT91C_TWI_NACK_MASTER )
   \   00000010   0x05C1             LSLS     R1,R0,#+23
   \   00000012   0xD519             BPL.N    ??TWI0_IrqHandler_0
    384            {
    385              /* Error has occurred, abort the message */
    386              TWI_u32Flags |= _TWI_ERROR_NACK;
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable15_9
   \   00000018   0x6809             LDR      R1,[R1, #+0]
   \   0000001A   0xF051 0x7180      ORRS     R1,R1,#0x1000000
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable15_9
   \   00000022   0x6011             STR      R1,[R2, #+0]
    387              TWI_Peripheral0.pBaseAddress->TWI_IDR = AT91C_TWI_ENDTX;
   \   00000024   0xF44F 0x5100      MOV      R1,#+8192
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x6291             STR      R1,[R2, #+40]
    388              TWI_Peripheral0.pBaseAddress->TWI_PTCR = AT91C_PDC_TXTDIS;
   \   00000030   0xF44F 0x7100      MOV      R1,#+512
   \   00000034   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   00000038   0x6812             LDR      R2,[R2, #+0]
   \   0000003A   0xF8C2 0x1120      STR      R1,[R2, #+288]
    389              TWI_pfnStateMachine = TwiSM_Error;
   \   0000003E   0x.... 0x....      ADR.W    R1,TwiSM_Error
   \   00000042   0x.... 0x....      LDR.W    R2,??DataTable15_16
   \   00000046   0x6011             STR      R1,[R2, #+0]
    390            }
    391          
    392            /*** ENDTX (transmit has finished) ***/
    393            if(u32InterruptStatus & AT91C_TWI_ENDTX )
   \                     ??TWI0_IrqHandler_0: (+1)
   \   00000048   0x0481             LSLS     R1,R0,#+18
   \   0000004A   0xD525             BPL.N    ??TWI0_IrqHandler_1
    394            {
    395              /* Disable interrupt and PDC transfer */
    396              TWI_Peripheral0.pBaseAddress->TWI_IDR = AT91C_TWI_ENDTX;
   \   0000004C   0xF44F 0x5100      MOV      R1,#+8192
   \   00000050   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   00000054   0x6812             LDR      R2,[R2, #+0]
   \   00000056   0x6291             STR      R1,[R2, #+40]
    397              TWI_Peripheral0.pBaseAddress->TWI_PTCR = AT91C_PDC_TXTDIS;
   \   00000058   0xF44F 0x7100      MOV      R1,#+512
   \   0000005C   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   00000060   0x6812             LDR      R2,[R2, #+0]
   \   00000062   0xF8C2 0x1120      STR      R1,[R2, #+288]
    398          
    399              /* Set stop condition if multi-byte transfer */
    400              if( (TWI_Peripheral0.pTransmitBuffer->u32Size != 1) &&
    401                  (TWI_psMsgBufferCurrent->eStopType == TWI_STOP) )
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   0000006A   0x6849             LDR      R1,[R1, #+4]
   \   0000006C   0x6849             LDR      R1,[R1, #+4]
   \   0000006E   0x2901             CMP      R1,#+1
   \   00000070   0xD00A             BEQ.N    ??TWI0_IrqHandler_2
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable15_10
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x7B89             LDRB     R1,[R1, #+14]
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD104             BNE.N    ??TWI0_IrqHandler_2
    402              {
    403                TWI_Peripheral0.pBaseAddress->TWI_CR = AT91C_TWI_STOP;
   \   0000007E   0x2102             MOVS     R1,#+2
   \   00000080   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   00000084   0x6812             LDR      R2,[R2, #+0]
   \   00000086   0x6011             STR      R1,[R2, #+0]
    404              }
    405              
    406              TWI_Peripheral0.u32PrivateFlags &= ~_TWI_TRANSMITTING;
   \                     ??TWI0_IrqHandler_2: (+1)
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable15_12
   \   0000008C   0x6889             LDR      R1,[R1, #+8]
   \   0000008E   0x0849             LSRS     R1,R1,#+1
   \   00000090   0x0049             LSLS     R1,R1,#+1
   \   00000092   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   00000096   0x6091             STR      R1,[R2, #+8]
    407          
    408            } /* end ENDTX handler */
    409            
    410            
    411            /*** ENDRX (receive has finished ALL BUT ONE bytes) ***/
    412            if(u32InterruptStatus & AT91C_TWI_ENDRX )
   \                     ??TWI0_IrqHandler_1: (+1)
   \   00000098   0x04C1             LSLS     R1,R0,#+19
   \   0000009A   0xD515             BPL.N    ??TWI0_IrqHandler_3
    413            {
    414              /* Disable interrupt and PDC transfer */
    415              TWI_Peripheral0.pBaseAddress->TWI_IDR = AT91C_TWI_ENDRX;
   \   0000009C   0xF44F 0x5180      MOV      R1,#+4096
   \   000000A0   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   000000A4   0x6812             LDR      R2,[R2, #+0]
   \   000000A6   0x6291             STR      R1,[R2, #+40]
    416              TWI_Peripheral0.pBaseAddress->TWI_PTCR = AT91C_PDC_RXTDIS;
   \   000000A8   0x2102             MOVS     R1,#+2
   \   000000AA   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   000000AE   0x6812             LDR      R2,[R2, #+0]
   \   000000B0   0xF8C2 0x1120      STR      R1,[R2, #+288]
    417          
    418              /* Set stop condition and change states */
    419              TWI_Peripheral0.pBaseAddress->TWI_CR = AT91C_TWI_STOP;
   \   000000B4   0x2102             MOVS     R1,#+2
   \   000000B6   0x.... 0x....      LDR.W    R2,??DataTable15_12
   \   000000BA   0x6812             LDR      R2,[R2, #+0]
   \   000000BC   0x6011             STR      R1,[R2, #+0]
    420              TWI_pfnStateMachine = TwiSM_ReceiveLastByte;
   \   000000BE   0x.... 0x....      ADR.W    R1,TwiSM_ReceiveLastByte
   \   000000C2   0x.... 0x....      LDR.W    R2,??DataTable15_16
   \   000000C6   0x6011             STR      R1,[R2, #+0]
    421          
    422            } /* end ENDRX handler */
    423            
    424          } /* end TWI0_IrqHandler() */
   \                     ??TWI0_IrqHandler_3: (+1)
   \   000000C8   0x4770             BX       LR               ;; return
    425          
    426          
    427          /*----------------------------------------------------------------------------------------------------------------------*/
    428          /*! @privatesection */                                                                                            
    429          /*----------------------------------------------------------------------------------------------------------------------*/
    430          
    431          
    432          /***********************************************************************************************************************
    433          State Machine Function Definitions
    434          ***********************************************************************************************************************/
    435          
    436          /*!-------------------------------------------------------------------------------------------------------------------
    437          @fn static void TwiSM_Idle(void)
    438          @brief Wait for a message to be queued then process that message.
    439          */

   \                                 In section .text, align 4, keep-with-next
    440          static void TwiSM_Idle(void)
    441          {
   \                     TwiSM_Idle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    442            u32 u32Byte;
    443          
    444            /* Do nothing unless new Tx or Rx messages have been queued */
    445            if(TWI_u8MsgQueueCount != 0)
   \   00000002   0x....             LDR.N    R0,??DataTable15_2
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xF000 0x80A9      BEQ.W    ??TwiSM_Idle_0
    446            {
    447              if(TWI_psMsgBufferCurrent->eDirection == TWI_WRITE)
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_10
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x7B40             LDRB     R0,[R0, #+13]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD156             BNE.N    ??TwiSM_Idle_1
    448              {
    449                /* Check that the local buffer Message token matches the message queued
    450                and the transmit buffer */
    451                if(TWI_psMsgBufferCurrent->u32MessageTaskToken != TWI_Peripheral0.pTransmitBuffer->u32Token)
   \   00000018   0x....             LDR.N    R0,??DataTable15_10
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x....             LDR.N    R1,??DataTable15_12
   \   00000020   0x6849             LDR      R1,[R1, #+4]
   \   00000022   0x6809             LDR      R1,[R1, #+0]
   \   00000024   0x4288             CMP      R0,R1
   \   00000026   0xD00A             BEQ.N    ??TwiSM_Idle_2
    452                {
    453                  DebugPrintf("TWI transmit message out of sync!\n\r");
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_22
   \   0000002C   0x.... 0x....      BL       DebugPrintf
    454                  TWI_Peripheral0.u32PrivateFlags |= _TWI_ERROR_TX_MSG_SYNC;
   \   00000030   0x....             LDR.N    R0,??DataTable15_12
   \   00000032   0x6880             LDR      R0,[R0, #+8]
   \   00000034   0xF050 0x7080      ORRS     R0,R0,#0x1000000
   \   00000038   0x....             LDR.N    R1,??DataTable15_12
   \   0000003A   0x6088             STR      R0,[R1, #+8]
   \   0000003C   0xE08F             B.N      ??TwiSM_Idle_0
    455                }
    456                else
    457                {
    458                  /* Update the message's status */
    459                  UpdateMessageStatus(TWI_Peripheral0.pTransmitBuffer->u32Token, SENDING);
   \                     ??TwiSM_Idle_2: (+1)
   \   0000003E   0x2102             MOVS     R1,#+2
   \   00000040   0x....             LDR.N    R0,??DataTable15_12
   \   00000042   0x6840             LDR      R0,[R0, #+4]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x.... 0x....      BL       UpdateMessageStatus
    460          
    461                  /* Set up to transmit the message */
    462                  TWI_Peripheral0.u32PrivateFlags |= (_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \   0000004A   0x....             LDR.N    R0,??DataTable15_12
   \   0000004C   0x6880             LDR      R0,[R0, #+8]
   \   0000004E   0xF050 0x0005      ORRS     R0,R0,#0x5
   \   00000052   0x....             LDR.N    R1,??DataTable15_12
   \   00000054   0x6088             STR      R0,[R1, #+8]
    463                  u32Byte = (TWI_psMsgBufferCurrent->u8Address) << TWI_MMR_ADDRESS_SHIFT;
   \   00000056   0x....             LDR.N    R0,??DataTable15_10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0x7B00             LDRB     R0,[R0, #+12]
   \   0000005C   0x0400             LSLS     R0,R0,#+16
   \   0000005E   0x0004             MOVS     R4,R0
    464                  TWI_Peripheral0.pBaseAddress->TWI_MMR |= u32Byte; 
   \   00000060   0x....             LDR.N    R0,??DataTable15_12
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x6840             LDR      R0,[R0, #+4]
   \   00000066   0x4320             ORRS     R0,R4,R0
   \   00000068   0x....             LDR.N    R1,??DataTable15_12
   \   0000006A   0x6809             LDR      R1,[R1, #+0]
   \   0000006C   0x6048             STR      R0,[R1, #+4]
    465          
    466                  /* Setup PDC and interrupts */
    467                  TWI_Peripheral0.pBaseAddress->TWI_TPR = (u32)TWI_Peripheral0.pTransmitBuffer->pu8Message; 
   \   0000006E   0x....             LDR.N    R0,??DataTable15_12
   \   00000070   0x6840             LDR      R0,[R0, #+4]
   \   00000072   0x3008             ADDS     R0,R0,#+8
   \   00000074   0x....             LDR.N    R1,??DataTable15_12
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0xF8C1 0x0108      STR      R0,[R1, #+264]
    468                  TWI_Peripheral0.pBaseAddress->TWI_TCR = TWI_Peripheral0.pTransmitBuffer->u32Size;
   \   0000007C   0x....             LDR.N    R0,??DataTable15_12
   \   0000007E   0x6840             LDR      R0,[R0, #+4]
   \   00000080   0x6840             LDR      R0,[R0, #+4]
   \   00000082   0x....             LDR.N    R1,??DataTable15_12
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0xF8C1 0x010C      STR      R0,[R1, #+268]
    469          
    470                  /* Enable Tx interrupt and the transmitter (triggers THR load) */
    471                  TWI_Peripheral0.pBaseAddress->TWI_IER = AT91C_TWI_ENDTX;
   \   0000008A   0xF44F 0x5000      MOV      R0,#+8192
   \   0000008E   0x....             LDR.N    R1,??DataTable15_12
   \   00000090   0x6809             LDR      R1,[R1, #+0]
   \   00000092   0x6248             STR      R0,[R1, #+36]
    472                  TWI_Peripheral0.pBaseAddress->TWI_PTCR = AT91C_PDC_TXTEN;
   \   00000094   0xF44F 0x7080      MOV      R0,#+256
   \   00000098   0x....             LDR.N    R1,??DataTable15_12
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0xF8C1 0x0120      STR      R0,[R1, #+288]
    473                       
    474                  /* Single byte transfers need STOP immediately (if applicable) */
    475                  if(TWI_Peripheral0.pTransmitBuffer->u32Size == 1)
   \   000000A0   0x....             LDR.N    R0,??DataTable15_12
   \   000000A2   0x6840             LDR      R0,[R0, #+4]
   \   000000A4   0x6840             LDR      R0,[R0, #+4]
   \   000000A6   0x2801             CMP      R0,#+1
   \   000000A8   0xD108             BNE.N    ??TwiSM_Idle_3
    476                  {
    477                    /* Set up the stop condition immediately if applicable */
    478                    if(TWI_psMsgBufferCurrent->eStopType == TWI_STOP)
   \   000000AA   0x....             LDR.N    R0,??DataTable15_10
   \   000000AC   0x6800             LDR      R0,[R0, #+0]
   \   000000AE   0x7B80             LDRB     R0,[R0, #+14]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD103             BNE.N    ??TwiSM_Idle_3
    479                    {
    480                      TWI_Peripheral0.pBaseAddress->TWI_CR = AT91C_TWI_STOP;
   \   000000B4   0x2002             MOVS     R0,#+2
   \   000000B6   0x....             LDR.N    R1,??DataTable15_12
   \   000000B8   0x6809             LDR      R1,[R1, #+0]
   \   000000BA   0x6008             STR      R0,[R1, #+0]
    481                    }
    482                  }
    483          
    484                  TWI_pfnStateMachine = TwiSM_Transmit;
   \                     ??TwiSM_Idle_3: (+1)
   \   000000BC   0x.... 0x....      ADR.W    R0,TwiSM_Transmit
   \   000000C0   0x....             LDR.N    R1,??DataTable15_16
   \   000000C2   0x6008             STR      R0,[R1, #+0]
   \   000000C4   0xE04B             B.N      ??TwiSM_Idle_0
    485          
    486                } /* end WRITE setup */
    487              } /* end TWI_WRITE */
    488              
    489              else if(TWI_psMsgBufferCurrent->eDirection == TWI_READ)
   \                     ??TwiSM_Idle_1: (+1)
   \   000000C6   0x....             LDR.N    R0,??DataTable15_10
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x7B40             LDRB     R0,[R0, #+13]
   \   000000CC   0x2802             CMP      R0,#+2
   \   000000CE   0xD146             BNE.N    ??TwiSM_Idle_0
    490              {
    491                /* Set up for READ transaction */
    492                u32Byte = AT91C_TWI_MREAD | (TWI_psMsgBufferCurrent->u8Address << TWI_MMR_ADDRESS_SHIFT);
   \   000000D0   0x....             LDR.N    R0,??DataTable15_10
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x7B00             LDRB     R0,[R0, #+12]
   \   000000D6   0x0400             LSLS     R0,R0,#+16
   \   000000D8   0xF450 0x5080      ORRS     R0,R0,#0x1000
   \   000000DC   0x0004             MOVS     R4,R0
    493                TWI_Peripheral0.pBaseAddress->TWI_MMR |= u32Byte; 
   \   000000DE   0x....             LDR.N    R0,??DataTable15_12
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x6840             LDR      R0,[R0, #+4]
   \   000000E4   0x4320             ORRS     R0,R4,R0
   \   000000E6   0x....             LDR.N    R1,??DataTable15_12
   \   000000E8   0x6809             LDR      R1,[R1, #+0]
   \   000000EA   0x6048             STR      R0,[R1, #+4]
    494                TWI_Peripheral0.u32PrivateFlags |= _TWI_RECEIVING;
   \   000000EC   0x....             LDR.N    R0,??DataTable15_12
   \   000000EE   0x6880             LDR      R0,[R0, #+8]
   \   000000F0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000000F4   0x....             LDR.N    R1,??DataTable15_12
   \   000000F6   0x6088             STR      R0,[R1, #+8]
    495          
    496                /* Set up to receive the message based on number of bytes */
    497                if(TWI_psMsgBufferCurrent->u32Size == 1)
   \   000000F8   0x....             LDR.N    R0,??DataTable15_10
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x6840             LDR      R0,[R0, #+4]
   \   000000FE   0x2801             CMP      R0,#+1
   \   00000100   0xD108             BNE.N    ??TwiSM_Idle_4
    498                {
    499                  /* Single byte direct receive (no PDC required) */
    500                  TWI_Peripheral0.pBaseAddress->TWI_CR = (AT91C_TWI_START | AT91C_TWI_STOP);
   \   00000102   0x2003             MOVS     R0,#+3
   \   00000104   0x....             LDR.N    R1,??DataTable15_12
   \   00000106   0x6809             LDR      R1,[R1, #+0]
   \   00000108   0x6008             STR      R0,[R1, #+0]
    501                  TWI_pfnStateMachine = TwiSM_ReceiveLastByte;
   \   0000010A   0x.... 0x....      ADR.W    R0,TwiSM_ReceiveLastByte
   \   0000010E   0x....             LDR.N    R1,??DataTable15_16
   \   00000110   0x6008             STR      R0,[R1, #+0]
   \   00000112   0xE024             B.N      ??TwiSM_Idle_0
    502                }
    503                else
    504                {
    505                  /* Multi-byte PDC-based receive */
    506                  TWI_Peripheral0.pBaseAddress->TWI_RPR = (u32)TWI_psMsgBufferCurrent->pu8RxBuffer;
   \                     ??TwiSM_Idle_4: (+1)
   \   00000114   0x....             LDR.N    R0,??DataTable15_10
   \   00000116   0x6800             LDR      R0,[R0, #+0]
   \   00000118   0x6880             LDR      R0,[R0, #+8]
   \   0000011A   0x....             LDR.N    R1,??DataTable15_12
   \   0000011C   0x6809             LDR      R1,[R1, #+0]
   \   0000011E   0xF8C1 0x0100      STR      R0,[R1, #+256]
    507                  TWI_Peripheral0.pBaseAddress->TWI_RCR = TWI_psMsgBufferCurrent->u32Size - 1;
   \   00000122   0x....             LDR.N    R0,??DataTable15_10
   \   00000124   0x6800             LDR      R0,[R0, #+0]
   \   00000126   0x6840             LDR      R0,[R0, #+4]
   \   00000128   0x1E40             SUBS     R0,R0,#+1
   \   0000012A   0x....             LDR.N    R1,??DataTable15_12
   \   0000012C   0x6809             LDR      R1,[R1, #+0]
   \   0000012E   0xF8C1 0x0104      STR      R0,[R1, #+260]
    508                  TWI_Peripheral0.pBaseAddress->TWI_IER = AT91C_TWI_ENDRX;
   \   00000132   0xF44F 0x5080      MOV      R0,#+4096
   \   00000136   0x....             LDR.N    R1,??DataTable15_12
   \   00000138   0x6809             LDR      R1,[R1, #+0]
   \   0000013A   0x6248             STR      R0,[R1, #+36]
    509                  TWI_Peripheral0.pBaseAddress->TWI_PTCR = AT91C_PDC_RXTEN;
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0x....             LDR.N    R1,??DataTable15_12
   \   00000140   0x6809             LDR      R1,[R1, #+0]
   \   00000142   0xF8C1 0x0120      STR      R0,[R1, #+288]
    510          
    511                  /* Trigger the peripheral to start */
    512                  TWI_Peripheral0.pBaseAddress->TWI_CR = AT91C_TWI_START;
   \   00000146   0x2001             MOVS     R0,#+1
   \   00000148   0x....             LDR.N    R1,??DataTable15_12
   \   0000014A   0x6809             LDR      R1,[R1, #+0]
   \   0000014C   0x6008             STR      R0,[R1, #+0]
    513          
    514                  /* Proceed to receiving state*/
    515                  TWI_u32Timer = G_u32SystemTime1ms;
   \   0000014E   0x....             LDR.N    R0,??DataTable15_13
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x....             LDR.N    R1,??DataTable15_14
   \   00000154   0x6008             STR      R0,[R1, #+0]
    516                  TWI_pfnStateMachine = TwiSM_PdcReceive;
   \   00000156   0x.... 0x....      ADR.W    R0,TwiSM_PdcReceive
   \   0000015A   0x....             LDR.N    R1,??DataTable15_16
   \   0000015C   0x6008             STR      R0,[R1, #+0]
    517                }
    518              } /* end TWI_READ */ 
    519            } /* if(TWI_u8MsgQueueCount != 0) */  
    520            
    521          } /* end TwiSM_Idle() */
   \                     ??TwiSM_Idle_0: (+1)
   \   0000015E   0xBD10             POP      {R4,PC}          ;; return
    522               
    523          
    524          /*!-------------------------------------------------------------------------------------------------------------------
    525          @fn static void TwiSM_Transmit(void)
    526          @brief Transmit in progress until until ISR clears _TWI_TRANSMITTING.
    527          */

   \                                 In section .text, align 4, keep-with-next
    528          static void TwiSM_Transmit(void)
    529          {
   \                     TwiSM_Transmit: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    530            /* Watch _TWI_TRANSMITTING to indicate transmit is complete */
    531            if( !(TWI_Peripheral0.u32PrivateFlags & _TWI_TRANSMITTING) )
   \   00000002   0x....             LDR.N    R0,??DataTable15_12
   \   00000004   0x7A00             LDRB     R0,[R0, #+8]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD419             BMI.N    ??TwiSM_Transmit_0
    532            {
    533              /*  Clean up the Message task message */
    534              UpdateMessageStatus(TWI_Peripheral0.pTransmitBuffer->u32Token, COMPLETE);
   \   0000000A   0x2103             MOVS     R1,#+3
   \   0000000C   0x....             LDR.N    R0,??DataTable15_12
   \   0000000E   0x6840             LDR      R0,[R0, #+4]
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x.... 0x....      BL       UpdateMessageStatus
    535              DeQueueMessage(&TWI_Peripheral0.pTransmitBuffer);
   \   00000016   0x....             LDR.N    R0,??DataTable15_7
   \   00000018   0x.... 0x....      BL       DeQueueMessage
    536          
    537              
    538              /* Advance states depending on whether TXCOMP is expected */
    539              if(TWI_psMsgBufferCurrent->eStopType == TWI_STOP)
   \   0000001C   0x....             LDR.N    R0,??DataTable15_10
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x7B80             LDRB     R0,[R0, #+14]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD104             BNE.N    ??TwiSM_Transmit_1
    540              {
    541                /* If a STOP condition is requested, need to wait for TXCOMP */
    542                TWI_pfnStateMachine = TwiSM_TxWaitComplete;
   \   00000026   0x.... 0x....      ADR.W    R0,TwiSM_TxWaitComplete
   \   0000002A   0x....             LDR.N    R1,??DataTable15_16
   \   0000002C   0x6008             STR      R0,[R1, #+0]
   \   0000002E   0xE006             B.N      ??TwiSM_Transmit_0
    543              }
    544              else
    545              {
    546                /* Otherwise leave the bus active */
    547                TWI_u32Timer = U8_NEXT_TRANSFER_DELAY_MS;
   \                     ??TwiSM_Transmit_1: (+1)
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0x....             LDR.N    R1,??DataTable15_14
   \   00000034   0x6008             STR      R0,[R1, #+0]
    548                TWI_pfnStateMachine = TwiSM_NextTransferDelay;
   \   00000036   0x.... 0x....      ADR.W    R0,TwiSM_NextTransferDelay
   \   0000003A   0x....             LDR.N    R1,??DataTable15_16
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    549              }
    550            }
    551              
    552          } /* end TwiSM_Transmit() */
   \                     ??TwiSM_Transmit_0: (+1)
   \   0000003E   0xBD01             POP      {R0,PC}          ;; return
    553          
    554          
    555          /*!-------------------------------------------------------------------------------------------------------------------
    556          @fn static void TwiSM_TxWaitComplete(void)
    557          @brief Optional state to wait for the TXCOMP bit to be set (indicates STOP condition
    558          has been placed on the bus). Some Master transmit states will bypass this. */

   \                                 In section .text, align 4, keep-with-next
    559          static void TwiSM_TxWaitComplete(void)
    560          {
    561            /* Wait for TX to complete */
    562            if(TWI_Peripheral0.pBaseAddress->TWI_SR & AT91C_TWI_TXCOMP_MASTER)
   \                     TwiSM_TxWaitComplete: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_12
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6A00             LDR      R0,[R0, #+32]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD50C             BPL.N    ??TwiSM_TxWaitComplete_0
    563            {
    564              /* Clear flags and advance states */
    565              TWI_Peripheral0.u32PrivateFlags &= ~_TWI_TRANS_NOT_COMP;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_12
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000012   0x....             LDR.N    R1,??DataTable15_12
   \   00000014   0x6088             STR      R0,[R1, #+8]
    566              
    567              TWI_u32Timer = U8_NEXT_TRANSFER_DELAY_MS;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable15_14
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    568              TWI_pfnStateMachine = TwiSM_NextTransferDelay;
   \   0000001C   0x.... 0x....      ADR.W    R0,TwiSM_NextTransferDelay
   \   00000020   0x....             LDR.N    R1,??DataTable15_16
   \   00000022   0x6008             STR      R0,[R1, #+0]
    569            }
    570              
    571          } /* end TwiSM_TxWaitComplete() */
   \                     ??TwiSM_TxWaitComplete_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    572          
    573          
    574          /*!-------------------------------------------------------------------------------------------------------------------
    575          @fn static void TwiSM_PdcReceive(void)
    576          @brief Receive in progress through PDC until 1 byte remains.
    577          The ENDRX ISR is responsible for changing states to exit here.
    578          */

   \                                 In section .text, align 4, keep-with-next
    579          static void TwiSM_PdcReceive(void)
    580          {
   \                     TwiSM_PdcReceive: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    581            if( IsTimeUp(&TWI_u32Timer, U32_RX_TIMEOUT_MS) )
   \   00000002   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000006   0x....             LDR.N    R0,??DataTable15_14
   \   00000008   0x.... 0x....      BL       IsTimeUp
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD009             BEQ.N    ??TwiSM_PdcReceive_0
    582            {
    583              TWI_u32Flags |= _TWI_ERROR_RX_TIMEOUT;
   \   00000010   0x....             LDR.N    R0,??DataTable15_9
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0xF050 0x6080      ORRS     R0,R0,#0x4000000
   \   00000018   0x....             LDR.N    R1,??DataTable15_9
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    584              TWI_pfnStateMachine = TwiSM_Error;
   \   0000001C   0x.... 0x....      ADR.W    R0,TwiSM_Error
   \   00000020   0x....             LDR.N    R1,??DataTable15_16
   \   00000022   0x6008             STR      R0,[R1, #+0]
    585            }
    586               
    587          } /* end TwiSM_PdcReceive() */
   \                     ??TwiSM_PdcReceive_0: (+1)
   \   00000024   0xBD01             POP      {R0,PC}          ;; return
    588          
    589          
    590          /*!-------------------------------------------------------------------------------------------------------------------
    591          @fn static void TwiSM_ReceiveLastByte(void)
    592          @brief Wait for RXRDY on the last byte transfer.
    593          */

   \                                 In section .text, align 4, keep-with-next
    594          static void TwiSM_ReceiveLastByte(void)
    595          {
    596            if( TWI_Peripheral0.pBaseAddress->TWI_SR & AT91C_TWI_RXRDY )
   \                     TwiSM_ReceiveLastByte: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_12
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6A00             LDR      R0,[R0, #+32]
   \   00000006   0x0780             LSLS     R0,R0,#+30
   \   00000008   0xD50F             BPL.N    ??TwiSM_ReceiveLastByte_0
    597            {
    598              /* Read the final byte */
    599              *(TWI_psMsgBufferCurrent->pu8RxBuffer + TWI_psMsgBufferCurrent->u32Size - 1) =  TWI_Peripheral0.pBaseAddress->TWI_RHR;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6880             LDR      R0,[R0, #+8]
   \   00000010   0x....             LDR.N    R1,??DataTable15_10
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x6849             LDR      R1,[R1, #+4]
   \   00000016   0x1808             ADDS     R0,R1,R0
   \   00000018   0x....             LDR.N    R1,??DataTable15_12
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x6B09             LDR      R1,[R1, #+48]
   \   0000001E   0xF800 0x1C01      STRB     R1,[R0, #-1]
    600              
    601              TWI_pfnStateMachine = TwiSM_ReceiveComplete;
   \   00000022   0x.... 0x....      ADR.W    R0,TwiSM_ReceiveComplete
   \   00000026   0x....             LDR.N    R1,??DataTable15_16
   \   00000028   0x6008             STR      R0,[R1, #+0]
    602            }
    603            
    604          } /* end TwiSM_ReceiveLastByte() */
   \                     ??TwiSM_ReceiveLastByte_0: (+1)
   \   0000002A   0x4770             BX       LR               ;; return
    605          
    606          
    607          /*!-------------------------------------------------------------------------------------------------------------------
    608          @fn static void TwiSM_ReceiveComplete(void)
    609          @brief Wait for final TXCOMP flag
    610          */

   \                                 In section .text, align 4, keep-with-next
    611          static void TwiSM_ReceiveComplete(void)
    612          {
    613            if(TWI_Peripheral0.pBaseAddress->TWI_SR & AT91C_TWI_TXCOMP_MASTER)
   \                     TwiSM_ReceiveComplete: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_12
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x6A00             LDR      R0,[R0, #+32]
   \   00000006   0x07C0             LSLS     R0,R0,#+31
   \   00000008   0xD50C             BPL.N    ??TwiSM_ReceiveComplete_0
    614            {   
    615              /* Clear RX flag and advance states */
    616              TWI_Peripheral0.u32PrivateFlags &= ~_TWI_RECEIVING;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_12
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000012   0x....             LDR.N    R1,??DataTable15_12
   \   00000014   0x6088             STR      R0,[R1, #+8]
    617              
    618              TWI_u32Timer = U8_NEXT_TRANSFER_DELAY_MS;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable15_14
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    619              TWI_pfnStateMachine = TwiSM_NextTransferDelay;
   \   0000001C   0x.... 0x....      ADR.W    R0,TwiSM_NextTransferDelay
   \   00000020   0x....             LDR.N    R1,??DataTable15_16
   \   00000022   0x6008             STR      R0,[R1, #+0]
    620            }
    621               
    622          } /* end TwiSM_ReceiveComplete() */
   \                     ??TwiSM_ReceiveComplete_0: (+1)
   \   00000024   0x4770             BX       LR               ;; return
    623          
    624          
    625          /*!-------------------------------------------------------------------------------------------------------------------
    626          @fn static void TwiSM_NextTransferDelay(void)
    627          @brief Provide a delay before next transfer starts then do final clean-up before Idle. 
    628          */

   \                                 In section .text, align 4, keep-with-next
    629          static void TwiSM_NextTransferDelay(void)          
    630          {
    631            TWI_u32Timer--;
   \                     TwiSM_NextTransferDelay: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable15_14
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable15_14
   \   00000008   0x6008             STR      R0,[R1, #+0]
    632            
    633            if(TWI_u32Timer == 0)
   \   0000000A   0x....             LDR.N    R0,??DataTable15_14
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD11E             BNE.N    ??TwiSM_NextTransferDelay_0
    634            {
    635              /* Clean up the local message queue (interrupts off, so not critical) */
    636              TWI_u8MsgQueueCount--;
   \   00000012   0x....             LDR.N    R0,??DataTable15_2
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x....             LDR.N    R1,??DataTable15_2
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
    637              TWI_psMsgBufferCurrent++;
   \   0000001C   0x....             LDR.N    R0,??DataTable15_10
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x3010             ADDS     R0,R0,#+16
   \   00000022   0x....             LDR.N    R1,??DataTable15_10
   \   00000024   0x6008             STR      R0,[R1, #+0]
    638              if(TWI_psMsgBufferCurrent == &TWI_asMessageBuffer[U8_TWI_MSG_BUFFER_SIZE])
   \   00000026   0x....             LDR.N    R0,??DataTable15_10
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x....             LDR.N    R1,??DataTable15_4
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD102             BNE.N    ??TwiSM_NextTransferDelay_1
    639              {
    640                TWI_psMsgBufferCurrent = &TWI_asMessageBuffer[0];
   \   00000030   0x....             LDR.N    R0,??DataTable15_5
   \   00000032   0x....             LDR.N    R1,??DataTable15_10
   \   00000034   0x6008             STR      R0,[R1, #+0]
    641              }
    642          
    643              /* Make sure _TWI_INIT_MODE flag is clear if no more messages in case this was a manual cycle */
    644              if(TWI_u8MsgQueueCount == 0)
   \                     ??TwiSM_NextTransferDelay_1: (+1)
   \   00000036   0x....             LDR.N    R0,??DataTable15_2
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD105             BNE.N    ??TwiSM_NextTransferDelay_2
    645              {
    646                TWI_u32Flags &= ~_TWI_INIT_MODE;
   \   0000003E   0x....             LDR.N    R0,??DataTable15_9
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x0840             LSRS     R0,R0,#+1
   \   00000044   0x0040             LSLS     R0,R0,#+1
   \   00000046   0x....             LDR.N    R1,??DataTable15_9
   \   00000048   0x6008             STR      R0,[R1, #+0]
    647              }
    648          
    649              TWI_pfnStateMachine = TwiSM_Idle;
   \                     ??TwiSM_NextTransferDelay_2: (+1)
   \   0000004A   0x....             LDR.N    R0,??DataTable15_23
   \   0000004C   0x....             LDR.N    R1,??DataTable15_16
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    650            }
    651            
    652          } /* TwiSM_NextTransferDelay */
   \                     ??TwiSM_NextTransferDelay_0: (+1)
   \   00000050   0x4770             BX       LR               ;; return
    653          
    654          
    655          /*!-------------------------------------------------------------------------------------------------------------------
    656          @fn static void TwiSM_Error(void)
    657          @brief Handle an error 
    658          */

   \                                 In section .text, align 4, keep-with-next
    659          static void TwiSM_Error(void)          
    660          {
   \                     TwiSM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    661            /* NACK recieved (write only) */
    662            if(TWI_u32Flags & _TWI_ERROR_NACK)
   \   00000002   0x....             LDR.N    R0,??DataTable15_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x01C0             LSLS     R0,R0,#+7
   \   00000008   0xD51C             BPL.N    ??TwiSM_Error_0
    663            {
    664              /* Announce the error and clear flag */
    665              TWI_u32Flags &= ~_TWI_ERROR_NACK;
   \   0000000A   0x....             LDR.N    R0,??DataTable15_9
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0xF030 0x7080      BICS     R0,R0,#0x1000000
   \   00000012   0x....             LDR.N    R1,??DataTable15_9
   \   00000014   0x6008             STR      R0,[R1, #+0]
    666              DebugPrintNumber(TWI_Peripheral0.pTransmitBuffer->u32Token);
   \   00000016   0x....             LDR.N    R0,??DataTable15_12
   \   00000018   0x6840             LDR      R0,[R0, #+4]
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x.... 0x....      BL       DebugPrintNumber
    667              DebugPrintf(" TWI NACK. Message deleted.\n\r");
   \   00000020   0x....             LDR.N    R0,??DataTable15_24
   \   00000022   0x.... 0x....      BL       DebugPrintf
    668              
    669              /* Clear flags and clean up the Message task message */
    670              UpdateMessageStatus(TWI_Peripheral0.pTransmitBuffer->u32Token, FAILED);
   \   00000026   0x2106             MOVS     R1,#+6
   \   00000028   0x....             LDR.N    R0,??DataTable15_12
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x.... 0x....      BL       UpdateMessageStatus
    671              DeQueueMessage(&TWI_Peripheral0.pTransmitBuffer);
   \   00000032   0x....             LDR.N    R0,??DataTable15_7
   \   00000034   0x.... 0x....      BL       DeQueueMessage
    672              TWI_Peripheral0.u32PrivateFlags &= ~(_TWI_TRANSMITTING | _TWI_TRANS_NOT_COMP);
   \   00000038   0x....             LDR.N    R0,??DataTable15_12
   \   0000003A   0x6880             LDR      R0,[R0, #+8]
   \   0000003C   0xF030 0x0005      BICS     R0,R0,#0x5
   \   00000040   0x....             LDR.N    R1,??DataTable15_12
   \   00000042   0x6088             STR      R0,[R1, #+8]
    673            }
    674            
    675            /* RX TIMEOUT (receive only) */
    676            if(TWI_u32Flags & _TWI_ERROR_RX_TIMEOUT)
   \                     ??TwiSM_Error_0: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable15_9
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x0140             LSLS     R0,R0,#+5
   \   0000004A   0xD502             BPL.N    ??TwiSM_Error_1
    677            {
    678              DebugPrintf("TWI Rx Timeout. Message deleted.\n\r");
   \   0000004C   0x....             LDR.N    R0,??DataTable15_25
   \   0000004E   0x.... 0x....      BL       DebugPrintf
    679            }  
    680          
    681            /* Advance states */
    682            TWI_u32Timer = U8_NEXT_TRANSFER_DELAY_MS;
   \                     ??TwiSM_Error_1: (+1)
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x....             LDR.N    R1,??DataTable15_14
   \   00000056   0x6008             STR      R0,[R1, #+0]
    683            TWI_pfnStateMachine = TwiSM_NextTransferDelay;
   \   00000058   0x....             LDR.N    R0,??DataTable15_26
   \   0000005A   0x....             LDR.N    R1,??DataTable15_16
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    684          
    685          } /* end TwiSM_Error() */
   \   0000005E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     TWI_u8MsgQueueCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     TWI_psMsgBufferNext

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     TWI_asMessageBuffer+0x200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     TWI_asMessageBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     TWI_Peripheral0+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     TWI_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x........         DC32     TWI_psMsgBufferCurrent

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x40084000         DC32     0x40084000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     TWI_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x........         DC32     TWI_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x00021D1D         DC32     0x21d1d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x........         DC32     TWI_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0xA5000001         DC32     0xa5000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x400E1250         DC32     0x400e1250

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x4008402C         DC32     0x4008402c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x40084020         DC32     0x40084020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0x........         DC32     TwiSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_26:
   \   00000000   0x........         DC32     TwiSM_NextTransferDelay

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x54 0x57          DC8 "TWI Peripheral Ready\012\015"
   \              0x49 0x20    
   \              0x50 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x61 0x6C    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x0A 0x0D    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x57          DC8 "TWI transmit message out of sync!\012\015"
   \              0x49 0x20    
   \              0x74 0x72    
   \              0x61 0x6E    
   \              0x73 0x6D    
   \              0x69 0x74    
   \              0x20 0x6D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x21 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x20 0x54          DC8 " TWI NACK. Message deleted.\012\015"
   \              0x57 0x49    
   \              0x20 0x4E    
   \              0x41 0x43    
   \              0x4B 0x2E    
   \              0x20 0x4D    
   \              0x65 0x73    
   \              0x73 0x61    
   \              0x67 0x65    
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x65 0x74    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x54 0x57          DC8 "TWI Rx Timeout. Message deleted.\012\015"
   \              0x49 0x20    
   \              0x52 0x78    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x6F    
   \              0x75 0x74    
   \              0x2E 0x20    
   \              0x4D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x64 0x65    
   \              0x6C 0x65    
   \              0x74 0x65    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0
    686          
    687          
    688          
    689          /*--------------------------------------------------------------------------------------------------------------------*/
    690          /* End of File */
    691          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ
       0   TWI0_IrqHandler
       8   TwiInitialize
         8   -> DebugPrintf
         8   -> IsTimeUp
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_EnableIRQ
       8   TwiManualMode
         8   -- Indirect call
         8   -> DebugRunActiveState
         8   -> IsTimeUp
         8   -> MessagingRunActiveState
      16   TwiReadData
        16   -> TwiManualMode
       8   TwiRunActiveState
         8   -- Indirect call
       8   TwiSM_Error
         8   -> DeQueueMessage
         8   -> DebugPrintNumber
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       8   TwiSM_Idle
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       0   TwiSM_NextTransferDelay
       8   TwiSM_PdcReceive
         8   -> IsTimeUp
       0   TwiSM_ReceiveComplete
       0   TwiSM_ReceiveLastByte
       8   TwiSM_Transmit
         8   -> DeQueueMessage
         8   -> UpdateMessageStatus
       0   TwiSM_TxWaitComplete
      24   TwiWriteData
        24   -> QueueMessage
        24   -> TwiManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      24  ?_0
      36  ?_1
      32  ?_2
      36  ?_3
      22  NVIC_ClearPendingIRQ
      22  NVIC_EnableIRQ
     202  TWI0_IrqHandler
      12  TWI_Peripheral0
     512  TWI_asMessageBuffer
       4  TWI_pfnStateMachine
       4  TWI_psMsgBufferCurrent
       4  TWI_psMsgBufferNext
       4  TWI_u32Flags
       4  TWI_u32Timer
       1  TWI_u8MsgQueueCount
     298  TwiInitialize
      78  TwiManualMode
     210  TwiReadData
      12  TwiRunActiveState
      96  TwiSM_Error
     352  TwiSM_Idle
      82  TwiSM_NextTransferDelay
      38  TwiSM_PdcReceive
      38  TwiSM_ReceiveComplete
      44  TwiSM_ReceiveLastByte
      64  TwiSM_Transmit
      38  TwiSM_TxWaitComplete
     240  TwiWriteData

 
   545 bytes in section .bss
   128 bytes in section .rodata
 1 944 bytes in section .text
 
 1 944 bytes of CODE  memory
   128 bytes of CONST memory
   545 bytes of DATA  memory

Errors: none
Warnings: none
