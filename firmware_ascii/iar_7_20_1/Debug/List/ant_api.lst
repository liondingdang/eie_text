###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant_api.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant_api.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ant_api.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ant_api.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\ant_api.c
      1          /*!**********************************************************************************************************************
      2          @file ant_api.c   
      3          @brief ANT user interface.  No initialization or state machine required.  
      4          
      5          This file holds the source code for all public functions that work with ant.c.  
      6          
      7          Once the ANT radio has been configured, all messaging from the ANT device is handled through 
      8          the incoming queue G_psAntApplicationMsgList.  The application is responsible for checking this
      9          queue for messages that belong to it and must manage timing and handle appropriate updates per 
     10          the ANT messaging protocol.  This should be no problem on the regular 1ms loop timing of the main 
     11          system (assuming ANT message rate is less than 1kHz).  Faster systems or burst messaging will need 
     12          to be handled seperately as an add-on to this API.
     13          
     14          Copy the following definitions to your client task:
     15            
     16          // Globals for passing data from the ANT application to the API
     17          
     18          extern u32 G_u32AntApiCurrentMessageTimeStamp;                            // From ant_api.c
     19          
     20          extern AntApplicationMessageType G_eAntApiCurrentMessageClass;            // From ant_api.c
     21          
     22          extern u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];  // From ant_api.c
     23          
     24          extern AntExtendedDataType G_sAntApiCurrentMessageExtData;                // From ant_api.c
     25          
     26          
     27          ------------------------------------------------------------------------------------------------------------------------
     28          GLOBALS
     29          - u32 G_u32AntApiCurrentMessageTimeStamp
     30          - AntApplicationMessageType G_eAntApiCurrentMessageClass
     31          - u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES]
     32          - AntExtendedDataType G_sAntApiCurrentMessageExtData
     33          
     34          CONSTANTS
     35          - NONE
     36          
     37          TYPES
     38          - NONE (see ant.h for all types used)
     39          
     40          
     41          PUBLIC ANT CONFIGURATION / STATUS FUNCTIONS
     42          - AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
     43          - bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
     44          - bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
     45          - bool AntOpenChannelNumber(AntChannelNumberType eAntChannelToOpen)
     46          - bool AntCloseChannelNumber(AntChannelNumberType eAntChannelToClose)
     47          - bool AntOpenScanningChannel(void)
     48          
     49          
     50          PUBLIC ANT DATA FUNCTIONS
     51          - bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
     52          - bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
     53          - bool AntReadAppMessageBuffer(void)
     54          
     55          PROTECTED FUNCTIONS
     56          - void AntApiInitialize(void)
     57          - void AntApiRunActiveState(void)
     58          
     59          
     60          ***********************************************************************************************************************/
     61          
     62          #include "configuration.h"
     63          
     64          /***********************************************************************************************************************
     65          Global variable definitions with scope across entire project.
     66          All Global variable names shall start with "G_<type>AntApi"
     67          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     68          volatile u32 G_u32AntApiFlags;                                      /*!< @brief Global state flags */
   \                     G_u32AntApiFlags:
   \   00000000                      DS8 4
     69          

   \                                 In section .bss, align 4
     70          u32 G_u32AntApiCurrentMessageTimeStamp = 0;                         /*!< @brief Current read message's G_u32SystemTime1ms */
   \                     G_u32AntApiCurrentMessageTimeStamp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     71          AntApplicationMessageType G_eAntApiCurrentMessageClass = ANT_EMPTY; /*!< @brief Type of data */
   \                     G_eAntApiCurrentMessageClass:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     72          u8 G_au8AntApiCurrentMessageBytes[ANT_APPLICATION_MESSAGE_BYTES];   /*!< @brief Array for message payload data */
   \                     G_au8AntApiCurrentMessageBytes:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     73          AntExtendedDataType G_sAntApiCurrentMessageExtData;                 /*!< @brief Extended data struct for the current message */
   \                     G_sAntApiCurrentMessageExtData:
   \   00000000                      DS8 8
     74          
     75          
     76          /*----------------------------------------------------------------------------*/
     77          /* Existing variables (defined in other files -- should all contain the "extern" keyword) 
     78          and indicate what file the variable is defined in. */
     79          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     80          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     81          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     82          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
     83          
     84          extern u32 G_u32AntFlags;                                     /* From ant.c */
     85          extern AntApplicationMsgListType *G_psAntApplicationMsgList;  /* From ant.c */
     86          extern AntAssignChannelInfoType G_asAntChannelConfiguration[ANT_NUM_CHANNELS]; /* From ant.c */
     87          extern AntMessageResponseType G_stAntMessageResponse;         /* From ant.c */
     88          
     89          extern u8 G_au8AntMessageOk[];                                /* From ant.c */
     90          extern u8 G_au8AntMessageFail[];                              /* From ant.c */
     91          extern u8 G_au8AntMessageAssign[];                            /* From ant.c */
     92          extern u8 G_au8AntMessageUnassign[];                          /* From ant.c */
     93          extern u8 G_au8AntMessageUnhandled[];                         /* From ant.c */
     94          extern u8 G_au8AntMessageSetup[];                             /* From ant.c */
     95          extern u8 G_au8AntMessageClose[];                             /* From ant.c */
     96          extern u8 G_au8AntMessageOpen[];                              /* From ant.c */
     97          extern u8 G_au8AntMessageInit[];                              /* From ant.c */
     98          extern u8 G_au8AntMessageInitFail[];                          /* From ant.c */
     99          extern u8 G_au8AntMessageNoAnt[];                             /* From ant.c */
    100          
    101          extern u8 G_au8AntSetNetworkKey[];                            /* From ant.c */
    102          extern u8 G_au8AntAssignChannel[];                            /* From ant.c */
    103          extern u8 G_au8AntSetChannelID[];                             /* From ant.c */
    104          extern u8 G_au8AntSetChannelPeriod[];                         /* From ant.c */
    105          extern u8 G_au8AntSetChannelRFFreq[];                         /* From ant.c */
    106          extern u8 G_au8AntSetChannelPower[];                          /* From ant.c */
    107          extern u8 G_au8AntSetSearchTimeout[];                         /* From ant.c */
    108          extern u8 G_au8AntLibConfig[];                                /* From ant.c */
    109          
    110          extern u8 G_au8AntBroadcastDataMessage[];                     /* From ant.c */
    111          extern u8 G_au8AntAckDataMessage[];                           /* From ant.c */
    112          
    113          
    114          /***********************************************************************************************************************
    115          Global variable definitions with scope limited to this local application.
    116          Variable names shall start with "AntApi_<type>Name" and be declared as static.
    117          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    118          static fnCode_type AntApi_StateMachine;             /*!< @brief The state machine function pointer */
   \                     AntApi_StateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    119          static u32 AntApi_u32Timeout;                       /*!< @brief Timeout counter used across states */
   \                     AntApi_u32Timeout:
   \   00000000                      DS8 4
    120          

   \                                 In section .data, align 4
    121          static u8* AntApi_apu8AntAssignChannel[] = {G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel, G_au8AntSetChannelID, 
   \                     AntApi_apu8AntAssignChannel:
   \   00000000   0x........         DC32 G_au8AntSetNetworkKey, G_au8AntLibConfig, G_au8AntAssignChannel
   \              0x........   
   \              0x........   
   \   0000000C   0x........         DC32 G_au8AntSetChannelID, G_au8AntSetChannelPeriod
   \              0x........   
   \   00000014   0x........         DC32 G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower
   \              0x........   
   \   0000001C   0x........         DC32 G_au8AntSetSearchTimeout
    122                                                      G_au8AntSetChannelPeriod, G_au8AntSetChannelRFFreq, G_au8AntSetChannelPower,
    123                                                      G_au8AntSetSearchTimeout
    124                                                     };       /*!< @brief Message for channel assignment.  Set ANT_ASSIGN_MESSAGES for number of messages. */
    125              
    126          
    127          /***********************************************************************************************************************
    128          Function Definitions
    129          ***********************************************************************************************************************/
    130          
    131          /*--------------------------------------------------------------------------------------------------------------------*/
    132          /*! @publicsection */                                                                                            
    133          /*--------------------------------------------------------------------------------------------------------------------*/
    134          
    135          /*!---------------------------------------------------------------------------------------------------------------------
    136          @fn bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
    137          
    138          @brief Updates all configuration messages to completely configure an ANT channel with an application's 
    139          required parameters for communication.  
    140          
    141          The application should monitor AntRadioStatusChannel()
    142          to see if all of the configuration messages are sent and the channel is configured properly.
    143          
    144          e.g.
    145            AntAssignChannelInfoType sChannelInfo;
    146          
    147            if(AntRadioStatusChannel(ANT_CHANNEL_0) == ANT_UNCONFIGURED)
    148            {
    149              sChannelInfo.AntChannel = ANT_CHANNEL_0;
    150              sChannelInfo.AntChannelType = CHANNEL_TYPE_MASTER;
    151              sChannelInfo.AntChannelPeriodHi = ANT_CHANNEL_PERIOD_HI_DEFAULT;
    152              sChannelInfo.AntChannelPeriodLo = ANT_CHANNEL_PERIOD_LO_DEFAULT;
    153              
    154              sChannelInfo.AntDeviceIdHi = 0x00;
    155              sChannelInfo.AntDeviceIdLo = 0x01;
    156              sChannelInfo.AntDeviceType = ANT_DEVICE_TYPE_DEFAULT;
    157              sChannelInfo.AntTransmissionType = ANT_TRANSMISSION_TYPE_DEFAULT;
    158              
    159              sChannelInfo.AntFrequency = ANT_FREQUENCY_DEFAULT;
    160              sChannelInfo.AntTxPower = ANT_TX_POWER_DEFAULT;
    161              
    162              sChannelInfo.AntNetwork = ANT_NETWORK_DEFAULT;
    163              for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
    164              {
    165                sChannelInfo.AntNetworkKey[i] = ANT_DEFAULT_NETWORK_KEY;
    166              }
    167              
    168              AntAssignChannel(&sChannelInfo);
    169            }
    170          
    171            // Go to a wait state that exits when AntRadioStatusChannel(ANT_CHANNEL_0) no longer returns ANT_UNCONFIGURED)
    172          
    173          Requires:
    174          - The ANT channel should not be currently assigned.
    175          
    176          @param psAntSetupInfo_ points to a complete AntAssignChannelInfoType with all the required channel information.
    177          
    178          Promises:
    179          - Channel, Channel ID, message period, radio frequency and radio power are configured.
    180          - Returns TRUE if the channel is ready to be set up; all global setup messages are updated with the values
    181            from psAntSetupInfo; 
    182          - Returns FALSE if the channel is already configured
    183          
    184          */

   \                                 In section .text, align 2, keep-with-next
    185          bool AntAssignChannel(AntAssignChannelInfoType* psAntSetupInfo_)
    186          {
   \                     AntAssignChannel: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    187            /* Check to ensure the selected channel is available */
    188            if(AntRadioStatusChannel(psAntSetupInfo_->AntChannel) != ANT_UNCONFIGURED)
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       AntRadioStatusChannel
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD005             BEQ.N    ??AntAssignChannel_0
    189            {
    190              DebugPrintf("AntAssignChannel error: channel is not unconfigured\n\r");
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable11
   \   00000012   0x.... 0x....      BL       DebugPrintf
    191              return FALSE;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xE0F1             B.N      ??AntAssignChannel_1
    192            }
    193            
    194            /* Setup the library config message (for extended data) - use defaults for now */
    195            G_au8AntLibConfig[4] = AntCalculateTxChecksum(G_au8AntLibConfig);
   \                     ??AntAssignChannel_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable11_1
   \   0000001E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable11_1
   \   00000026   0x7108             STRB     R0,[R1, #+4]
    196          
    197            /* Set Network key message */
    198            G_au8AntSetNetworkKey[2] = psAntSetupInfo_->AntNetwork;
   \   00000028   0x78A0             LDRB     R0,[R4, #+2]
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   0000002E   0x7088             STRB     R0,[R1, #+2]
    199            for(u8 i = 0; i < ANT_NETWORK_NUMBER_BYTES; i++)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??AntAssignChannel_2: (+1)
   \   00000032   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000034   0x2808             CMP      R0,#+8
   \   00000036   0xDA15             BGE.N    ??AntAssignChannel_3
    200            {
    201              G_au8AntSetNetworkKey[i + 3] = psAntSetupInfo_->AntNetworkKey[i];
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0x1901             ADDS     R1,R0,R4
   \   0000003C   0x78C9             LDRB     R1,[R1, #+3]
   \   0000003E   0x.... 0x....      LDR.W    R2,??DataTable11_2
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x1882             ADDS     R2,R0,R2
   \   00000046   0x70D1             STRB     R1,[R2, #+3]
    202              G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetworkKey[i] = psAntSetupInfo_->AntNetworkKey[i];
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000004C   0x7822             LDRB     R2,[R4, #+0]
   \   0000004E   0x2314             MOVS     R3,#+20
   \   00000050   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000054   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000056   0x1841             ADDS     R1,R0,R1
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x1902             ADDS     R2,R0,R4
   \   0000005C   0x78D2             LDRB     R2,[R2, #+3]
   \   0000005E   0x70CA             STRB     R2,[R1, #+3]
    203            }
   \   00000060   0x1C40             ADDS     R0,R0,#+1
   \   00000062   0xE7E6             B.N      ??AntAssignChannel_2
    204            G_au8AntSetNetworkKey[11] = AntCalculateTxChecksum(G_au8AntSetNetworkKey);
   \                     ??AntAssignChannel_3: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable11_2
   \   00000068   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable11_2
   \   00000070   0x72C8             STRB     R0,[R1, #+11]
    205              
    206            /* Setup the channel message */
    207            G_au8AntAssignChannel[2] = psAntSetupInfo_->AntChannel;
   \   00000072   0x7820             LDRB     R0,[R4, #+0]
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000078   0x7088             STRB     R0,[R1, #+2]
    208            G_au8AntAssignChannel[3] = psAntSetupInfo_->AntChannelType;
   \   0000007A   0x7860             LDRB     R0,[R4, #+1]
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000080   0x70C8             STRB     R0,[R1, #+3]
    209            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelType = psAntSetupInfo_->AntChannelType;
   \   00000082   0x7860             LDRB     R0,[R4, #+1]
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000088   0x7822             LDRB     R2,[R4, #+0]
   \   0000008A   0x2314             MOVS     R3,#+20
   \   0000008C   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000090   0x7048             STRB     R0,[R1, #+1]
    210          
    211            G_au8AntAssignChannel[4] = psAntSetupInfo_->AntNetwork;
   \   00000092   0x78A0             LDRB     R0,[R4, #+2]
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   00000098   0x7108             STRB     R0,[R1, #+4]
    212            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntNetwork = psAntSetupInfo_->AntNetwork;
   \   0000009A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000A0   0x7822             LDRB     R2,[R4, #+0]
   \   000000A2   0x2314             MOVS     R3,#+20
   \   000000A4   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000A8   0x7088             STRB     R0,[R1, #+2]
    213          
    214            G_au8AntAssignChannel[5] = AntCalculateTxChecksum(G_au8AntAssignChannel);
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable11_4
   \   000000AE   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable11_4
   \   000000B6   0x7148             STRB     R0,[R1, #+5]
    215          
    216            /* Setup the channel ID message */
    217            G_au8AntSetChannelID[2] = psAntSetupInfo_->AntChannel;
   \   000000B8   0x7820             LDRB     R0,[R4, #+0]
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000BE   0x7088             STRB     R0,[R1, #+2]
    218            G_au8AntSetChannelID[3] = psAntSetupInfo_->AntDeviceIdLo;
   \   000000C0   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000C6   0x70C8             STRB     R0,[R1, #+3]
    219            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdLo = psAntSetupInfo_->AntDeviceIdLo;
   \   000000C8   0x7AE0             LDRB     R0,[R4, #+11]
   \   000000CA   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000CE   0x7822             LDRB     R2,[R4, #+0]
   \   000000D0   0x2314             MOVS     R3,#+20
   \   000000D2   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000D6   0x72C8             STRB     R0,[R1, #+11]
    220          
    221            G_au8AntSetChannelID[4] = psAntSetupInfo_->AntDeviceIdHi;
   \   000000D8   0x7B20             LDRB     R0,[R4, #+12]
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000DE   0x7108             STRB     R0,[R1, #+4]
    222            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceIdHi = psAntSetupInfo_->AntDeviceIdHi;
   \   000000E0   0x7B20             LDRB     R0,[R4, #+12]
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000E6   0x7822             LDRB     R2,[R4, #+0]
   \   000000E8   0x2314             MOVS     R3,#+20
   \   000000EA   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000000EE   0x7308             STRB     R0,[R1, #+12]
    223          
    224            G_au8AntSetChannelID[5] = psAntSetupInfo_->AntDeviceType;
   \   000000F0   0x7B60             LDRB     R0,[R4, #+13]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   000000F6   0x7148             STRB     R0,[R1, #+5]
    225            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntDeviceType = psAntSetupInfo_->AntDeviceType;
   \   000000F8   0x7B60             LDRB     R0,[R4, #+13]
   \   000000FA   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000FE   0x7822             LDRB     R2,[R4, #+0]
   \   00000100   0x2314             MOVS     R3,#+20
   \   00000102   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000106   0x7348             STRB     R0,[R1, #+13]
    226          
    227            G_au8AntSetChannelID[6] = psAntSetupInfo_->AntTransmissionType;
   \   00000108   0x7BA0             LDRB     R0,[R4, #+14]
   \   0000010A   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   0000010E   0x7188             STRB     R0,[R1, #+6]
    228            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTransmissionType = psAntSetupInfo_->AntTransmissionType;
   \   00000110   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000112   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000116   0x7822             LDRB     R2,[R4, #+0]
   \   00000118   0x2314             MOVS     R3,#+20
   \   0000011A   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000011E   0x7388             STRB     R0,[R1, #+14]
    229          
    230            G_au8AntSetChannelID[7] = AntCalculateTxChecksum(G_au8AntSetChannelID);
   \   00000120   0x.... 0x....      LDR.W    R0,??DataTable11_5
   \   00000124   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000128   0x.... 0x....      LDR.W    R1,??DataTable11_5
   \   0000012C   0x71C8             STRB     R0,[R1, #+7]
    231              
    232            /* Setup the channel period message */
    233            G_au8AntSetChannelPeriod[2] = psAntSetupInfo_->AntChannel;
   \   0000012E   0x7820             LDRB     R0,[R4, #+0]
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000134   0x7088             STRB     R0,[R1, #+2]
    234            G_au8AntSetChannelPeriod[3] = psAntSetupInfo_->AntChannelPeriodLo;
   \   00000136   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   0000013C   0x70C8             STRB     R0,[R1, #+3]
    235            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodLo = psAntSetupInfo_->AntChannelPeriodLo;
   \   0000013E   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000140   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000144   0x7822             LDRB     R2,[R4, #+0]
   \   00000146   0x2314             MOVS     R3,#+20
   \   00000148   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   0000014C   0x73C8             STRB     R0,[R1, #+15]
    236          
    237            G_au8AntSetChannelPeriod[4] = psAntSetupInfo_->AntChannelPeriodHi;
   \   0000014E   0x7C20             LDRB     R0,[R4, #+16]
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000154   0x7108             STRB     R0,[R1, #+4]
    238            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntChannelPeriodHi = psAntSetupInfo_->AntChannelPeriodHi;
   \   00000156   0x7C20             LDRB     R0,[R4, #+16]
   \   00000158   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000015C   0x7822             LDRB     R2,[R4, #+0]
   \   0000015E   0x2314             MOVS     R3,#+20
   \   00000160   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000164   0x7408             STRB     R0,[R1, #+16]
    239          
    240            G_au8AntSetChannelPeriod[5] = AntCalculateTxChecksum(G_au8AntSetChannelPeriod);
   \   00000166   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   0000016A   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000016E   0x.... 0x....      LDR.W    R1,??DataTable11_6
   \   00000172   0x7148             STRB     R0,[R1, #+5]
    241              
    242            /* Setup the channel frequency message */
    243            G_au8AntSetChannelRFFreq[2] = psAntSetupInfo_->AntChannel;
   \   00000174   0x7820             LDRB     R0,[R4, #+0]
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   0000017A   0x7088             STRB     R0,[R1, #+2]
    244            G_au8AntSetChannelRFFreq[3] = psAntSetupInfo_->AntFrequency;
   \   0000017C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000017E   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   00000182   0x70C8             STRB     R0,[R1, #+3]
    245            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntFrequency = psAntSetupInfo_->AntFrequency;
   \   00000184   0x7C60             LDRB     R0,[R4, #+17]
   \   00000186   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000018A   0x7822             LDRB     R2,[R4, #+0]
   \   0000018C   0x2314             MOVS     R3,#+20
   \   0000018E   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000192   0x7448             STRB     R0,[R1, #+17]
    246          
    247            G_au8AntSetChannelRFFreq[4] = AntCalculateTxChecksum(G_au8AntSetChannelRFFreq);
   \   00000194   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   00000198   0x.... 0x....      BL       AntCalculateTxChecksum
   \   0000019C   0x.... 0x....      LDR.W    R1,??DataTable11_7
   \   000001A0   0x7108             STRB     R0,[R1, #+4]
    248          
    249            /* Setup the channel power message */
    250            G_au8AntSetChannelPower[3] = psAntSetupInfo_->AntTxPower;
   \   000001A2   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001A4   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001A8   0x70C8             STRB     R0,[R1, #+3]
    251            G_asAntChannelConfiguration[psAntSetupInfo_->AntChannel].AntTxPower = psAntSetupInfo_->AntTxPower;
   \   000001AA   0x7CA0             LDRB     R0,[R4, #+18]
   \   000001AC   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000001B0   0x7822             LDRB     R2,[R4, #+0]
   \   000001B2   0x2314             MOVS     R3,#+20
   \   000001B4   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   000001B8   0x7488             STRB     R0,[R1, #+18]
    252          
    253            G_au8AntSetChannelPower[4] = AntCalculateTxChecksum(G_au8AntSetChannelPower);
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable11_8
   \   000001BE   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000001C2   0x.... 0x....      LDR.W    R1,??DataTable11_8
   \   000001C6   0x7108             STRB     R0,[R1, #+4]
    254               
    255            /* Setup the the channel search timeout (currently set at default for infinite search) */
    256            G_au8AntSetSearchTimeout[2] = psAntSetupInfo_->AntChannel;
   \   000001C8   0x7820             LDRB     R0,[R4, #+0]
   \   000001CA   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \   000001CE   0x7088             STRB     R0,[R1, #+2]
    257            G_au8AntSetSearchTimeout[3] = ANT_INFINITE_SEARCH_TIMEOUT;
   \   000001D0   0x20FF             MOVS     R0,#+255
   \   000001D2   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \   000001D6   0x70C8             STRB     R0,[R1, #+3]
    258          
    259            G_au8AntSetSearchTimeout[4] = AntCalculateTxChecksum(G_au8AntSetSearchTimeout);
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable11_9
   \   000001DC   0x.... 0x....      BL       AntCalculateTxChecksum
   \   000001E0   0x.... 0x....      LDR.W    R1,??DataTable11_9
   \   000001E4   0x7108             STRB     R0,[R1, #+4]
    260            
    261            /* Set the next state to begin transferring */
    262            AntApi_u32Timeout = G_u32SystemTime1ms;
   \   000001E6   0x.... 0x....      LDR.W    R0,??DataTable11_10
   \   000001EA   0x6800             LDR      R0,[R0, #+0]
   \   000001EC   0x.... 0x....      LDR.W    R1,??DataTable11_11
   \   000001F0   0x6008             STR      R0,[R1, #+0]
    263            AntApi_StateMachine = AntApiSM_AssignChannel;
   \   000001F2   0x.... 0x....      ADR.W    R0,AntApiSM_AssignChannel
   \   000001F6   0x.... 0x....      LDR.W    R1,??DataTable11_12
   \   000001FA   0x6008             STR      R0,[R1, #+0]
    264            return TRUE;
   \   000001FC   0x2001             MOVS     R0,#+1
   \                     ??AntAssignChannel_1: (+1)
   \   000001FE   0xBD10             POP      {R4,PC}          ;; return
    265          
    266          } /* end AntAssignChannel() */
    267          
    268          
    269          /*!---------------------------------------------------------------------------------------------------------------------
    270          @fn bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
    271          
    272          @brief Queues message to unassign the specified ANT channel so it can be reconfigured.
    273          
    274           
    275          Requires:
    276          - ANT channel is closed
    277          
    278          @param eChannel_ is the channel to unassign
    279          
    280          Promises:
    281          - ANT channel unassign message is queued; application should monitor AntRadioStatus()
    282          
    283          */

   \                                 In section .text, align 2, keep-with-next
    284          bool AntUnassignChannelNumber(AntChannelNumberType eChannel_)
    285          {
   \                     AntUnassignChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    286            u8 au8AntUnassignChannel[] = {MESG_UNASSIGN_CHANNEL_SIZE, MESG_UNASSIGN_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_13
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    287          
    288            /* Check if the channel is closed */
    289            if(AntRadioStatusChannel(eChannel_) != ANT_CLOSED)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       AntRadioStatusChannel
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??AntUnassignChannelNumber_0
    290            {
    291              DebugPrintf("AntUnssignChannel error: channel not closed\n\r");
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable11_14
   \   00000020   0x.... 0x....      BL       DebugPrintf
    292              return FALSE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE009             B.N      ??AntUnassignChannelNumber_1
    293            }
    294            
    295            /* Update the channel number */
    296             au8AntUnassignChannel[2] = eChannel_;
   \                     ??AntUnassignChannelNumber_0: (+1)
   \   00000028   0xF88D 0x4002      STRB     R4,[SP, #+2]
    297          
    298            /* Update checksum and queue the unassign channel message */
    299            au8AntUnassignChannel[3] = AntCalculateTxChecksum(au8AntUnassignChannel);
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000032   0xF88D 0x0003      STRB     R0,[SP, #+3]
    300            return( AntQueueOutgoingMessage(au8AntUnassignChannel) );
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x.... 0x....      BL       AntQueueOutgoingMessage
   \                     ??AntUnassignChannelNumber_1: (+1)
   \   0000003C   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    301          
    302          } /* end AntUnassignChannelNumber() */
    303          
    304          
    305          /*!---------------------------------------------------------------------------------------------------------------------
    306          @fn bool AntOpenChannelNumber(AntChannelNumberType eChannel_)
    307          
    308          @brief Queues a request to open the specified channel.
    309          
    310          Queues the Open Channel message on the configured ANT channel.  This does not actually indicate
    311          that the channel has been opened successfully -- the calling task must monitor _ANT_FLAGS_CHANNEL_OPEN
    312          to determine if channel opens successfully.
    313          
    314          Returns TRUE if the channel is configured and the message is successfully queued - this can be ignored or checked.  
    315          Application should monitor AntRadioStatusChannel() for actual channel status.
    316          
    317          e.g.
    318          AntChannelStatusType eAntCurrentState;
    319          
    320          // Request to open channel only on an already closed channel.
    321          eAntCurrentState = AntChannelStatus(ANT_CHANNEL_1);
    322          
    323          if(eAntCurrentState == ANT_CLOSED )
    324          {
    325             AntOpenChannelNumber(ANT_CHANNEL_1);
    326          }
    327          
    328          Requires:
    329          - ANT channel to open should already be correctly configured.
    330          
    331          @param eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    332          
    333          Promises:
    334          - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    335          - Otherwise returns FALSE
    336           
    337          */

   \                                 In section .text, align 2, keep-with-next
    338          bool AntOpenChannelNumber(AntChannelNumberType eChannel_)
    339          {
   \                     AntOpenChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    340            u8 au8AntOpenChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_15
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    341            
    342            /* Check if the channel is ready */
    343            if(AntRadioStatusChannel(eChannel_) != ANT_CONFIGURED)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       AntRadioStatusChannel
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD005             BEQ.N    ??AntOpenChannelNumber_0
    344            {
    345              DebugPrintf("AntOpenChannel error: channel not ready\n\r");
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable11_16
   \   00000020   0x.... 0x....      BL       DebugPrintf
    346              return FALSE;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE01C             B.N      ??AntOpenChannelNumber_1
    347            }
    348          
    349            /* Update the channel number in the message for a regular channel */
    350            if(eChannel_ != ANT_CHANNEL_SCANNING)
   \                     ??AntOpenChannelNumber_0: (+1)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C00             CMP      R4,#+0
   \   0000002C   0xD001             BEQ.N    ??AntOpenChannelNumber_2
    351            {
    352              au8AntOpenChannel[2] = eChannel_;
   \   0000002E   0xF88D 0x4002      STRB     R4,[SP, #+2]
    353            }
    354          
    355            /* Update the checksum value and queue the open channel message */
    356            au8AntOpenChannel[3] = AntCalculateTxChecksum(au8AntOpenChannel);
   \                     ??AntOpenChannelNumber_2: (+1)
   \   00000032   0xA800             ADD      R0,SP,#+0
   \   00000034   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000038   0xF88D 0x0003      STRB     R0,[SP, #+3]
    357            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2114             MOVS     R1,#+20
   \   00000044   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   00000048   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000004A   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000052   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000005A   0x74C8             STRB     R0,[R1, #+19]
    358           
    359            return( AntQueueOutgoingMessage(au8AntOpenChannel) );
   \   0000005C   0xA800             ADD      R0,SP,#+0
   \   0000005E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \                     ??AntOpenChannelNumber_1: (+1)
   \   00000062   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    360            
    361          } /* end AntOpenChannelNumber() */
    362          
    363          
    364          /*!---------------------------------------------------------------------------------------------------------------------
    365          @fn bool AntOpenScanningChannel(void)
    366          
    367          
    368          @brief Queues a request to open a scanning channel. 
    369          
    370          Queues the Open Scan Channel message.  Scanning channels must use Channel 0
    371          and takes all channel resources.  It is up to the user to ensure
    372          that the device is configured properly.  Attempting to open a scanning channel
    373          when other channels are already open will result in a failure.
    374          
    375          Returns TRUE if message is successfully queued - this can be ignored or checked.  
    376          Application should monitor AntRadioStatusChannel() for actual channel status.
    377          
    378          e.g.
    379          AntChannelStatusType eAntCurrentState;
    380          
    381          // Request to open channel only on an already closed channel.
    382          if(AntRadioStatusChannel(ANT_CHANNEL_SCANNING) == ANT_CLOSED )
    383          {
    384             AntOpenScanningChannel();
    385          }
    386          
    387          Requires:
    388          - ANT channel 0 should be correctly configured as a SLAVE.
    389          
    390          Promises:
    391          - If channel open message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    392          - Otherwise returns FALSE
    393           
    394          */

   \                                 In section .text, align 2, keep-with-next
    395          bool AntOpenScanningChannel(void)
    396          {
   \                     AntOpenScanningChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    397            u8 au8AntOpenScanChannel[] = {MESG_OPEN_CHANNEL_SIZE, MESG_OPEN_SCAN_CHANNEL_ID, 0, CS};
   \   00000002   0xA800             ADD      R0,SP,#+0
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable11_17
   \   00000008   0x680A             LDR      R2,[R1, #0]
   \   0000000A   0x6002             STR      R2,[R0, #+0]
    398            
    399            /* Check if the channel is ready */
    400            if(AntRadioStatusChannel(ANT_CHANNEL_0) != ANT_CONFIGURED)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       AntRadioStatusChannel
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD005             BEQ.N    ??AntOpenScanningChannel_0
    401            {
    402              DebugPrintf("AntOpenScanningChannel error: channel not ready\n\r");
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable11_18
   \   0000001A   0x.... 0x....      BL       DebugPrintf
    403              return FALSE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE00D             B.N      ??AntOpenScanningChannel_1
    404            }
    405          
    406            /* Update the checksum value and queue the open channel message */
    407            au8AntOpenScanChannel[3] = AntCalculateTxChecksum(au8AntOpenScanChannel);
   \                     ??AntOpenScanningChannel_0: (+1)
   \   00000022   0xA800             ADD      R0,SP,#+0
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0xF88D 0x0003      STRB     R0,[SP, #+3]
    408            G_asAntChannelConfiguration[0].AntFlags |= _ANT_FLAGS_CHANNEL_OPEN_PENDING;
   \   0000002C   0x....             LDR.N    R0,??DataTable11_3
   \   0000002E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000030   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000034   0x....             LDR.N    R1,??DataTable11_3
   \   00000036   0x74C8             STRB     R0,[R1, #+19]
    409           
    410            return( AntQueueOutgoingMessage(au8AntOpenScanChannel) );
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       AntQueueOutgoingMessage
   \                     ??AntOpenScanningChannel_1: (+1)
   \   0000003E   0xBD02             POP      {R1,PC}          ;; return
    411            
    412          } /* end AntOpenScanningChannelNumber() */
    413          
    414          
    415          /*!---------------------------------------------------------------------------------------------------------------------
    416          @fn bool AntCloseChannelNumber(AntChannelNumberType eChannel_)
    417          
    418          @brief Queues a request to close the specified channel.
    419          
    420          Requests that an ANT channel is closed.  Issuing MESG_CLOSE_CHANNEL_ID does not
    421          guarantee that the channel closes, and ANT response to this message does not
    422          indicate that the channel is closed (a seperate message will be sent when the 
    423          channel actually closes which usually happens on the next ANT message period).
    424          
    425          Returns TRUE if the message is successfully queued - this can be ignored or checked.  
    426          Application should monitor AntRadioStatusChannel() for actual channel status.
    427          e.g.
    428          AntChannelStatusType eAntCurrentState;
    429          
    430          // Request to close channel only on an open channel.
    431          if(AntRadioStatusChannel(ANT_CHANNEL_1) == ANT_OPEN )
    432          {
    433             AntCloseChannelNumber(ANT_CHANNEL_1);
    434          }
    435          
    436          Requires:
    437          - ANT channel is correctly configured and should be open.
    438          
    439          @param eChannel_ is ANT_CHANNEL_0, ..., ANT_CHANNEL_7, ANT_CHANNEL_SCANNING
    440          
    441          Promises:
    442          - If channel close message is queued, returns TRUE (Ant_u32CurrentTxMessageToken will be non-zero)
    443          - Otherwise returns FALSE
    444          
    445          */

   \                                 In section .text, align 2, keep-with-next
    446          bool AntCloseChannelNumber(AntChannelNumberType eChannel_)
    447          {
   \                     AntCloseChannelNumber: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    448            u8 au8AntCloseChannel[] = {MESG_CLOSE_CHANNEL_SIZE, MESG_CLOSE_CHANNEL_ID, 0, CS};
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable11_19
   \   0000000C   0x680A             LDR      R2,[R1, #0]
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    449            
    450            /* Check if the channel is ready */
    451            if(AntRadioStatusChannel(eChannel_) != ANT_OPEN)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x.... 0x....      BL       AntRadioStatusChannel
   \   00000018   0x2803             CMP      R0,#+3
   \   0000001A   0xD004             BEQ.N    ??AntCloseChannelNumber_0
    452            {
    453              DebugPrintf("AntCloseChannel error: channel not open\n\r");
   \   0000001C   0x....             LDR.N    R0,??DataTable11_20
   \   0000001E   0x.... 0x....      BL       DebugPrintf
    454              return FALSE;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE017             B.N      ??AntCloseChannelNumber_1
    455            }
    456          
    457            /* Update the channel number */
    458            au8AntCloseChannel[2] = eChannel_;
   \                     ??AntCloseChannelNumber_0: (+1)
   \   00000026   0xF88D 0x4002      STRB     R4,[SP, #+2]
    459          
    460            /* Update the checksum value and queue the close channel message*/
    461            au8AntCloseChannel[3] = AntCalculateTxChecksum(au8AntCloseChannel);
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000030   0xF88D 0x0003      STRB     R0,[SP, #+3]
    462            G_asAntChannelConfiguration[eChannel_].AntFlags |= _ANT_FLAGS_CHANNEL_CLOSE_PENDING;
   \   00000034   0x....             LDR.N    R0,??DataTable11_3
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2114             MOVS     R1,#+20
   \   0000003A   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000003E   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000040   0xF050 0x0008      ORRS     R0,R0,#0x8
   \   00000044   0x....             LDR.N    R1,??DataTable11_3
   \   00000046   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000048   0x2214             MOVS     R2,#+20
   \   0000004A   0xFB02 0x1104      MLA      R1,R2,R4,R1
   \   0000004E   0x74C8             STRB     R0,[R1, #+19]
    463            
    464            return( AntQueueOutgoingMessage(au8AntCloseChannel) );
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0x.... 0x....      BL       AntQueueOutgoingMessage
   \                     ??AntCloseChannelNumber_1: (+1)
   \   00000056   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    465          
    466          } /* end AntCloseChannelNumber() */
    467          
    468          
    469          /*!---------------------------------------------------------------------------------------------------------------------
    470          @fn AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
    471          
    472          @brief Query the status of the specified channel.  
    473          
    474          Returns ANT_UNCONFIGURED, ANT_CONFIGURED, ANT_OPENING, ANT_OPEN, ANT_CLOSING, ANT_CLOSED
    475          ANT_CONFIGURED and ANT_CLOSED are actually the same state.
    476          e.g.
    477          AntChannelStatus eAntCurrentStatus;
    478          
    479          // Get the status of Channel 1
    480          eAntCurrentStatus = AntRadioStatusChannel(ANT_CHANNEL_1);
    481            
    482          Requires:
    483          - AntFlags for the specified channel are up to date 
    484          
    485          @param eChannel_ is the ANT channel whose status is desired
    486          
    487          Promises:
    488            - Returns one of {ANT_UNCONFIGURED, ANT_CONFIGURED (ANT_CLOSED), ANT_CLOSING, ANT_OPEN, ANT_CLOSED}
    489          
    490          */

   \                                 In section .text, align 2, keep-with-next
    491          AntChannelStatusType AntRadioStatusChannel(AntChannelNumberType eChannel_)
    492          {
   \                     AntRadioStatusChannel: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    493            if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CONFIGURED)
   \   00000002   0x....             LDR.N    R0,??DataTable11_3
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x2214             MOVS     R2,#+20
   \   00000008   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000000C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000000E   0x07C0             LSLS     R0,R0,#+31
   \   00000010   0xD515             BPL.N    ??AntRadioStatusChannel_0
    494            {
    495              if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_CLOSE_PENDING)
   \   00000012   0x....             LDR.N    R0,??DataTable11_3
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x2214             MOVS     R2,#+20
   \   00000018   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   0000001C   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000001E   0x0700             LSLS     R0,R0,#+28
   \   00000020   0xD501             BPL.N    ??AntRadioStatusChannel_1
    496              {
    497                return ANT_CLOSING;
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE00C             B.N      ??AntRadioStatusChannel_2
    498              }
    499              else if(G_asAntChannelConfiguration[eChannel_].AntFlags & _ANT_FLAGS_CHANNEL_OPEN)
   \                     ??AntRadioStatusChannel_1: (+1)
   \   00000026   0x....             LDR.N    R0,??DataTable11_3
   \   00000028   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000002A   0x2214             MOVS     R2,#+20
   \   0000002C   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000030   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000032   0x0740             LSLS     R0,R0,#+29
   \   00000034   0xD501             BPL.N    ??AntRadioStatusChannel_3
    500              {
    501                return ANT_OPEN;
   \   00000036   0x2003             MOVS     R0,#+3
   \   00000038   0xE002             B.N      ??AntRadioStatusChannel_2
    502              }
    503              else
    504              {
    505                return ANT_CLOSED;
   \                     ??AntRadioStatusChannel_3: (+1)
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xE000             B.N      ??AntRadioStatusChannel_2
    506              }
    507            }
    508            else
    509            {
    510              return ANT_UNCONFIGURED;
   \                     ??AntRadioStatusChannel_0: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \                     ??AntRadioStatusChannel_2: (+1)
   \   00000040   0x4770             BX       LR               ;; return
    511            }
    512             
    513          } /* end AntRadioStatusChannel () */
    514          
    515          
    516          /***ANT DATA MESSAGE FUNCTIONS***/
    517          
    518          /*!---------------------------------------------------------------------------------------------------------------------
    519          @fn bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    520          
    521          @brief Adds an ANT broadcast message to the outgoing messages list.  
    522          
    523          Requires:
    524          @param eChannel_ is the channel number on which to broadcast
    525          @param pu8Data_ is a pointer to the first element of an array of 8 data bytes
    526          
    527          Promises:
    528          - Returns TRUE if the entry is added successfully.
    529          
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          bool AntQueueBroadcastMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    532          {
   \                     AntQueueBroadcastMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    533            /* Update the dynamic message data */
    534            G_au8AntBroadcastDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_21
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    535            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueBroadcastMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueBroadcastMessage_1
    536            {
    537              G_au8AntBroadcastDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5D41             LDRB     R1,[R0, R5]
   \   00000016   0x....             LDR.N    R2,??DataTable11_21
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x1882             ADDS     R2,R0,R2
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    538            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueBroadcastMessage_0
    539           
    540            G_au8AntBroadcastDataMessage[11] = AntCalculateTxChecksum(G_au8AntBroadcastDataMessage);
   \                     ??AntQueueBroadcastMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_21
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_21
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    541            
    542            return( AntQueueOutgoingMessage(G_au8AntBroadcastDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_21
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    543          
    544          } /* end AntQueueBroadcastMessage */
    545          
    546          
    547          /*!---------------------------------------------------------------------------------------------------------------------
    548          @fn bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    549          
    550          @brief Adds an ANT Acknowledged message to the outgoing messages list.  
    551          
    552          Requires:
    553          @param eChannel_ is the channel number on which to broadcast
    554          @param pu8Data_ is a pointer to the first element of an array of 8 data bytes
    555          
    556          Promises:
    557          - Returns TRUE if the entry is added successfully.
    558          
    559          */

   \                                 In section .text, align 2, keep-with-next
    560          bool AntQueueAcknowledgedMessage(AntChannelNumberType eChannel_, u8 *pu8Data_)
    561          {
   \                     AntQueueAcknowledgedMessage: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    562            /* Update the dynamic message data */
    563            G_au8AntAckDataMessage[2] = eChannel_;
   \   00000006   0x....             LDR.N    R0,??DataTable11_22
   \   00000008   0x7084             STRB     R4,[R0, #+2]
    564            for(u8 i = 0; i < ANT_DATA_BYTES; i++)
   \   0000000A   0x2000             MOVS     R0,#+0
   \                     ??AntQueueAcknowledgedMessage_0: (+1)
   \   0000000C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000E   0x2808             CMP      R0,#+8
   \   00000010   0xDA07             BGE.N    ??AntQueueAcknowledgedMessage_1
    565            {
    566              G_au8AntAckDataMessage[3 + i] = *(pu8Data_ + i);
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5D41             LDRB     R1,[R0, R5]
   \   00000016   0x....             LDR.N    R2,??DataTable11_22
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x1882             ADDS     R2,R0,R2
   \   0000001C   0x70D1             STRB     R1,[R2, #+3]
    567            }
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE7F4             B.N      ??AntQueueAcknowledgedMessage_0
    568           
    569            G_au8AntAckDataMessage[11] = AntCalculateTxChecksum(G_au8AntAckDataMessage);
   \                     ??AntQueueAcknowledgedMessage_1: (+1)
   \   00000022   0x....             LDR.N    R0,??DataTable11_22
   \   00000024   0x.... 0x....      BL       AntCalculateTxChecksum
   \   00000028   0x....             LDR.N    R1,??DataTable11_22
   \   0000002A   0x72C8             STRB     R0,[R1, #+11]
    570            return( AntQueueOutgoingMessage(G_au8AntAckDataMessage) );
   \   0000002C   0x....             LDR.N    R0,??DataTable11_22
   \   0000002E   0x.... 0x....      BL       AntQueueOutgoingMessage
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    571           
    572          } /* end AntQueueAcknowledgedMessage */
    573          
    574          
    575          /*!---------------------------------------------------------------------------------------------------------------------
    576          @fn bool AntReadAppMessageBuffer(void)
    577          
    578          @brief Checks for any new messages from ANT.  
    579          
    580          New messages are buffered by ant.c and made available to the application 
    581          on a FIFO basis.  Whenever this function is called, the global 
    582          parameters are updated:
    583          - G_u32AntApiCurrentMessageTimeStamp
    584          - G_eAntApiCurrentMessageClass
    585          - G_au8AntApiCurrentMessageBytes
    586          - G_sAntApiCurrentMessageExtData
    587          
    588          The application should check G_eAntApiCurrentMessageClass to determine if the message
    589          is ANT_DATA or ANT_TICK and then use G_au8AntApiCurrentMessageBytes and
    590          G_sAntApiCurrentMessageExtData accordingly.
    591          
    592          Requires:
    593          - NONE
    594          
    595          Promises:
    596          - Returns TRUE if there is new data; 
    597            G_u32AntApiCurrentMessageTimeStamp
    598            G_eAntApiCurrentMessageClass
    599            G_au8AntApiCurrentMessageBytes
    600            G_sAntApiCurrentMessageExtData
    601            are all updated with the oldest data from G_psAntApplicationMsgList and the message
    602            is removed from the buffer.
    603          - Returns FALSE if no new data is present (all variables unchanged)
    604          
    605          */

   \                                 In section .text, align 2, keep-with-next
    606          bool AntReadAppMessageBuffer(void)
    607          {
   \                     AntReadAppMessageBuffer: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    608            u8 *pu8Parser;
    609            
    610            if(G_psAntApplicationMsgList != NULL)
   \   00000002   0x....             LDR.N    R0,??DataTable11_23
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD03B             BEQ.N    ??AntReadAppMessageBuffer_0
    611            {
    612              /* Grab the single bytes */
    613              G_u32AntApiCurrentMessageTimeStamp = G_psAntApplicationMsgList->u32TimeStamp;
   \   0000000A   0x....             LDR.N    R0,??DataTable11_23
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x....             LDR.N    R1,??DataTable11_24
   \   00000012   0x6008             STR      R0,[R1, #+0]
    614              G_eAntApiCurrentMessageClass = G_psAntApplicationMsgList->eMessageType;
   \   00000014   0x....             LDR.N    R0,??DataTable11_23
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x7900             LDRB     R0,[R0, #+4]
   \   0000001A   0x....             LDR.N    R1,??DataTable11_25
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    615              
    616              /* Copy over all the payload data */
    617              pu8Parser = &(G_psAntApplicationMsgList->au8MessageData[0]);
   \   0000001E   0x....             LDR.N    R0,??DataTable11_23
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF200 0x0006      ADDW     R0,R0,#+6
   \   00000026   0x0004             MOVS     R4,R0
    618              for(u8 i = 0; i < ANT_APPLICATION_MESSAGE_BYTES; i++)
   \   00000028   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_1: (+1)
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0x2808             CMP      R0,#+8
   \   0000002E   0xDA06             BGE.N    ??AntReadAppMessageBuffer_2
    619              {
    620                G_au8AntApiCurrentMessageBytes[i] = *(pu8Parser + i);
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5D01             LDRB     R1,[R0, R4]
   \   00000034   0x....             LDR.N    R2,??DataTable11_26
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0x5481             STRB     R1,[R0, R2]
    621              }
   \   0000003A   0x1C40             ADDS     R0,R0,#+1
   \   0000003C   0xE7F5             B.N      ??AntReadAppMessageBuffer_1
    622              
    623              /* Copy over the extended data */
    624              G_sAntApiCurrentMessageExtData.u8Channel    = G_psAntApplicationMsgList->sExtendedData.u8Channel;
   \                     ??AntReadAppMessageBuffer_2: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable11_23
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x7B80             LDRB     R0,[R0, #+14]
   \   00000044   0x....             LDR.N    R1,??DataTable11_27
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    625              G_sAntApiCurrentMessageExtData.u8Flags      = G_psAntApplicationMsgList->sExtendedData.u8Flags;
   \   00000048   0x....             LDR.N    R0,??DataTable11_23
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x7BC0             LDRB     R0,[R0, #+15]
   \   0000004E   0x....             LDR.N    R1,??DataTable11_27
   \   00000050   0x7048             STRB     R0,[R1, #+1]
    626              G_sAntApiCurrentMessageExtData.u16DeviceID  = G_psAntApplicationMsgList->sExtendedData.u16DeviceID;
   \   00000052   0x....             LDR.N    R0,??DataTable11_23
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0x8A00             LDRH     R0,[R0, #+16]
   \   00000058   0x....             LDR.N    R1,??DataTable11_27
   \   0000005A   0x8048             STRH     R0,[R1, #+2]
    627              G_sAntApiCurrentMessageExtData.u8DeviceType = G_psAntApplicationMsgList->sExtendedData.u8DeviceType;
   \   0000005C   0x....             LDR.N    R0,??DataTable11_23
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x7C80             LDRB     R0,[R0, #+18]
   \   00000062   0x....             LDR.N    R1,??DataTable11_27
   \   00000064   0x7108             STRB     R0,[R1, #+4]
    628              G_sAntApiCurrentMessageExtData.u8TransType  = G_psAntApplicationMsgList->sExtendedData.u8TransType;
   \   00000066   0x....             LDR.N    R0,??DataTable11_23
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x7CC0             LDRB     R0,[R0, #+19]
   \   0000006C   0x....             LDR.N    R1,??DataTable11_27
   \   0000006E   0x7148             STRB     R0,[R1, #+5]
    629              G_sAntApiCurrentMessageExtData.s8RSSI       = G_psAntApplicationMsgList->sExtendedData.s8RSSI;
   \   00000070   0x....             LDR.N    R0,??DataTable11_23
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x7D00             LDRB     R0,[R0, #+20]
   \   00000076   0x....             LDR.N    R1,??DataTable11_27
   \   00000078   0x7188             STRB     R0,[R1, #+6]
    630              
    631              /* Done, so message can be removed from the buffer */
    632              AntDeQueueApplicationMessage();    
   \   0000007A   0x.... 0x....      BL       AntDeQueueApplicationMessage
    633              return TRUE;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xE000             B.N      ??AntReadAppMessageBuffer_3
    634            }
    635            
    636            /* Otherwise return FALSE and do not touch the current data array */
    637            return FALSE;
   \                     ??AntReadAppMessageBuffer_0: (+1)
   \   00000082   0x2000             MOVS     R0,#+0
   \                     ??AntReadAppMessageBuffer_3: (+1)
   \   00000084   0xBD10             POP      {R4,PC}          ;; return
    638            
    639          } /* end AntReadAppMessageBuffer() */
    640          
    641          
    642          /*!---------------------------------------------------------------------------------------------------------------------
    643          @fn void AntGetdBmAscii(s8 s8RssiValue_, u8* pu8Result_)
    644          
    645          @brief Takes the binary RSSI value and writes back a string with the value in dBm.
    646          
    647          The string INCLUDES the sign (- or +, even though it will ALWAYS be - for ANT)
    648          but does NOT include the unit text dBm.  Leading 0s are always returned,
    649          thus the returned string is always three chars (no terminating NULL).
    650          
    651          Requires:
    652          @param s8RssiValue_ is the signed 8-bit RSSI value to convert.  The number is two's complement.
    653          @param pu8Result_ points to a string with at least 3 bytes of space to write
    654          
    655          Promises:
    656          - *pu8Result_ receive the '-xx' where xx is the value in dBm (does not send
    657            a terminating NULL)
    658          
    659          */

   \                                 In section .text, align 2, keep-with-next
    660          void AntGetdBmAscii(s8 s8RssiValue_, u8* pu8Result_)
    661          {
   \                     AntGetdBmAscii: (+1)
   \   00000000   0xB410             PUSH     {R4}
    662            u8 u8AbsoluteValue;
    663            
    664            /* Handle the positive number */
    665            if(s8RssiValue_ >= 0)
   \   00000002   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD408             BMI.N    ??AntGetdBmAscii_0
    666            {
    667              /* Print '+' but only for numbers larger than 0 */
    668              *pu8Result_ = '+';
   \   00000008   0x232B             MOVS     R3,#+43
   \   0000000A   0x700B             STRB     R3,[R1, #+0]
    669              if(s8RssiValue_ == 0)
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE.N    ??AntGetdBmAscii_1
    670              {
    671                *pu8Result_ = ' ';
   \   00000012   0x2320             MOVS     R3,#+32
   \   00000014   0x700B             STRB     R3,[R1, #+0]
    672              }
    673              
    674              u8AbsoluteValue = (u8)s8RssiValue_;
   \                     ??AntGetdBmAscii_1: (+1)
   \   00000016   0x0002             MOVS     R2,R0
   \   00000018   0xE004             B.N      ??AntGetdBmAscii_2
    675            }
    676            /* Handle the negative number */
    677            else
    678            {
    679              *pu8Result_ = '-';
   \                     ??AntGetdBmAscii_0: (+1)
   \   0000001A   0x232D             MOVS     R3,#+45
   \   0000001C   0x700B             STRB     R3,[R1, #+0]
    680              u8AbsoluteValue = (u8)(~s8RssiValue_ + 1);
   \   0000001E   0x43C3             MVNS     R3,R0
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \   00000022   0x001A             MOVS     R2,R3
    681            }
    682            
    683            /* Limit any display to two digit */
    684            if(u8AbsoluteValue > 99)
   \                     ??AntGetdBmAscii_2: (+1)
   \   00000024   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000026   0x2A64             CMP      R2,#+100
   \   00000028   0xDB01             BLT.N    ??AntGetdBmAscii_3
    685            {
    686              u8AbsoluteValue = 99;
   \   0000002A   0x2363             MOVS     R3,#+99
   \   0000002C   0x001A             MOVS     R2,R3
    687            }
    688            
    689          
    690            /* Write the numeric value */
    691            pu8Result_++;
   \                     ??AntGetdBmAscii_3: (+1)
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
    692            *pu8Result_ = (u8AbsoluteValue / 10) + NUMBER_ASCII_TO_DEC;
   \   00000030   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000032   0x230A             MOVS     R3,#+10
   \   00000034   0xFB92 0xF3F3      SDIV     R3,R2,R3
   \   00000038   0x3330             ADDS     R3,R3,#+48
   \   0000003A   0x700B             STRB     R3,[R1, #+0]
    693            pu8Result_++;
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
    694            *pu8Result_ = (u8AbsoluteValue % 10) + NUMBER_ASCII_TO_DEC;
   \   0000003E   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000040   0x230A             MOVS     R3,#+10
   \   00000042   0xFB92 0xF4F3      SDIV     R4,R2,R3
   \   00000046   0xFB03 0x2314      MLS      R3,R3,R4,R2
   \   0000004A   0x3330             ADDS     R3,R3,#+48
   \   0000004C   0x700B             STRB     R3,[R1, #+0]
    695            
    696          } /* end AntGetdBmAscii() */
   \   0000004E   0xBC10             POP      {R4}
   \   00000050   0x4770             BX       LR               ;; return
    697          
    698          
    699          /*--------------------------------------------------------------------------------------------------------------------*/
    700          /*! @protectedsection */                                                                                            
    701          /*--------------------------------------------------------------------------------------------------------------------*/
    702          
    703          /*!---------------------------------------------------------------------------------------------------------------------
    704          @fn void AntApiInitialize(void)
    705          
    706          @brief Runs required initialization for the task.  
    707          
    708          Should only be called once in main init section.
    709          
    710          Requires:
    711          - NONE 
    712          
    713          Promises:
    714          - Ant API set to Idle
    715          
    716          */

   \                                 In section .text, align 2, keep-with-next
    717          void AntApiInitialize(void)
    718          {
   \                     AntApiInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    719            /* If good initialization, set state to Idle */
    720            if(G_u32ApplicationFlags & _APPLICATION_FLAGS_ANT)
   \   00000002   0x....             LDR.N    R0,??DataTable11_28
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0640             LSLS     R0,R0,#+25
   \   00000008   0xD507             BPL.N    ??AntApiInitialize_0
    721            {
    722              DebugPrintf("ANT API ready\n\r");
   \   0000000A   0x....             LDR.N    R0,??DataTable11_29
   \   0000000C   0x.... 0x....      BL       DebugPrintf
    723              AntApi_StateMachine = AntApiSM_Idle;
   \   00000010   0x.... 0x....      ADR.W    R0,AntApiSM_Idle
   \   00000014   0x....             LDR.N    R1,??DataTable11_12
   \   00000016   0x6008             STR      R0,[R1, #+0]
   \   00000018   0xE003             B.N      ??AntApiInitialize_1
    724            }
    725            else
    726            {
    727              /* The task isn't properly initialized, so shut it down and don't run */
    728              AntApi_StateMachine = AntApiSM_FailedInit;
   \                     ??AntApiInitialize_0: (+1)
   \   0000001A   0x.... 0x....      ADR.W    R0,AntApiSM_FailedInit
   \   0000001E   0x....             LDR.N    R1,??DataTable11_12
   \   00000020   0x6008             STR      R0,[R1, #+0]
    729            }
    730          
    731          } /* end AntApiInitialize() */
   \                     ??AntApiInitialize_1: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
    732          
    733          
    734          /*!---------------------------------------------------------------------------------------------------------------------
    735          @fn void AntApiRunActiveState(void)
    736          
    737          @brief Selects and runs one iteration of the current state in the state machine.
    738          
    739          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    740          may take 1ms / n to execute.
    741          
    742          Requires:
    743          - State machine function pointer points at current state
    744          
    745          Promises:
    746          - Calls the function to pointed by the state machine function pointer
    747          
    748          */

   \                                 In section .text, align 2, keep-with-next
    749          void AntApiRunActiveState(void)
    750          {
   \                     AntApiRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    751            AntApi_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable11_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    752          
    753          } /* end AntApiRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    754          
    755          
    756          /*----------------------------------------------------------------------------------------------------------------------*/
    757          /*! @privatesection */                                                                                            
    758          /*----------------------------------------------------------------------------------------------------------------------*/
    759          
    760          
    761          /**********************************************************************************************************************
    762          State Machine Function Definitions
    763          **********************************************************************************************************************/
    764          
    765          /*!-------------------------------------------------------------------------------------------------------------------
    766          @fn static void AntApiSM_Idle(void)
    767          
    768          @brief Wait for a message to be queued.
    769          */

   \                                 In section .text, align 4, keep-with-next
    770          static void AntApiSM_Idle(void)
    771          {
    772            /* Monitor requests to send generic ANT messages */
    773            
    774          } /* end AntApiSM_Idle() */
   \                     AntApiSM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    775               
    776          
    777          /*!-------------------------------------------------------------------------------------------------------------------
    778          @fn static void AntApiSM_AssignChannel(void)          
    779          
    780          @brief Send all configuration messages to ANT to fully assign the channel.
    781          
    782          The selected channel has already been verified unconfigured, and all required setup
    783          messages are ready to go.  
    784          */

   \                                 In section .text, align 4, keep-with-next
    785          static void AntApiSM_AssignChannel(void)          
    786          {
   \                     AntApiSM_AssignChannel: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    787            static u8 u8CurrentMessageToSend = 0;
    788            static u8 u8CurrentMesssageId = 0;
    789            static bool bMessageInProgress = FALSE;
    790            
    791            /* Queue the next message if it's time */
    792            if(bMessageInProgress == FALSE)
   \   00000002   0x....             LDR.N    R0,??DataTable11_30
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD111             BNE.N    ??AntApiSM_AssignChannel_0
    793            {
    794              u8CurrentMesssageId = *(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend] + BUFFER_INDEX_MESG_ID); 
   \   0000000A   0x....             LDR.N    R0,??DataTable11_31
   \   0000000C   0x....             LDR.N    R1,??DataTable11_32
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000014   0x7840             LDRB     R0,[R0, #+1]
   \   00000016   0x....             LDR.N    R1,??DataTable11_33
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    795              AntQueueOutgoingMessage(AntApi_apu8AntAssignChannel[u8CurrentMessageToSend]);
   \   0000001A   0x....             LDR.N    R0,??DataTable11_31
   \   0000001C   0x....             LDR.N    R1,??DataTable11_32
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000024   0x.... 0x....      BL       AntQueueOutgoingMessage
    796              bMessageInProgress = TRUE;
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0x....             LDR.N    R1,??DataTable11_30
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    797            }
    798            
    799            /* Check message status */
    800            if( u8CurrentMesssageId == G_stAntMessageResponse.u8MessageNumber )
   \                     ??AntApiSM_AssignChannel_0: (+1)
   \   0000002E   0x....             LDR.N    R0,??DataTable11_33
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x....             LDR.N    R1,??DataTable11_34
   \   00000034   0x7849             LDRB     R1,[R1, #+1]
   \   00000036   0x4288             CMP      R0,R1
   \   00000038   0xD13A             BNE.N    ??AntApiSM_AssignChannel_1
    801            { 
    802              if(G_stAntMessageResponse.u8ResponseCode == RESPONSE_NO_ERROR)
   \   0000003A   0x....             LDR.N    R0,??DataTable11_34
   \   0000003C   0x7880             LDRB     R0,[R0, #+2]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD12A             BNE.N    ??AntApiSM_AssignChannel_2
    803              {
    804                /* Increment message pointer and check if complete */
    805                u8CurrentMessageToSend++;
   \   00000042   0x....             LDR.N    R0,??DataTable11_32
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable11_32
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    806                if(u8CurrentMessageToSend == ANT_ASSIGN_MESSAGES)
   \   0000004C   0x....             LDR.N    R0,??DataTable11_32
   \   0000004E   0x7800             LDRB     R0,[R0, #+0]
   \   00000050   0x2808             CMP      R0,#+8
   \   00000052   0xD12A             BNE.N    ??AntApiSM_AssignChannel_3
    807                {
    808                  /* Print OK message and update the channel flags */
    809                  G_au8AntMessageAssign[12] = G_stAntMessageResponse.u8Channel + NUMBER_ASCII_TO_DEC;
   \   00000054   0x....             LDR.N    R0,??DataTable11_34
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x3030             ADDS     R0,R0,#+48
   \   0000005A   0x....             LDR.N    R1,??DataTable11_35
   \   0000005C   0x7308             STRB     R0,[R1, #+12]
    810                  DebugPrintf(G_au8AntMessageAssign);
   \   0000005E   0x....             LDR.N    R0,??DataTable11_35
   \   00000060   0x.... 0x....      BL       DebugPrintf
    811                  DebugPrintf(G_au8AntMessageOk);
   \   00000064   0x....             LDR.N    R0,??DataTable11_36
   \   00000066   0x.... 0x....      BL       DebugPrintf
    812                  G_asAntChannelConfiguration[G_stAntMessageResponse.u8Channel].AntFlags |= _ANT_FLAGS_CHANNEL_CONFIGURED;
   \   0000006A   0x....             LDR.N    R0,??DataTable11_3
   \   0000006C   0x....             LDR.N    R1,??DataTable11_34
   \   0000006E   0x7809             LDRB     R1,[R1, #+0]
   \   00000070   0x2214             MOVS     R2,#+20
   \   00000072   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000076   0x7CC0             LDRB     R0,[R0, #+19]
   \   00000078   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000007C   0x....             LDR.N    R1,??DataTable11_3
   \   0000007E   0x....             LDR.N    R2,??DataTable11_34
   \   00000080   0x7812             LDRB     R2,[R2, #+0]
   \   00000082   0x2314             MOVS     R3,#+20
   \   00000084   0xFB03 0x1102      MLA      R1,R3,R2,R1
   \   00000088   0x74C8             STRB     R0,[R1, #+19]
    813          
    814                  /* Clean up and exit this state */
    815                  u8CurrentMessageToSend = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x....             LDR.N    R1,??DataTable11_32
   \   0000008E   0x7008             STRB     R0,[R1, #+0]
    816                  AntApi_StateMachine = AntApiSM_Idle;
   \   00000090   0x....             LDR.N    R0,??DataTable11_37
   \   00000092   0x....             LDR.N    R1,??DataTable11_12
   \   00000094   0x6008             STR      R0,[R1, #+0]
   \   00000096   0xE008             B.N      ??AntApiSM_AssignChannel_3
    817                }
    818              } 
    819              else
    820              {
    821                /* Report the error and return.  Channel flags will remain clear for application to check. */
    822                DebugPrintf(G_au8AntMessageAssign);
   \                     ??AntApiSM_AssignChannel_2: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable11_35
   \   0000009A   0x.... 0x....      BL       DebugPrintf
    823                DebugPrintf(G_au8AntMessageFail);
   \   0000009E   0x....             LDR.N    R0,??DataTable11_38
   \   000000A0   0x.... 0x....      BL       DebugPrintf
    824                AntApi_StateMachine = AntApiSM_Idle;
   \   000000A4   0x....             LDR.N    R0,??DataTable11_37
   \   000000A6   0x....             LDR.N    R1,??DataTable11_12
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    825              }
    826          
    827              /* In either case, clean up the following: */
    828              bMessageInProgress = FALSE;
   \                     ??AntApiSM_AssignChannel_3: (+1)
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x....             LDR.N    R1,??DataTable11_30
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
    829          
    830            } /* end if( u8CurrentMesssageId == G_stAntMessageResponse.u8MessageNumber ) */
    831            
    832            /* Check for timeout */
    833            if(IsTimeUp(&AntApi_u32Timeout, ANT_ACTIVITY_TIME_COUNT) )
   \                     ??AntApiSM_AssignChannel_1: (+1)
   \   000000B0   0xF242 0x7110      MOVW     R1,#+10000
   \   000000B4   0x....             LDR.N    R0,??DataTable11_11
   \   000000B6   0x.... 0x....      BL       IsTimeUp
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD008             BEQ.N    ??AntApiSM_AssignChannel_4
    834            {
    835              /* Report the error and return.  Channel flags will remain clear for application to check. */
    836              DebugPrintf(G_au8AntMessageAssign);
   \   000000BE   0x....             LDR.N    R0,??DataTable11_35
   \   000000C0   0x.... 0x....      BL       DebugPrintf
    837              DebugPrintf(G_au8AntMessageFail);
   \   000000C4   0x....             LDR.N    R0,??DataTable11_38
   \   000000C6   0x.... 0x....      BL       DebugPrintf
    838              AntApi_StateMachine = AntApiSM_Idle;
   \   000000CA   0x....             LDR.N    R0,??DataTable11_37
   \   000000CC   0x....             LDR.N    R1,??DataTable11_12
   \   000000CE   0x6008             STR      R0,[R1, #+0]
    839            }
    840            
    841          } /* end AntApiSM_AssignChannel() */
   \                     ??AntApiSM_AssignChannel_4: (+1)
   \   000000D0   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .bss, align 1
   \                     ??u8CurrentMessageToSend:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??u8CurrentMesssageId:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     ??bMessageInProgress:
   \   00000000                      DS8 1
    842          
    843          
    844          #if 0
    845          /*-------------------------------------------------------------------------------------------------------------------*/
    846          /* Handle an error */
    847          static void  AntApiSM_Error(void)          
    848          {
    849            
    850          } /* end AntApiSM_Error() */
    851          #endif
    852          
    853          
    854          /*-------------------------------------------------------------------------------------------------------------------*/
    855          /* State to sit in if init failed */

   \                                 In section .text, align 4, keep-with-next
    856          static void  AntApiSM_FailedInit(void)          
    857          {
    858              
    859          } /* end AntApiSM_FailedInit() */
   \                     AntApiSM_FailedInit: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     G_au8AntLibConfig

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     G_au8AntSetNetworkKey

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     G_asAntChannelConfiguration

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     G_au8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     G_au8AntSetChannelID

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     G_au8AntSetChannelPeriod

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     G_au8AntSetChannelRFFreq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     G_au8AntSetChannelPower

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     G_au8AntSetSearchTimeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     AntApi_u32Timeout

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     AntApi_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_17:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_18:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_19:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_20:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_21:
   \   00000000   0x........         DC32     G_au8AntBroadcastDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_22:
   \   00000000   0x........         DC32     G_au8AntAckDataMessage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_23:
   \   00000000   0x........         DC32     G_psAntApplicationMsgList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_24:
   \   00000000   0x........         DC32     G_u32AntApiCurrentMessageTimeStamp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_25:
   \   00000000   0x........         DC32     G_eAntApiCurrentMessageClass

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_26:
   \   00000000   0x........         DC32     G_au8AntApiCurrentMessageBytes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_27:
   \   00000000   0x........         DC32     G_sAntApiCurrentMessageExtData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_28:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_29:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_30:
   \   00000000   0x........         DC32     ??bMessageInProgress

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_31:
   \   00000000   0x........         DC32     AntApi_apu8AntAssignChannel

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_32:
   \   00000000   0x........         DC32     ??u8CurrentMessageToSend

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_33:
   \   00000000   0x........         DC32     ??u8CurrentMesssageId

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_34:
   \   00000000   0x........         DC32     G_stAntMessageResponse

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_35:
   \   00000000   0x........         DC32     G_au8AntMessageAssign

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_36:
   \   00000000   0x........         DC32     G_au8AntMessageOk

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_37:
   \   00000000   0x........         DC32     AntApiSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_38:
   \   00000000   0x........         DC32     G_au8AntMessageFail

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x6E          DC8 41H, 6EH, 74H, 41H, 73H, 73H, 69H, 67H
   \              0x74 0x41    
   \              0x73 0x73    
   \              0x69 0x67    
   \   00000008   0x6E 0x43          DC8 6EH, 43H, 68H, 61H, 6EH, 6EH, 65H, 6CH
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \   00000010   0x20 0x65          DC8 20H, 65H, 72H, 72H, 6FH, 72H, 3AH, 20H
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \   00000018   0x63 0x68          DC8 63H, 68H, 61H, 6EH, 6EH, 65H, 6CH, 20H
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \   00000020   0x69 0x73          DC8 69H, 73H, 20H, 6EH, 6FH, 74H, 20H, 75H
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x75    
   \   00000028   0x6E 0x63          DC8 6EH, 63H, 6FH, 6EH, 66H, 69H, 67H, 75H
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \   00000030   0x72 0x65          DC8 72H, 65H, 64H, 0AH, 0DH, 0
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x01 0x41          DC8 1, 65, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x6E          DC8 "AntUnssignChannel error: channel not closed\012\015"
   \              0x74 0x55    
   \              0x6E 0x73    
   \              0x73 0x69    
   \              0x67 0x6E    
   \              0x43 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x63    
   \              0x6C 0x6F    
   \              0x73 0x65    
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x01 0x4B          DC8 1, 75, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x6E          DC8 "AntOpenChannel error: channel not ready\012\015"
   \              0x74 0x4F    
   \              0x70 0x65    
   \              0x6E 0x43    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x01 0x5B          DC8 1, 91, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x6E          DC8 "AntOpenScanningChannel error: channel not ready\012\015"
   \              0x74 0x4F    
   \              0x70 0x65    
   \              0x6E 0x53    
   \              0x63 0x61    
   \              0x6E 0x6E    
   \              0x69 0x6E    
   \              0x67 0x43    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x01 0x4C          DC8 1, 76, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x41 0x6E          DC8 "AntCloseChannel error: channel not open\012\015"
   \              0x74 0x43    
   \              0x6C 0x6F    
   \              0x73 0x65    
   \              0x43 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x20    
   \              0x65 0x72    
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x63    
   \              0x68 0x61    
   \              0x6E 0x6E    
   \              0x65 0x6C    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x6F    
   \              0x70 0x65    
   \              0x6E 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x41 0x4E          DC8 "ANT API ready\012\015"
   \              0x54 0x20    
   \              0x41 0x50    
   \              0x49 0x20    
   \              0x72 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    
    860          
    861          
    862          /*--------------------------------------------------------------------------------------------------------------------*/
    863          /* End of File                                                                                                        */
    864          /*--------------------------------------------------------------------------------------------------------------------*/
    865          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AntApiInitialize
         8   -> DebugPrintf
       8   AntApiRunActiveState
         8   -- Indirect call
       8   AntApiSM_AssignChannel
         8   -> AntQueueOutgoingMessage
         8   -> DebugPrintf
         8   -> IsTimeUp
       0   AntApiSM_FailedInit
       0   AntApiSM_Idle
       8   AntAssignChannel
         8   -> AntCalculateTxChecksum
         8   -> AntRadioStatusChannel
         8   -> DebugPrintf
      16   AntCloseChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
        16   -> AntRadioStatusChannel
        16   -> DebugPrintf
       4   AntGetdBmAscii
      16   AntOpenChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
        16   -> AntRadioStatusChannel
        16   -> DebugPrintf
       8   AntOpenScanningChannel
         8   -> AntCalculateTxChecksum
         8   -> AntQueueOutgoingMessage
         8   -> AntRadioStatusChannel
         8   -> DebugPrintf
      16   AntQueueAcknowledgedMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
      16   AntQueueBroadcastMessage
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
       0   AntRadioStatusChannel
       8   AntReadAppMessageBuffer
         8   -> AntDeQueueApplicationMessage
      16   AntUnassignChannelNumber
        16   -> AntCalculateTxChecksum
        16   -> AntQueueOutgoingMessage
        16   -> AntRadioStatusChannel
        16   -> DebugPrintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_17
       4  ??DataTable11_18
       4  ??DataTable11_19
       4  ??DataTable11_2
       4  ??DataTable11_20
       4  ??DataTable11_21
       4  ??DataTable11_22
       4  ??DataTable11_23
       4  ??DataTable11_24
       4  ??DataTable11_25
       4  ??DataTable11_26
       4  ??DataTable11_27
       4  ??DataTable11_28
       4  ??DataTable11_29
       4  ??DataTable11_3
       4  ??DataTable11_30
       4  ??DataTable11_31
       4  ??DataTable11_32
       4  ??DataTable11_33
       4  ??DataTable11_34
       4  ??DataTable11_35
       4  ??DataTable11_36
       4  ??DataTable11_37
       4  ??DataTable11_38
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      56  ?_0
       4  ?_1
      48  ?_2
       4  ?_3
      44  ?_4
       4  ?_5
      52  ?_6
       4  ?_7
      44  ?_8
      16  ?_9
      36  AntApiInitialize
      10  AntApiRunActiveState
     210  AntApiSM_AssignChannel
       2  AntApiSM_FailedInit
       2  AntApiSM_Idle
       4  AntApi_StateMachine
      32  AntApi_apu8AntAssignChannel
       4  AntApi_u32Timeout
     512  AntAssignChannel
      88  AntCloseChannelNumber
      82  AntGetdBmAscii
     100  AntOpenChannelNumber
      64  AntOpenScanningChannel
      52  AntQueueAcknowledgedMessage
      52  AntQueueBroadcastMessage
      66  AntRadioStatusChannel
     134  AntReadAppMessageBuffer
      62  AntUnassignChannelNumber
       8  G_au8AntApiCurrentMessageBytes
       1  G_eAntApiCurrentMessageClass
       8  G_sAntApiCurrentMessageExtData
       4  G_u32AntApiCurrentMessageTimeStamp
       4  G_u32AntApiFlags
       1  bMessageInProgress
       1  u8CurrentMessageToSend
       1  u8CurrentMesssageId

 
    36 bytes in section .bss
    32 bytes in section .data
   276 bytes in section .rodata
 1 628 bytes in section .text
 
 1 628 bytes of CODE  memory
   276 bytes of CONST memory
    68 bytes of DATA  memory

Errors: none
Warnings: none
