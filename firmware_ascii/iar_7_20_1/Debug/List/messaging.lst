###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\messaging.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\messaging.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\messaging.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\messaging.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\messaging.c
      1          /*!**********************************************************************************************************************
      2          @file messaging.c                                                                
      3          @brief This file contains utilities to create and monitor outgoing messages.  It essentially provides a 
      4          smart queue system for outgoing data.
      5          
      6          Any message being transferred by a peripheral is kept here.  As the peripheral sends the message,
      7          it talks to messaging.c to get data and update the message status.  
      8          
      9          All interaction between the peripheral and this task is through unique message tokens that are assigned
     10          to every message queued to messaging.c
     11          
     12          The API is simplified and provides just a single function for high-level client tasks to check the
     13          status of their message based on a provided unique token.  If the status of a message is such that
     14          it will no longer change (i.e. COMPLETE, TIMOEOUT, ABANDONDED) then that message's status in the loop
     15          will be cleared automatically.  There is ample room in the message status array to keep sufficient message 
     16          status history given the processing time of the firmware.  However, the status array is circular so 
     17          message statuses can be lost eventually.  If a task waits too long and received a "NOT FOUND" status 
     18          because they have waited too long, the task should increase the frequency at which it queries the 
     19          message status.
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          GLOBALS
     23          - NONE
     24          
     25          CONSTANTS
     26          - NONE
     27          
     28          TYPES
     29          - MessageStateType {EMPTY, WAITING, SENDING, COMPLETE, 
     30                              TIMEOUT, ABANDONED, NOT_FOUND}
     31          
     32          PUBLIC FUNCTIONS
     33          - MessageStateType QueryMessageStatus(u32 u32Token_)
     34          
     35          PROTECTED FUNCTIONS
     36          - void MessagingInitialize(void)
     37          - u32 QueueMessage(MessageType** ppsTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
     38          - void DeQueueMessage(MessageType** pTargetQueue_)
     39          - void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
     40          
     41          
     42          **********************************************************************************************************************/
     43          
     44          #include "configuration.h"
     45          
     46          /***********************************************************************************************************************
     47          Global variable definitions with scope across entire project.
     48          All Global variable names shall start with "G_<type>Messaging"
     49          ***********************************************************************************************************************/
     50          /* New variables */

   \                                 In section .bss, align 4
     51          u32 G_u32MessagingFlags;                               /*!< @brief Global state flags */
   \                     G_u32MessagingFlags:
   \   00000000                      DS8 4
     52          
     53          
     54          /*--------------------------------------------------------------------------------------------------------------------*/
     55          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     56          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     57          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     58          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     59          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
     60          
     61          
     62          /***********************************************************************************************************************
     63          Global variable definitions with scope limited to this local application.
     64          Variable names shall start with "Msg_<type>" and be declared as static.
     65          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     66          static fnCode_type Messaging_pfnStateMachine;          /*!< @brief The state machine function pointer */
   \                     Messaging_pfnStateMachine:
   \   00000000                      DS8 4
     67          

   \                                 In section .bss, align 4
     68          static u32 Msg_u32Token;                               /*!< @brief Incrementing message token used for all external communications */
   \                     Msg_u32Token:
   \   00000000                      DS8 4
     69          

   \                                 In section .bss, align 4
     70          static MessageSlotType Msg_asPool[U8_TX_QUEUE_SIZE];   /*!< @brief Array of MessageSlotType used for the transmit queue */
   \                     Msg_asPool:
   \   00000000                      DS8 4608

   \                                 In section .bss, align 1
     71          static u8 Msg_u8QueuedMessageCount;                    /*!< @brief Number of messages slots currently occupied */
   \                     Msg_u8QueuedMessageCount:
   \   00000000                      DS8 1
     72          
     73          /* A separate status queue needs to be maintained since the message information in Msg_asPool will be lost when the message
     74          has been dequeued.  Applications must be able to query to determine the status of their message, particularly if
     75          it has been sent. */

   \                                 In section .bss, align 4
     76          static MessageStatusType  Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE]; /*!< @brief Array of MessageStatusType used to monitor message status */
   \                     Msg_asStatusQueue:
   \   00000000                      DS8 768

   \                                 In section .bss, align 4
     77          static MessageStatusType* Msg_psNextStatus;                        /*!< @brief Pointer to next available message status */
   \                     Msg_psNextStatus:
   \   00000000                      DS8 4
     78          
     79          
     80          
     81          /**********************************************************************************************************************
     82          Function Definitions
     83          **********************************************************************************************************************/
     84          
     85          /*--------------------------------------------------------------------------------------------------------------------*/
     86          /*! @publicsection */                                                                                            
     87          /*--------------------------------------------------------------------------------------------------------------------*/
     88          
     89          /*!---------------------------------------------------------------------------------------------------------------------
     90          @fn MessageStateType QueryMessageStatus(u32 u32Token_)
     91          
     92          @brief Checks the state of a message and returns the current MessageStateType
     93          
     94          If the state is COMPLETE, TIMEOUT or ABANDONED, calling this function
     95          forces the associated status to be cleared from the message queue.
     96          Since the queue is quite short, most of the time it will hold very little entries.  
     97          New entries are always filled at the front, using a simple linear search starting at index 0.
     98          
     99          Requires:
    100          @param u32Token_ is the token (ID) of the message of interest
    101          
    102          Promises:
    103          - Returns MessageStateType indicating the status of the message
    104          - if the message is found in COMPLETE, TIMEOUT, or ABANDONED state, the status is removed from
    105          the queue and time-stamped for debugging purposes.
    106          
    107          */

   \                                 In section .text, align 2, keep-with-next
    108          MessageStateType QueryMessageStatus(u32 u32Token_)
    109          {
   \                     QueryMessageStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    110            MessageStateType eStatus = NOT_FOUND;
   \   00000002   0x20FF             MOVS     R0,#+255
    111            MessageStatusType* pListParser = &Msg_asStatusQueue[0];
   \   00000004   0x....             LDR.N    R2,??DataTable7
    112            
    113            /* Brute force search for the token - the queue will never be large enough on this system to require a more
    114            intelligent search algorithm */
    115            while( (pListParser->u32Token != u32Token_) && 
    116                   (pListParser != &Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE]) )
   \                     ??QueryMessageStatus_0: (+1)
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x428B             CMP      R3,R1
   \   0000000A   0xD004             BEQ.N    ??QueryMessageStatus_1
   \   0000000C   0x....             LDR.N    R3,??DataTable7_1
   \   0000000E   0x429A             CMP      R2,R3
   \   00000010   0xD001             BEQ.N    ??QueryMessageStatus_1
    117            {
    118              pListParser++;
   \   00000012   0x320C             ADDS     R2,R2,#+12
   \   00000014   0xE7F7             B.N      ??QueryMessageStatus_0
    119            }
    120          
    121            /* If the token was found pListParser is pointing at it, take appropriate action */
    122            if(pListParser != &Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE])
   \                     ??QueryMessageStatus_1: (+1)
   \   00000016   0x....             LDR.N    R3,??DataTable7_1
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD011             BEQ.N    ??QueryMessageStatus_2
    123            {
    124              /* Save the status */
    125              eStatus = pListParser->eState;
   \   0000001C   0x7913             LDRB     R3,[R2, #+4]
   \   0000001E   0x0018             MOVS     R0,R3
    126          
    127              /* Release the slot if the message state is final (the client must deal with it now) */
    128              if( (eStatus == COMPLETE) || (eStatus == TIMEOUT) || (eStatus == ABANDONED) )
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2803             CMP      R0,#+3
   \   00000024   0xD005             BEQ.N    ??QueryMessageStatus_3
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2804             CMP      R0,#+4
   \   0000002A   0xD002             BEQ.N    ??QueryMessageStatus_3
   \   0000002C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002E   0x2805             CMP      R0,#+5
   \   00000030   0xD106             BNE.N    ??QueryMessageStatus_2
    129              {
    130                pListParser->u32Token = 0;
   \                     ??QueryMessageStatus_3: (+1)
   \   00000032   0x2300             MOVS     R3,#+0
   \   00000034   0x6013             STR      R3,[R2, #+0]
    131                pListParser->eState = EMPTY;
   \   00000036   0x2300             MOVS     R3,#+0
   \   00000038   0x7113             STRB     R3,[R2, #+4]
    132                pListParser->u32Timestamp = G_u32SystemTime1ms;
   \   0000003A   0x....             LDR.N    R3,??DataTable7_2
   \   0000003C   0x681B             LDR      R3,[R3, #+0]
   \   0000003E   0x6093             STR      R3,[R2, #+8]
    133              }
    134            }
    135          
    136            /* If the message was not found, the state is already set correctly, so just return */
    137            return(eStatus);
   \                     ??QueryMessageStatus_2: (+1)
   \   00000040   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000042   0x4770             BX       LR               ;; return
    138            
    139          } /* end QueryMessageStatus() */
    140          
    141          
    142          /*--------------------------------------------------------------------------------------------------------------------*/
    143          /*! @protectedsection */                                                                                            
    144          /*--------------------------------------------------------------------------------------------------------------------*/
    145          
    146          /*!--------------------------------------------------------------------------------------------------------------------
    147          @fn void MessagingInitialize(void)
    148          
    149          @brief Runs required initialization for the task.  
    150          
    151          Should only be called once in main init section.
    152          
    153          Requires:
    154          - No messaging in progress
    155          
    156          Promises:
    157          - Message queues are zeroed
    158          - Flags and state machine are initialized
    159          
    160          */

   \                                 In section .text, align 2, keep-with-next
    161          void MessagingInitialize(void)
    162          {
    163            /* Initialize variables */
    164            Msg_u8QueuedMessageCount = 0;
   \                     MessagingInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable7_3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    165            Msg_u32Token = 1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable7_4
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    166          
    167            /* Ensure all message slots are deallocated and the message status queue is empty */
    168            for(u8 i = 0; i < U8_TX_QUEUE_SIZE; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_0: (+1)
   \   0000000E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000010   0x2820             CMP      R0,#+32
   \   00000012   0xDA2D             BGE.N    ??MessagingInitialize_1
    169            {
    170              /* Clear the Slot value */
    171              Msg_asPool[i].bFree = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable7_5
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x2390             MOVS     R3,#+144
   \   0000001C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000020   0x7011             STRB     R1,[R2, #+0]
    172              
    173              /* Clear the slot's message values */
    174              Msg_asPool[i].Message.u32Token = 0;
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x....             LDR.N    R2,??DataTable7_5
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2390             MOVS     R3,#+144
   \   0000002A   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000002E   0x6051             STR      R1,[R2, #+4]
    175              Msg_asPool[i].Message.u32Size = 0;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x....             LDR.N    R2,??DataTable7_5
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2390             MOVS     R3,#+144
   \   00000038   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000003C   0x6091             STR      R1,[R2, #+8]
    176              Msg_asPool[i].Message.psNextMessage = NULL;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x....             LDR.N    R2,??DataTable7_5
   \   00000042   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000044   0x2390             MOVS     R3,#+144
   \   00000046   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000004A   0xF8C2 0x108C      STR      R1,[R2, #+140]
    177              
    178              /* Clear the slot's message's contents */
    179              for(u16 j = 0; j < U16_MAX_TX_MESSAGE_LENGTH; j++)
   \   0000004E   0x2100             MOVS     R1,#+0
   \                     ??MessagingInitialize_2: (+1)
   \   00000050   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000052   0x2980             CMP      R1,#+128
   \   00000054   0xDA0A             BGE.N    ??MessagingInitialize_3
    180              {
    181                *(Msg_asPool[i].Message.pu8Message + j) = 0;
   \   00000056   0x....             LDR.N    R2,??DataTable7_5
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0x2390             MOVS     R3,#+144
   \   0000005C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000060   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000062   0x188A             ADDS     R2,R1,R2
   \   00000064   0x2300             MOVS     R3,#+0
   \   00000066   0x7313             STRB     R3,[R2, #+12]
    182              }
   \   00000068   0x1C49             ADDS     R1,R1,#+1
   \   0000006A   0xE7F1             B.N      ??MessagingInitialize_2
    183            }
   \                     ??MessagingInitialize_3: (+1)
   \   0000006C   0x1C40             ADDS     R0,R0,#+1
   \   0000006E   0xE7CE             B.N      ??MessagingInitialize_0
    184          
    185            /* Clear the message status queue */
    186            for(u8 i = 0; i < U8_STATUS_QUEUE_SIZE; i++)
   \                     ??MessagingInitialize_1: (+1)
   \   00000070   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_4: (+1)
   \   00000072   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000074   0x2840             CMP      R0,#+64
   \   00000076   0xDA16             BGE.N    ??MessagingInitialize_5
    187            {
    188              Msg_asStatusQueue[i].u32Token = 0;
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x....             LDR.N    R2,??DataTable7
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x230C             MOVS     R3,#+12
   \   00000080   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000084   0x6011             STR      R1,[R2, #+0]
    189              Msg_asStatusQueue[i].eState = EMPTY;
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x....             LDR.N    R2,??DataTable7
   \   0000008A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000008C   0x230C             MOVS     R3,#+12
   \   0000008E   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000092   0x7111             STRB     R1,[R2, #+4]
    190              Msg_asStatusQueue[i].u32Timestamp = 0;
   \   00000094   0x2100             MOVS     R1,#+0
   \   00000096   0x....             LDR.N    R2,??DataTable7
   \   00000098   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000009A   0x230C             MOVS     R3,#+12
   \   0000009C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   000000A0   0x6091             STR      R1,[R2, #+8]
    191            }
   \   000000A2   0x1C40             ADDS     R0,R0,#+1
   \   000000A4   0xE7E5             B.N      ??MessagingInitialize_4
    192          
    193            Msg_psNextStatus = &Msg_asStatusQueue[0];
   \                     ??MessagingInitialize_5: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable7
   \   000000A8   0x....             LDR.N    R1,??DataTable7_6
   \   000000AA   0x6008             STR      R0,[R1, #+0]
    194          
    195            G_u32MessagingFlags = 0;
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0x....             LDR.N    R1,??DataTable7_7
   \   000000B0   0x6008             STR      R0,[R1, #+0]
    196            Messaging_pfnStateMachine = MessagingSM_Idle;
   \   000000B2   0x.... 0x....      ADR.W    R0,MessagingSM_Idle
   \   000000B6   0x....             LDR.N    R1,??DataTable7_8
   \   000000B8   0x6008             STR      R0,[R1, #+0]
    197          
    198          } /* end MessagingInitialize() */
   \   000000BA   0x4770             BX       LR               ;; return
    199          
    200          
    201          /*!--------------------------------------------------------------------------------------------------------------------
    202          @fn void MessagingRunActiveState(void)
    203          
    204          @brief Selects and runs one iteration of the current state in the state machine.
    205          
    206          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    207          may take 1ms / n to execute.
    208          
    209          Requires:
    210          - State machine function pointer points at current state
    211          
    212          Promises:
    213          - Calls the function to pointed by the state machine function pointer
    214          
    215          */

   \                                 In section .text, align 2, keep-with-next
    216          void MessagingRunActiveState(void)
    217          {
   \                     MessagingRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    218            Messaging_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable7_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    219          
    220          } /* end MessagingRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    221          
    222          
    223          /*!--------------------------------------------------------------------------------------------------------------------
    224          @fn u32 QueueMessage(MessageType** ppsTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
    225          
    226          @brief Allocates one of the positions in the message queue to the calling function's send queue.
    227          
    228          Requires:
    229          - Msg_asPool should not be full 
    230          
    231          @param  ppsTargetTxBuffer_ is the peripheral transmit buffer where the message will be queued
    232          @param  u32MessageSize_ is the size of the message data array in bytes
    233          @param  pu8MessageData_ points to the message data array
    234          
    235          Promises:
    236          - The message is inserted into the target list and assigned a token
    237          - If the message is created successfully, the message token is returned; otherwise, NULL is returned
    238          
    239          */

   \                                 In section .text, align 2, keep-with-next
    240          u32 QueueMessage(MessageType** ppsTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
    241          {
   \                     QueueMessage: (+1)
   \   00000000   0xE92D 0x4FF2      PUSH     {R1,R4-R11,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x0015             MOVS     R5,R2
    242            MessageSlotType *psSlotParser;
    243            MessageType *psNewMessage;
    244            MessageType *psListParser;
    245            u8  u8SlotsRequired;
    246            u32 u32BytesRemaining = u32MessageSize_;
   \   0000000A   0xF8DD 0x9008      LDR      R9,[SP, #+8]
    247            u32 u32CurrentMessageSize = 0;
   \   0000000E   0xF05F 0x0A00      MOVS     R10,#+0
    248            u32 u32MaxTxMessageLength = (u32)(U16_MAX_TX_MESSAGE_LENGTH) & 0x0000FFFF;
   \   00000012   0xF05F 0x0B80      MOVS     R11,#+128
    249            
    250            /* Check for empty message */
    251            if(u32MessageSize_ == 0)
   \   00000016   0x9802             LDR      R0,[SP, #+8]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD101             BNE.N    ??QueueMessage_0
    252            {
    253              return(0);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE085             B.N      ??QueueMessage_1
    254            }
    255          
    256            /* Carefully check for available space in the message pool */
    257            u8SlotsRequired = (u8)(u32MessageSize_ / u32MaxTxMessageLength);
   \                     ??QueueMessage_0: (+1)
   \   00000020   0x9802             LDR      R0,[SP, #+8]
   \   00000022   0xFBB0 0xF0FB      UDIV     R0,R0,R11
   \   00000026   0xF88D 0x0000      STRB     R0,[SP, #+0]
    258            if( (u32MessageSize_ % u32MaxTxMessageLength) != 0 )
   \   0000002A   0x9802             LDR      R0,[SP, #+8]
   \   0000002C   0x9902             LDR      R1,[SP, #+8]
   \   0000002E   0xFBB1 0xF1FB      UDIV     R1,R1,R11
   \   00000032   0xFB0B 0x0011      MLS      R0,R11,R1,R0
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD004             BEQ.N    ??QueueMessage_2
    259            {
    260              u8SlotsRequired++;
   \   0000003A   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0xF88D 0x0000      STRB     R0,[SP, #+0]
    261            }
    262          
    263            if( (Msg_u8QueuedMessageCount + u8SlotsRequired) > U8_TX_QUEUE_SIZE)
   \                     ??QueueMessage_2: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable7_3
   \   00000046   0x7800             LDRB     R0,[R0, #+0]
   \   00000048   0xF89D 0x1000      LDRB     R1,[SP, #+0]
   \   0000004C   0x1808             ADDS     R0,R1,R0
   \   0000004E   0x2821             CMP      R0,#+33
   \   00000050   0xDB07             BLT.N    ??QueueMessage_3
    264            {
    265              G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_FULL;
   \   00000052   0x....             LDR.N    R0,??DataTable7_7
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000005A   0x....             LDR.N    R1,??DataTable7_7
   \   0000005C   0x6008             STR      R0,[R1, #+0]
    266              return(0);
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xE064             B.N      ??QueueMessage_1
    267            }
    268          
    269            /* Space available, so proceed with allocation.  Though only one message is queued at a time, we
    270            use a while loop to handle messages that are too big and must be split into different slots.  The slots
    271            are always sequential and the message processor will send the bytes continuously across slots */
    272            while(u32BytesRemaining)
   \                     ??QueueMessage_3: (+1)
   \   00000062   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000066   0xD060             BEQ.N    ??QueueMessage_4
    273            {
    274              /* Increment the message count.  Interrupts are disabled here since this global
    275              can be accessed by an interrupt. */
    276              __disable_irq();
   \   00000068   0xB672             CPSID    I
    277              Msg_u8QueuedMessageCount++;
   \   0000006A   0x....             LDR.N    R0,??DataTable7_3
   \   0000006C   0x7800             LDRB     R0,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0x....             LDR.N    R1,??DataTable7_3
   \   00000072   0x7008             STRB     R0,[R1, #+0]
    278              __enable_irq();
   \   00000074   0xB662             CPSIE    I
    279            
    280              /* Flag if we're above the high watermark */
    281              if(Msg_u8QueuedMessageCount >= U8_TX_QUEUE_WATERMARK)
   \   00000076   0x....             LDR.N    R0,??DataTable7_3
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x281D             CMP      R0,#+29
   \   0000007C   0xDB06             BLT.N    ??QueueMessage_5
    282              {
    283                G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_ALMOST_FULL;
   \   0000007E   0x....             LDR.N    R0,??DataTable7_7
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000086   0x....             LDR.N    R1,??DataTable7_7
   \   00000088   0x6008             STR      R0,[R1, #+0]
   \   0000008A   0xE005             B.N      ??QueueMessage_6
    284              }
    285              else
    286              {
    287                G_u32MessagingFlags &= ~_MESSAGING_TX_QUEUE_ALMOST_FULL;
   \                     ??QueueMessage_5: (+1)
   \   0000008C   0x....             LDR.N    R0,??DataTable7_7
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000094   0x....             LDR.N    R1,??DataTable7_7
   \   00000096   0x6008             STR      R0,[R1, #+0]
    288              }
    289          
    290              /* Find an empty slot: this is non-circular and there must be at least one free slot if we're here */
    291              psSlotParser = &Msg_asPool[0];
   \                     ??QueueMessage_6: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable7_5
   \   0000009A   0x0006             MOVS     R6,R0
    292              while(!psSlotParser->bFree)
   \                     ??QueueMessage_7: (+1)
   \   0000009C   0x7830             LDRB     R0,[R6, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD101             BNE.N    ??QueueMessage_8
    293              {
    294                psSlotParser++;
   \   000000A2   0x3690             ADDS     R6,R6,#+144
   \   000000A4   0xE7FA             B.N      ??QueueMessage_7
    295              }
    296              
    297              /* Allocate the slot and set the message pointer */
    298              psSlotParser->bFree = FALSE;
   \                     ??QueueMessage_8: (+1)
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7030             STRB     R0,[R6, #+0]
    299              psNewMessage = &(psSlotParser->Message);
   \   000000AA   0x1D30             ADDS     R0,R6,#+4
   \   000000AC   0x0007             MOVS     R7,R0
    300            
    301              /* Check the message size and split the message up if necessary */
    302              if(u32BytesRemaining > u32MaxTxMessageLength)
   \   000000AE   0x45CB             CMP      R11,R9
   \   000000B0   0xD203             BCS.N    ??QueueMessage_9
    303              {
    304                u32CurrentMessageSize = u32MaxTxMessageLength;
   \   000000B2   0x46DA             MOV      R10,R11
    305                u32BytesRemaining -= u32MaxTxMessageLength;
   \   000000B4   0xEBB9 0x090B      SUBS     R9,R9,R11
   \   000000B8   0xE002             B.N      ??QueueMessage_10
    306              }
    307              else
    308              {
    309                u32CurrentMessageSize = u32BytesRemaining;
   \                     ??QueueMessage_9: (+1)
   \   000000BA   0x46CA             MOV      R10,R9
    310                u32BytesRemaining = 0;
   \   000000BC   0x2000             MOVS     R0,#+0
   \   000000BE   0x4681             MOV      R9,R0
    311              }
    312              
    313              /* Copy all the data to the allocated message structure */
    314              psNewMessage->u32Token      = Msg_u32Token;
   \                     ??QueueMessage_10: (+1)
   \   000000C0   0x....             LDR.N    R0,??DataTable7_4
   \   000000C2   0x6800             LDR      R0,[R0, #+0]
   \   000000C4   0x6038             STR      R0,[R7, #+0]
    315              psNewMessage->u32Size       = u32CurrentMessageSize;
   \   000000C6   0xF8C7 0xA004      STR      R10,[R7, #+4]
    316              psNewMessage->psNextMessage = NULL;
   \   000000CA   0x2000             MOVS     R0,#+0
   \   000000CC   0xF8C7 0x0088      STR      R0,[R7, #+136]
    317              
    318              /* Add the data into the payload */
    319              for(u32 i = 0; i < psNewMessage->u32Size; i++)
   \   000000D0   0x2000             MOVS     R0,#+0
   \                     ??QueueMessage_11: (+1)
   \   000000D2   0x6879             LDR      R1,[R7, #+4]
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xD205             BCS.N    ??QueueMessage_12
    320              {
    321                *(psNewMessage->pu8Message + i) = *pu8MessageData_;
   \   000000D8   0x7829             LDRB     R1,[R5, #+0]
   \   000000DA   0x19C2             ADDS     R2,R0,R7
   \   000000DC   0x7211             STRB     R1,[R2, #+8]
    322                pu8MessageData_++;
   \   000000DE   0x1C6D             ADDS     R5,R5,#+1
    323              }
   \   000000E0   0x1C40             ADDS     R0,R0,#+1
   \   000000E2   0xE7F6             B.N      ??QueueMessage_11
    324            
    325              /* Link the new message into the client's transmit buffer.  This must happen
    326              with interrupts off since other functions can operate on the transmit buffer. */
    327              __disable_irq();
   \                     ??QueueMessage_12: (+1)
   \   000000E4   0xB672             CPSID    I
    328              
    329              /* Handle an empty list */
    330              if(*ppsTargetTxBuffer_ == NULL)
   \   000000E6   0x6820             LDR      R0,[R4, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD101             BNE.N    ??QueueMessage_13
    331              {
    332                *ppsTargetTxBuffer_ = psNewMessage;
   \   000000EC   0x6027             STR      R7,[R4, #+0]
   \   000000EE   0xE00A             B.N      ??QueueMessage_14
    333              }
    334          
    335              /* Add the message to the end of the list */
    336              else
    337              {
    338                /* Find the last node */
    339                psListParser = *ppsTargetTxBuffer_;
   \                     ??QueueMessage_13: (+1)
   \   000000F0   0x6820             LDR      R0,[R4, #+0]
   \   000000F2   0x4680             MOV      R8,R0
    340                while(psListParser->psNextMessage != NULL)
   \                     ??QueueMessage_15: (+1)
   \   000000F4   0xF8D8 0x0088      LDR      R0,[R8, #+136]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD002             BEQ.N    ??QueueMessage_16
    341                {
    342                  psListParser = psListParser->psNextMessage;
   \   000000FC   0xF8D8 0x8088      LDR      R8,[R8, #+136]
   \   00000100   0xE7F8             B.N      ??QueueMessage_15
    343                }
    344               
    345                /* Found the end: add the new node */
    346                psListParser->psNextMessage = psNewMessage;
   \                     ??QueueMessage_16: (+1)
   \   00000102   0xF8C8 0x7088      STR      R7,[R8, #+136]
    347              }
    348          
    349              /* Safe to re-enable interrupts */
    350              __enable_irq();
   \                     ??QueueMessage_14: (+1)
   \   00000106   0xB662             CPSIE    I
    351          
    352              /* Update the Public status of the message in the status queue */
    353              AddNewMessageStatus(Msg_u32Token);
   \   00000108   0x....             LDR.N    R0,??DataTable7_4
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x.... 0x....      BL       AddNewMessageStatus
    354            
    355              /* Increment message token and catch the rollover every 4 billion messages... Token 0 is not allowed. */
    356              Msg_u32Token++;
   \   00000110   0x....             LDR.N    R0,??DataTable7_4
   \   00000112   0x6800             LDR      R0,[R0, #+0]
   \   00000114   0x1C40             ADDS     R0,R0,#+1
   \   00000116   0x....             LDR.N    R1,??DataTable7_4
   \   00000118   0x6008             STR      R0,[R1, #+0]
    357              if(Msg_u32Token == 0)
   \   0000011A   0x....             LDR.N    R0,??DataTable7_4
   \   0000011C   0x6800             LDR      R0,[R0, #+0]
   \   0000011E   0x2800             CMP      R0,#+0
   \   00000120   0xD19F             BNE.N    ??QueueMessage_3
    358              {
    359                Msg_u32Token = 1;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x....             LDR.N    R1,??DataTable7_4
   \   00000126   0x6008             STR      R0,[R1, #+0]
   \   00000128   0xE79B             B.N      ??QueueMessage_3
    360              }
    361                
    362            } /* end while */
    363          
    364            /* Return only the current (and highest) message token, as it will be the last portion to be sent if the message was split up */
    365            return(psNewMessage->u32Token);
   \                     ??QueueMessage_4: (+1)
   \   0000012A   0x6838             LDR      R0,[R7, #+0]
   \                     ??QueueMessage_1: (+1)
   \   0000012C   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
    366            
    367          } /* end QueueMessage() */
    368          
    369          
    370          /*!--------------------------------------------------------------------------------------------------------------------
    371          @fn void DeQueueMessage(MessageType** pTargetQueue_)
    372          
    373          @brief Removes a message from a message queue and adds it back to the pool.
    374          
    375          Requires:
    376          - The message to be removed has been completely sent and is no longer in use
    377          - New message cannot be added into the list during this function (via interrupts)
    378          
    379          @param  pTargetQueue_ is a FIFO linked-list where the message that needs to be killed is at the front of the list
    380          
    381          Promises:
    382          - The first message in the list is deleted; the list is hooked back up
    383          - The message space is added back to the available message queue
    384          
    385          */

   \                                 In section .text, align 2, keep-with-next
    386          void DeQueueMessage(MessageType** pTargetQueue_)
    387          {
    388            MessageSlotType *psSlotParser;
    389                
    390            /* Make sure there is a message to kill */
    391            if(*pTargetQueue_ == NULL)
   \                     DeQueueMessage: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD106             BNE.N    ??DeQueueMessage_0
    392            {
    393              G_u32MessagingFlags |= _DEQUEUE_GOT_NULL;
   \   00000006   0x....             LDR.N    R2,??DataTable7_7
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000E   0x....             LDR.N    R3,??DataTable7_7
   \   00000010   0x601A             STR      R2,[R3, #+0]
    394              return;
   \   00000012   0xE01F             B.N      ??DeQueueMessage_1
    395            }
    396            
    397            /* Find the message's slot: this message pool is non-circular and the message must be one of the slots */
    398            psSlotParser = &Msg_asPool[0];
   \                     ??DeQueueMessage_0: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable7_5
   \   00000016   0x0011             MOVS     R1,R2
    399            while( (&psSlotParser->Message != *pTargetQueue_) && 
    400                   (psSlotParser != &Msg_asPool[U8_TX_QUEUE_SIZE]) )
   \                     ??DeQueueMessage_2: (+1)
   \   00000018   0x1D0A             ADDS     R2,R1,#+4
   \   0000001A   0x6803             LDR      R3,[R0, #+0]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD004             BEQ.N    ??DeQueueMessage_3
   \   00000020   0x....             LDR.N    R2,??DataTable7_9
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD001             BEQ.N    ??DeQueueMessage_3
    401            {
    402              psSlotParser++;
   \   00000026   0x3190             ADDS     R1,R1,#+144
   \   00000028   0xE7F6             B.N      ??DeQueueMessage_2
    403            }
    404          
    405            /* Make sure the message has been found */
    406            if(psSlotParser == &Msg_asPool[U8_TX_QUEUE_SIZE])
   \                     ??DeQueueMessage_3: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable7_9
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD106             BNE.N    ??DeQueueMessage_4
    407            {
    408              G_u32MessagingFlags |= _DEQUEUE_MSG_NOT_FOUND;
   \   00000030   0x....             LDR.N    R2,??DataTable7_7
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   00000038   0x....             LDR.N    R3,??DataTable7_7
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    409              return;
   \   0000003C   0xE00A             B.N      ??DeQueueMessage_1
    410            }
    411          
    412            /* Unhook the message from the current owner's queue and put it back in the pool */
    413            *pTargetQueue_ = (*pTargetQueue_)->psNextMessage;
   \                     ??DeQueueMessage_4: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0xF8D2 0x2088      LDR      R2,[R2, #+136]
   \   00000044   0x6002             STR      R2,[R0, #+0]
    414            psSlotParser->bFree = TRUE;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x700A             STRB     R2,[R1, #+0]
    415            Msg_u8QueuedMessageCount--;
   \   0000004A   0x....             LDR.N    R2,??DataTable7_3
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
   \   00000050   0x....             LDR.N    R3,??DataTable7_3
   \   00000052   0x701A             STRB     R2,[R3, #+0]
    416            
    417          } /* end DeQueueMessage() */
   \                     ??DeQueueMessage_1: (+1)
   \   00000054   0x4770             BX       LR               ;; return
    418          
    419          
    420          /*!--------------------------------------------------------------------------------------------------------------------
    421          @fn void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
    422          
    423          @brief Changes the status of a message in the statue queue.
    424          
    425          Requires:
    426          @param u32Token_ is message that should be in the status queue
    427          @param eNewState_ is the desired status setting for the message
    428          
    429          Promises:
    430          - if the token is found, the eState of the message is set to eNewState_
    431          
    432          */

   \                                 In section .text, align 2, keep-with-next
    433          void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
    434          {
    435            MessageStatusType* pListParser = &Msg_asStatusQueue[0];
   \                     UpdateMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable7
    436            
    437            /* Search for the token */
    438            while( (pListParser->u32Token != u32Token_) && (pListParser != &Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE]) )
   \                     ??UpdateMessageStatus_0: (+1)
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0x4283             CMP      R3,R0
   \   00000006   0xD004             BEQ.N    ??UpdateMessageStatus_1
   \   00000008   0x....             LDR.N    R3,??DataTable7_1
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD001             BEQ.N    ??UpdateMessageStatus_1
    439            {
    440              pListParser++;
   \   0000000E   0x320C             ADDS     R2,R2,#+12
   \   00000010   0xE7F7             B.N      ??UpdateMessageStatus_0
    441            }
    442          
    443            /* If the token was found, change the status */
    444            if(pListParser != &Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE])
   \                     ??UpdateMessageStatus_1: (+1)
   \   00000012   0x....             LDR.N    R3,??DataTable7_1
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD000             BEQ.N    ??UpdateMessageStatus_2
    445            {
    446              pListParser->eState = eNewState_;
   \   00000018   0x7111             STRB     R1,[R2, #+4]
    447            }
    448            
    449          } /* end UpdateMessageStatus() */
   \                     ??UpdateMessageStatus_2: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    450          
    451          
    452          /*------------------------------------------------------------------------------------------------------------------*/
    453          /*! @privatesection */                                                                                            
    454          /*--------------------------------------------------------------------------------------------------------------------*/
    455          
    456          /*!--------------------------------------------------------------------------------------------------------------------
    457          @fn static void AddNewMessageStatus(u32 u32Token_)
    458          
    459          @brief Adds a new message into the message status queue.  
    460          
    461          Due to the tendency of applications to forget that they wrote a message here, 
    462          this buffer is circular and will overwrite the oldest message if it needs space for a 
    463          new message.
    464          
    465          Requires:
    466          - Msg_psNextStatus points to the next status location
    467          
    468          @param u32Token_ is the token of the message of interest
    469          
    470          Promises:
    471          - A new status is created at Msg_psNextStatus indexed by u32Token_
    472          
    473          */

   \                                 In section .text, align 2, keep-with-next
    474          static void AddNewMessageStatus(u32 u32Token_)
    475          {
    476            /* Install the new message */
    477            Msg_psNextStatus->u32Token = u32Token_;
   \                     AddNewMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable7_6
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6008             STR      R0,[R1, #+0]
    478            Msg_psNextStatus->eState = WAITING;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x....             LDR.N    R2,??DataTable7_6
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x7111             STRB     R1,[R2, #+4]
    479            Msg_psNextStatus->u32Timestamp = G_u32SystemTime1ms;
   \   0000000E   0x....             LDR.N    R1,??DataTable7_2
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable7_6
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x6091             STR      R1,[R2, #+8]
    480            
    481            /* Safely advance the pointer */
    482            Msg_psNextStatus++;
   \   00000018   0x....             LDR.N    R1,??DataTable7_6
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x310C             ADDS     R1,R1,#+12
   \   0000001E   0x....             LDR.N    R2,??DataTable7_6
   \   00000020   0x6011             STR      R1,[R2, #+0]
    483            if(Msg_psNextStatus == &Msg_asStatusQueue[U8_STATUS_QUEUE_SIZE])
   \   00000022   0x....             LDR.N    R1,??DataTable7_6
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x....             LDR.N    R2,??DataTable7_1
   \   00000028   0x4291             CMP      R1,R2
   \   0000002A   0xD102             BNE.N    ??AddNewMessageStatus_0
    484            {
    485              Msg_psNextStatus = &Msg_asStatusQueue[0];
   \   0000002C   0x....             LDR.N    R1,??DataTable7
   \   0000002E   0x....             LDR.N    R2,??DataTable7_6
   \   00000030   0x6011             STR      R1,[R2, #+0]
    486            }
    487            
    488          } /* end AddNewMessageStatus() */
   \                     ??AddNewMessageStatus_0: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    489          
    490          /**********************************************************************************************************************
    491          State Machine Function Definitions
    492          **********************************************************************************************************************/
    493          
    494          /*!-------------------------------------------------------------------------------------------------------------------
    495          @fn static void MessagingSM_Idle(void)
    496          
    497          @brief Right now this doesn't do anything 
    498          */

   \                                 In section .text, align 4, keep-with-next
    499          static void MessagingSM_Idle(void)
    500          {
    501            static u32 u32CleaningTime = U32_MSG_STATUS_CLEANING_TIME;
    502            
    503            /* Periodically check for stale messages */
    504            if(--u32CleaningTime == 0)
   \                     MessagingSM_Idle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable7_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable7_10
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable7_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE.N    ??MessagingSM_Idle_0
    505            {
    506              u32CleaningTime = U32_MSG_STATUS_CLEANING_TIME;
   \   00000012   0xF242 0x7010      MOVW     R0,#+10000
   \   00000016   0x....             LDR.N    R1,??DataTable7_10
   \   00000018   0x6008             STR      R0,[R1, #+0]
    507              
    508              /* ??? Probably should add clean of the main message queue to detect any messages that have become stuck */
    509            }
    510              
    511          } /* end MessagingSM_Idle() */
   \                     ??MessagingSM_Idle_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .data, align 4
   \                     ??u32CleaningTime:
   \   00000000   0x00002710         DC32 10000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     Msg_asStatusQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     Msg_asStatusQueue+0x300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     Msg_u8QueuedMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x........         DC32     Msg_u32Token

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x........         DC32     Msg_asPool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x........         DC32     Msg_psNextStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x........         DC32     G_u32MessagingFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x........         DC32     Messaging_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x........         DC32     Msg_asPool+0x1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x........         DC32     ??u32CleaningTime
    512          
    513          
    514          #if 0
    515          /*-------------------------------------------------------------------------------------------------------------------*/
    516          /* Handle an error */
    517          static void MessagingSM_Error(void)          
    518          {
    519            
    520          } /* end MessagingSM_Error() */
    521          #endif
    522          
    523          
    524          
    525          /*--------------------------------------------------------------------------------------------------------------------*/
    526          /* End of File */
    527          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AddNewMessageStatus
       0   DeQueueMessage
       0   MessagingInitialize
       8   MessagingRunActiveState
         8   -- Indirect call
       0   MessagingSM_Idle
       0   QueryMessageStatus
      48   QueueMessage
        48   -> AddNewMessageStatus
       0   UpdateMessageStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
      52  AddNewMessageStatus
      86  DeQueueMessage
       4  G_u32MessagingFlags
     188  MessagingInitialize
      10  MessagingRunActiveState
      28  MessagingSM_Idle
       4  Messaging_pfnStateMachine
    4608  Msg_asPool
     768  Msg_asStatusQueue
       4  Msg_psNextStatus
       4  Msg_u32Token
       1  Msg_u8QueuedMessageCount
      68  QueryMessageStatus
     304  QueueMessage
      28  UpdateMessageStatus
       4  u32CleaningTime

 
 5 393 bytes in section .bss
     4 bytes in section .data
   808 bytes in section .text
 
   808 bytes of CODE memory
 5 397 bytes of DATA memory

Errors: none
Warnings: none
