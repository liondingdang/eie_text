###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_spi.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_spi.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\sam3u_spi.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_spi.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_spi.c
      1          /*!**********************************************************************************************************************
      2          @file sam3u_spi.c                                                                
      3          @brief Provides a driver to use the dedicated SPI peripheral to send and 
      4          receive data using interrupts.
      5          
      6          ------------------------------------------------------------------------------------------------------------------------
      7          GLOBALS
      8          - G_u32Spi0ApplicationFlags
      9          
     10          CONSTANTS
     11          - NONE
     12          
     13          TYPES
     14          - SpiBitOrderType
     15          - SpiModeType
     16          - SpiRxStatusType
     17          - SpiConfigurationType
     18          - SpiPeripheralType
     19          
     20          PUBLIC FUNCTIONS
     21          - SpiPeripheralType* SpiRequest(SpiConfigurationType* psSpiConfig_)
     22          - void SpiRelease(SpiPeripheralType* psSpiPeripheral_)
     23          - u32 SpiWriteByte(SpiPeripheralType* psSpiPeripheral_, u8 u8Byte_)
     24          - u32 SpiWriteData(SpiPeripheralType* psSpiPeripheral_, u32 u32Size_, u8* pu8Data_)
     25          
     26          Master mode only:
     27          - bool SpiReadByte(SpiPeripheralType* psSpiPeripheral_)
     28          - bool SpiReadData(SpiPeripheralType* psSpiPeripheral_, u16 u16Size_)
     29          - SpiRxStatusType SpiQueryReceiveStatus(SpiPeripheralType* psSpiPeripheral_)
     30          
     31          PROTECTED FUNCTIONS
     32          - void SpiInitialize(void)
     33          - void SpiRunActiveState(void)
     34          - void SpiManualMode(void)
     35          - void SPI0_IRQHandler(void)
     36          
     37          
     38          **********************************************************************************************************************/
     39          
     40          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable11_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     41          
     42          /***********************************************************************************************************************
     43          Global variable definitions with scope across entire project.
     44          All Global variable names shall start with "G_<type>Spi"
     45          ***********************************************************************************************************************/
     46          /* New variables */

   \                                 In section .bss, align 4
     47          u32 G_u32Spi0ApplicationFlags;                   /*!< @brief Status flags meant for application using this SPI peripheral */
   \                     G_u32Spi0ApplicationFlags:
   \   00000000                      DS8 4
     48          
     49          
     50          /*--------------------------------------------------------------------------------------------------------------------*/
     51          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     52          extern volatile u32 G_u32SystemTime1ms;          /*!< @brief From main.c */
     53          extern volatile u32 G_u32SystemTime1s;           /*!< @brief From main.c */
     54          extern volatile u32 G_u32SystemFlags;            /*!< @brief From main.c */
     55          extern volatile u32 G_u32ApplicationFlags;       /*!< @brief From main.c */
     56          
     57          
     58          /***********************************************************************************************************************
     59          Global variable definitions with scope limited to this local application.
     60          Variable names shall start with "SPI_<type>" and be declared as static.
     61          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     62          static fnCode_type Spi_pfnStateMachine;          /*!< @brief The SPI application state machine */
   \                     Spi_pfnStateMachine:
   \   00000000                      DS8 4
     63          

   \                                 In section .bss, align 4
     64          static u32 SPI_u32Flags;                         /*!< @brief Application flags for SPI */
   \                     SPI_u32Flags:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          static SpiPeripheralType SPI_Peripheral0;        /*!< @brief SPI peripheral object */
   \                     SPI_Peripheral0:
   \   00000000                      DS8 44
     67          
     68          
     69          /***********************************************************************************************************************
     70          Function Definitions
     71          ***********************************************************************************************************************/
     72          
     73          /*--------------------------------------------------------------------------------------------------------------------*/
     74          /*! @publicsection */                                                                                            
     75          /*--------------------------------------------------------------------------------------------------------------------*/
     76          
     77          /*!---------------------------------------------------------------------------------------------------------------------
     78          @fn SpiPeripheralType* SpiRequest(SpiConfigurationType* psSpiConfig_)
     79          
     80          @brief Requests access to an SPI resource.  
     81          
     82          If the resource is available, the transmit and receive parameters are set up
     83          and the peripheral is made ready to use in the application. The peripheral will be 
     84          configured in different ways for different SPI modes.  The following modes are supported:
     85          
     86          SPI_MASTER: transmit and receive using peripheral registers on byte-wise basis using 
     87          interrupts.  Transmit is initiated through Message task.  Receive is based on
     88          queued Rx bytes.  Master receive is non-circular.  The Rx buffer is initialized
     89          to SPI_DUMMY_BYTE and is the source for the transmit dummies.
     90          
     91          SPI_SLAVE: transmit through peripheral registers on byte-wise basis using interrupts.
     92          Transmit is initiated through Message.  Receive set up per-byte using peripheral
     93          registers and interrupts and assumes a circular Rx buffer.
     94          
     95          Requires:
     96          - SPI peripheral register initialization values in configuration.h must be set 
     97            correctly; currently this does not support different SPI configurations 
     98            for multiple Slaves on the same bus - all peripherals on the bus must work with
     99            the same setup.
    100          
    101          @param psSpiConfig_ has the SPI peripheral number, address of the RxBuffer and the RxBuffer size
    102          
    103          Promises:
    104          - Returns a pointer to the requested SPI peripheral object if the resource is available; otherwise returns NULL
    105          - Peripheral is enabled
    106          - Peripheral interrupts are enabled as required for the selected mode
    107          
    108          */

   \                                 In section .text, align 2, keep-with-next
    109          SpiPeripheralType* SpiRequest(SpiConfigurationType* psSpiConfig_)
    110          {
   \                     SpiRequest: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
    111            /* If the peripheral is already assigned, return NULL now */
    112            if( (SPI_Peripheral0.u32PrivateFlags) & _SPI_PERIPHERAL_ASSIGNED )
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x02C0             LSLS     R0,R0,#+11
   \   0000000C   0xD501             BPL.N    ??SpiRequest_0
    113            {
    114              return(NULL);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE09C             B.N      ??SpiRequest_1
    115            }
    116          
    117            /* Activate and configure the peripheral */
    118            AT91C_BASE_PMC->PMC_PCER |= (1 << SPI_Peripheral0.u8PeripheralId);
   \                     ??SpiRequest_0: (+1)
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable11_4  ;; 0x400e0410
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable11_3
   \   0000001E   0xF992 0x200E      LDRSB    R2,[R2, #+14]
   \   00000022   0x4091             LSLS     R1,R1,R2
   \   00000024   0x4308             ORRS     R0,R1,R0
   \   00000026   0x.... 0x....      LDR.W    R1,??DataTable11_4  ;; 0x400e0410
   \   0000002A   0x6008             STR      R0,[R1, #+0]
    119            
    120            SPI_Peripheral0.pCsGpioAddress   = psSpiConfig_->pCsGpioAddress;
   \   0000002C   0x6860             LDR      R0,[R4, #+4]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000032   0x6048             STR      R0,[R1, #+4]
    121            SPI_Peripheral0.u32CsPin         = psSpiConfig_->u32CsPin;
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000003A   0x6088             STR      R0,[R1, #+8]
    122            SPI_Peripheral0.eBitOrder        = psSpiConfig_->eBitOrder;
   \   0000003C   0x7B20             LDRB     R0,[R4, #+12]
   \   0000003E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000042   0x7308             STRB     R0,[R1, #+12]
    123            SPI_Peripheral0.eSpiMode         = psSpiConfig_->eSpiMode;
   \   00000044   0x7B60             LDRB     R0,[R4, #+13]
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000004A   0x7348             STRB     R0,[R1, #+13]
    124            SPI_Peripheral0.pu8RxBuffer      = psSpiConfig_->pu8RxBufferAddress;
   \   0000004C   0x6920             LDR      R0,[R4, #+16]
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000052   0x6148             STR      R0,[R1, #+20]
    125            SPI_Peripheral0.ppu8RxNextByte   = psSpiConfig_->ppu8RxNextByte;
   \   00000054   0x6960             LDR      R0,[R4, #+20]
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000005A   0x6188             STR      R0,[R1, #+24]
    126            SPI_Peripheral0.u16RxBufferSize  = psSpiConfig_->u16RxBufferSize;
   \   0000005C   0x89E0             LDRH     R0,[R4, #+14]
   \   0000005E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000062   0x8388             STRH     R0,[R1, #+28]
    127            SPI_Peripheral0.u32PrivateFlags |= _SPI_PERIPHERAL_ASSIGNED;
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000068   0x6900             LDR      R0,[R0, #+16]
   \   0000006A   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   0000006E   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000072   0x6108             STR      R0,[R1, #+16]
    128             
    129            SPI_Peripheral0.pBaseAddress->SPI_CR  = SPI0_CR_INIT;
   \   00000074   0x2002             MOVS     R0,#+2
   \   00000076   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    130            SPI_Peripheral0.pBaseAddress->SPI_MR  = SPI0_MR_INIT;
   \   0000007E   0x2021             MOVS     R0,#+33
   \   00000080   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000084   0x6809             LDR      R1,[R1, #+0]
   \   00000086   0x6048             STR      R0,[R1, #+4]
    131            SPI_Peripheral0.pBaseAddress->SPI_IER = SPI0_IER_INIT;
   \   00000088   0x2000             MOVS     R0,#+0
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000008E   0x6809             LDR      R1,[R1, #+0]
   \   00000090   0x6148             STR      R0,[R1, #+20]
    132            SPI_Peripheral0.pBaseAddress->SPI_IDR = SPI0_IDR_INIT;
   \   00000092   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0x6188             STR      R0,[R1, #+24]
    133          
    134            SPI_Peripheral0.pBaseAddress->SPI_CSR[0] = SPI0_CSR0_INIT;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x5303001
   \   000000A2   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x6308             STR      R0,[R1, #+48]
    135            SPI_Peripheral0.pBaseAddress->SPI_CSR[1] = SPI0_CSR1_INIT;
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x5303001
   \   000000AE   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000B2   0x6809             LDR      R1,[R1, #+0]
   \   000000B4   0x6348             STR      R0,[R1, #+52]
    136            SPI_Peripheral0.pBaseAddress->SPI_CSR[2] = SPI0_CSR2_INIT;
   \   000000B6   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x5303001
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000BE   0x6809             LDR      R1,[R1, #+0]
   \   000000C0   0x6388             STR      R0,[R1, #+56]
    137            SPI_Peripheral0.pBaseAddress->SPI_CSR[3] = SPI0_CSR3_INIT;
   \   000000C2   0x.... 0x....      LDR.W    R0,??DataTable11_5  ;; 0x5303001
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000CA   0x6809             LDR      R1,[R1, #+0]
   \   000000CC   0x63C8             STR      R0,[R1, #+60]
    138            
    139            /* Special considerations for SPI Slaves */
    140            if(SPI_Peripheral0.eSpiMode == SPI_SLAVE)
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000D2   0x7B40             LDRB     R0,[R0, #+13]
   \   000000D4   0x2801             CMP      R0,#+1
   \   000000D6   0xD129             BNE.N    ??SpiRequest_2
    141            {
    142              /* Initialize the receive buffer to dummies and set up a dummy transfer */
    143              memset(SPI_Peripheral0.pu8RxBuffer, SPI_DUMMY, SPI_Peripheral0.u16RxBufferSize);
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000DC   0x8B85             LDRH     R5,[R0, #+28]
   \   000000DE   0x26AA             MOVS     R6,#+170
   \   000000E0   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000E4   0x6947             LDR      R7,[R0, #+20]
   \   000000E6   0x0032             MOVS     R2,R6
   \   000000E8   0x0029             MOVS     R1,R5
   \   000000EA   0x0038             MOVS     R0,R7
   \   000000EC   0x.... 0x....      BL       __aeabi_memset
    144              SPI_Peripheral0.u32CurrentTxBytesRemaining = SPI_Peripheral0.u16RxBufferSize;
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   000000F4   0x8B80             LDRH     R0,[R0, #+28]
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   000000FA   0x6248             STR      R0,[R1, #+36]
    145              SPI_Peripheral0.pu8CurrentTxData = SPI_Peripheral0.pu8RxBuffer;
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000100   0x6940             LDR      R0,[R0, #+20]
   \   00000102   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000106   0x6288             STR      R0,[R1, #+40]
    146              SPI_Peripheral0.pBaseAddress->SPI_TDR = *SPI_Peripheral0.pu8CurrentTxData;
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000010C   0x6A80             LDR      R0,[R0, #+40]
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000114   0x6809             LDR      R1,[R1, #+0]
   \   00000116   0x60C8             STR      R0,[R1, #+12]
    147          
    148              /* Enable the transmit and receive interrupts and the SPI peripheral in case the Master starts clocking */
    149              SPI_Peripheral0.pBaseAddress->SPI_IER = (AT91C_SPI_TDRE | AT91C_SPI_RDRF);
   \   00000118   0x2003             MOVS     R0,#+3
   \   0000011A   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   0000011E   0x6809             LDR      R1,[R1, #+0]
   \   00000120   0x6148             STR      R0,[R1, #+20]
    150              SPI_Peripheral0.pBaseAddress->SPI_CR = AT91C_SPI_SPIEN;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable11_3
   \   00000128   0x6809             LDR      R1,[R1, #+0]
   \   0000012A   0x6008             STR      R0,[R1, #+0]
    151            }
    152            
    153            /* Enable SPI interrupts */
    154            NVIC_ClearPendingIRQ( (IRQn_Type)SPI_Peripheral0.u8PeripheralId );
   \                     ??SpiRequest_2: (+1)
   \   0000012C   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   00000130   0xF990 0x000E      LDRSB    R0,[R0, #+14]
   \   00000134   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000136   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    155            NVIC_EnableIRQ( (IRQn_Type)SPI_Peripheral0.u8PeripheralId );
   \   0000013A   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \   0000013E   0xF990 0x000E      LDRSB    R0,[R0, #+14]
   \   00000142   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000144   0x.... 0x....      BL       NVIC_EnableIRQ
    156            
    157            return(&SPI_Peripheral0);
   \   00000148   0x.... 0x....      LDR.W    R0,??DataTable11_3
   \                     ??SpiRequest_1: (+1)
   \   0000014C   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    158            
    159          } /* end SpiRequest() */
    160          
    161          
    162          /*!---------------------------------------------------------------------------------------------------------------------
    163          @fn void SpiRelease(SpiPeripheralType* psSpiPeripheral_)
    164          
    165          @brief Releases an SPI resource.  
    166          
    167          Requires:
    168          - Receive operation is not in progress
    169          
    170          @param psSpiPeripheral_ has the SPI peripheral number, address of the RxBuffer, 
    171          and the RxBuffer size.
    172          
    173          Promises:
    174          - Resets peripheral object's pointers and data to safe values
    175          - Peripheral is disabled
    176          - Peripheral interrupts are disabled.
    177          
    178          */

   \                                 In section .text, align 2, keep-with-next
    179          void SpiRelease(SpiPeripheralType* psSpiPeripheral_)
    180          {
   \                     SpiRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    181            /* Check to see if the peripheral is already released */
    182            if( !(psSpiPeripheral_->u32PrivateFlags) & _SPI_PERIPHERAL_ASSIGNED )
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??SpiRelease_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??SpiRelease_1
   \                     ??SpiRelease_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
    183            {
    184              return;
    185            }
    186            
    187            /* Disable interrupts */
    188            NVIC_DisableIRQ( (IRQn_Type)(psSpiPeripheral_->u8PeripheralId) );
   \                     ??SpiRelease_1: (+1)
   \   00000010   0xF994 0x000E      LDRSB    R0,[R4, #+14]
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       NVIC_DisableIRQ
    189            NVIC_ClearPendingIRQ( (IRQn_Type)(psSpiPeripheral_->u8PeripheralId) );
   \   0000001A   0xF994 0x000E      LDRSB    R0,[R4, #+14]
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    190           
    191            /* Now it's safe to release all of the resources in the target peripheral */
    192            psSpiPeripheral_->pCsGpioAddress  = NULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6060             STR      R0,[R4, #+4]
    193            psSpiPeripheral_->pu8RxBuffer     = NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x6160             STR      R0,[R4, #+20]
    194            psSpiPeripheral_->ppu8RxNextByte  = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x61A0             STR      R0,[R4, #+24]
    195            psSpiPeripheral_->u32PrivateFlags = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6120             STR      R0,[R4, #+16]
    196            
    197            /* Empty the transmit buffer if there were leftover messages */
    198            while(psSpiPeripheral_->psTransmitBuffer != NULL)
   \                     ??SpiRelease_2: (+1)
   \   00000034   0x6A20             LDR      R0,[R4, #+32]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD009             BEQ.N    ??SpiRelease_3
    199            {
    200              UpdateMessageStatus(psSpiPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   0000003A   0x2105             MOVS     R1,#+5
   \   0000003C   0x6A20             LDR      R0,[R4, #+32]
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x.... 0x....      BL       UpdateMessageStatus
    201              DeQueueMessage(&psSpiPeripheral_->psTransmitBuffer);
   \   00000044   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000048   0x.... 0x....      BL       DeQueueMessage
   \   0000004C   0xE7F2             B.N      ??SpiRelease_2
    202            }
    203            
    204          } /* end SpiRelease() */
   \                     ??SpiRelease_3: (+1)
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
    205          
    206          
    207          /*!---------------------------------------------------------------------------------------------------------------------
    208          @fn u32 SpiWriteByte(SpiPeripheralType* psSpiPeripheral_, u8 u8Byte_)
    209          
    210          @brief Queues a single byte for transfer on the target SPI peripheral.  
    211          
    212          Requires:
    213          @param psSpiPeripheral_ is the SPI peripheral to use and it has already been requested.
    214          @param u8Byte_ is the byte to send
    215          
    216          Promises:
    217          - Creates a 1-byte message at psSpiPeripheral_->psTransmitBuffer that will be sent 
    218            by the SPI application when it is available.
    219          - Returns the message token assigned to the message; 0 is returned if the message 
    220            cannot be queued in which case G_u32MessagingFlags can be checked for the reason
    221          
    222          */

   \                                 In section .text, align 2, keep-with-next
    223          u32 SpiWriteByte(SpiPeripheralType* psSpiPeripheral_, u8 u8Byte_)
    224          {
   \                     SpiWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    225            u32 u32Token;
    226            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    227            
    228            /* Attempt to queue message and get a response token */
    229            u32Token = QueueMessage(&psSpiPeripheral_->psTransmitBuffer, 1, &u8Data);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000014   0x.... 0x....      BL       QueueMessage
   \   00000018   0x0006             MOVS     R6,R0
    230            if( u32Token != 0 )
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD006             BEQ.N    ??SpiWriteByte_0
    231            {
    232              /* If the system is initializing, we want to manually cycle the SPI task through one iteration
    233              to send the message */
    234              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??SpiWriteByte_0
    235              {
    236                SpiManualMode();
   \   00000028   0x.... 0x....      BL       SpiManualMode
    237              }
    238            }
    239            
    240            return(u32Token);
   \                     ??SpiWriteByte_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    241            
    242          } /* end SpiWriteByte() */
    243          
    244          
    245          /*!--------------------------------------------------------------------------------------------------------------------
    246          @fn u32 SpiWriteData(SpiPeripheralType* psSpiPeripheral_, u32 u32Size_, u8* pu8Data_)
    247          
    248          @brief Queues a data array for transfer on the target SPI peripheral.  
    249          
    250          Requires:
    251          @param psSpiPeripheral_ is the SPI peripheral to use and it has already been requested.
    252          @param u32Size_ is the number of bytes in the data array
    253          @param pu8Data_ points to the first byte of the data array
    254          
    255          Promises:
    256          - adds the data message at psSpiPeripheral_->psTransmitBuffer that will be sent by the SPI application
    257            when it is available.
    258          - Returns the message token assigned to the message; 0 is returned if the message 
    259            cannot be queued in which case G_u32MessagingFlags can be checked for the reason
    260          
    261          */

   \                                 In section .text, align 2, keep-with-next
    262          u32 SpiWriteData(SpiPeripheralType* psSpiPeripheral_, u32 u32Size_, u8* pu8Data_)
    263          {
   \                     SpiWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    264            u32 u32Token;
    265          
    266            /* Check for a valid size */
    267            if(u32Size_ == 0)
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE.N    ??SpiWriteData_0
    268            {
    269              return NULL;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE012             B.N      ??SpiWriteData_1
    270            }
    271          
    272            /* Attempt to queue message and get a response token */
    273            u32Token = QueueMessage(&psSpiPeripheral_->psTransmitBuffer, u32Size_, pu8Data_);
   \                     ??SpiWriteData_0: (+1)
   \   00000010   0x0032             MOVS     R2,R6
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0xF114 0x0020      ADDS     R0,R4,#+32
   \   00000018   0x.... 0x....      BL       QueueMessage
   \   0000001C   0x0007             MOVS     R7,R0
    274            if( u32Token == 0 )
   \   0000001E   0x2F00             CMP      R7,#+0
   \   00000020   0xD101             BNE.N    ??SpiWriteData_2
    275            {
    276              return(0);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE007             B.N      ??SpiWriteData_1
    277            }
    278            
    279            /* If the system is initializing, manually cycle the SPI task through one iteration to send the message */
    280            if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??SpiWriteData_2: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_6
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD501             BPL.N    ??SpiWriteData_3
    281            {
    282              SpiManualMode();
   \   00000030   0x.... 0x....      BL       SpiManualMode
    283            }
    284          
    285            return(u32Token);
   \                     ??SpiWriteData_3: (+1)
   \   00000034   0x0038             MOVS     R0,R7
   \                     ??SpiWriteData_1: (+1)
   \   00000036   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    286          
    287          } /* end SpiWriteData() */
    288          
    289          
    290          /*!--------------------------------------------------------------------------------------------------------------------
    291          @fn bool SpiReadByte(SpiPeripheralType* psSpiPeripheral_)
    292          
    293          @brief Master mode only.  Queues a request for a single byte from the Slave on 
    294          the target SPI peripheral.  There cannot be pending writes.
    295          
    296          Requires:
    297          - Master mode 
    298          
    299          @param psSpiPeripheral_ is the SPI peripheral to use and it has already been requested.
    300          
    301          Promises:
    302          - Creates a message with one SPI_DUMMY_BYTE at psSpiPeripheral_->psTransmitBuffer that will be sent by the SPI application
    303            when it is available and thus clock in a received byte to the target receive buffer.
    304          - Returns TRUE and loads the target SPI u16RxBytes
    305          
    306          */

   \                                 In section .text, align 2, keep-with-next
    307          bool SpiReadByte(SpiPeripheralType* psSpiPeripheral_)
    308          {
   \                     SpiReadByte: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    309            /* Confirm Master Mode */
    310            if( (psSpiPeripheral_->eSpiMode) == SPI_SLAVE )
   \   00000002   0x7B48             LDRB     R0,[R1, #+13]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??SpiReadByte_0
    311            {
    312              return FALSE;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xE00A             B.N      ??SpiReadByte_1
    313            }
    314          
    315            /* Make sure no Tx or Rx function is already in progress */
    316            if( (psSpiPeripheral_->u16RxBytes != 0) || (psSpiPeripheral_->psTransmitBuffer != NULL) )
   \                     ??SpiReadByte_0: (+1)
   \   0000000C   0x8BC8             LDRH     R0,[R1, #+30]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD102             BNE.N    ??SpiReadByte_2
   \   00000012   0x6A08             LDR      R0,[R1, #+32]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD001             BEQ.N    ??SpiReadByte_3
    317            {
    318              return FALSE;
   \                     ??SpiReadByte_2: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xE002             B.N      ??SpiReadByte_1
    319            }
    320            
    321            /* Load the counter and return success */
    322            psSpiPeripheral_->u16RxBytes = 1;
   \                     ??SpiReadByte_3: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x83C8             STRH     R0,[R1, #+30]
    323            return TRUE;
   \   00000020   0x2001             MOVS     R0,#+1
   \                     ??SpiReadByte_1: (+1)
   \   00000022   0x4770             BX       LR               ;; return
    324            
    325          } /* end SpiReadByte() */
    326          
    327          
    328          /*!--------------------------------------------------------------------------------------------------------------------
    329          @fn bool SpiReadData(SpiPeripheralType* psSpiPeripheral_, u16 u16Size_)
    330          
    331          @brief Master mode only. Prepares to get multiple bytes from the Slave on the target SPI peripheral.  
    332          
    333          Requires:
    334          - Master mode 
    335          
    336          @param psSpiPeripheral_ is the SPI peripheral to use and it has already been requested.
    337          @param u16Size_ is the number of bytes to receive
    338          
    339          Promises:
    340          - Returns FALSE if the message is too big, or the peripheral already has a read request
    341          - Returns TRUE and loads the target SPI u16RxBytes
    342          
    343          */

   \                                 In section .text, align 2, keep-with-next
    344          bool SpiReadData(SpiPeripheralType* psSpiPeripheral_, u16 u16Size_)
    345          {
   \                     SpiReadData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    346            /* Confirm Master Mode */
    347            if( (psSpiPeripheral_->eSpiMode) == SPI_SLAVE)
   \   00000006   0x7B60             LDRB     R0,[R4, #+13]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD101             BNE.N    ??SpiReadData_0
    348            {
    349              return FALSE;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE012             B.N      ??SpiReadData_1
    350            }
    351          
    352            /* Make sure no Tx or Rx function is already in progress */
    353            if( (psSpiPeripheral_->u16RxBytes != 0) || (psSpiPeripheral_->psTransmitBuffer != NULL) )
   \                     ??SpiReadData_0: (+1)
   \   00000010   0x8BE0             LDRH     R0,[R4, #+30]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD102             BNE.N    ??SpiReadData_2
   \   00000016   0x6A20             LDR      R0,[R4, #+32]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD001             BEQ.N    ??SpiReadData_3
    354            {
    355              return FALSE;
   \                     ??SpiReadData_2: (+1)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE00A             B.N      ??SpiReadData_1
    356            }
    357          
    358            /* Do not allow if requested size is too large */
    359            if(u16Size_ > U16_MAX_TX_MESSAGE_LENGTH)
   \                     ??SpiReadData_3: (+1)
   \   00000020   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000022   0x2D81             CMP      R5,#+129
   \   00000024   0xDB05             BLT.N    ??SpiReadData_4
    360            {
    361              DebugPrintf("\r\nSPI message too large\n\r");
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable11_7
   \   0000002A   0x.... 0x....      BL       DebugPrintf
    362              return FALSE;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xE001             B.N      ??SpiReadData_1
    363            }
    364            
    365            /* Load the counter and return success */
    366            psSpiPeripheral_->u16RxBytes = u16Size_;
   \                     ??SpiReadData_4: (+1)
   \   00000032   0x83E5             STRH     R5,[R4, #+30]
    367            return TRUE;
   \   00000034   0x2001             MOVS     R0,#+1
   \                     ??SpiReadData_1: (+1)
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    368              
    369          } /* end SpiReadData() */
    370          
    371          
    372          /*!--------------------------------------------------------------------------------------------------------------------
    373          @fn SpiRxStatusType SpiQueryReceiveStatus(SpiPeripheralType* psSpiPeripheral_)
    374          
    375          @brief Master mode only.  Returns status of currently requested receive data.
    376          
    377          Requires:
    378          @param psSpiPeripheral_ is the SPI peripheral to use and it has already been requested.
    379          
    380          Promises:
    381          - Returns the SpiRxStatusType status of the currently receiving message.
    382          
    383          */

   \                                 In section .text, align 2, keep-with-next
    384          SpiRxStatusType SpiQueryReceiveStatus(SpiPeripheralType* psSpiPeripheral_)
    385          {
   \                     SpiQueryReceiveStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    386            /* Confirm Master Mode */
    387            if( (psSpiPeripheral_->eSpiMode) == SPI_SLAVE)
   \   00000002   0x7B48             LDRB     R0,[R1, #+13]
   \   00000004   0x2801             CMP      R0,#+1
   \   00000006   0xD101             BNE.N    ??SpiQueryReceiveStatus_0
    388            {
    389              return SPI_RX_INVALID;
   \   00000008   0x2005             MOVS     R0,#+5
   \   0000000A   0xE013             B.N      ??SpiQueryReceiveStatus_1
    390            }
    391          
    392            /* Check for no current bytes queued */
    393            if(psSpiPeripheral_->u16RxBytes == 0)
   \                     ??SpiQueryReceiveStatus_0: (+1)
   \   0000000C   0x8BC8             LDRH     R0,[R1, #+30]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD10A             BNE.N    ??SpiQueryReceiveStatus_2
    394            {
    395              /* If a transfer is finished and has not be queried... */
    396              if( psSpiPeripheral_->u32PrivateFlags & _SPI_PERIPHERAL_RX_COMPLETE)
   \   00000012   0x6908             LDR      R0,[R1, #+16]
   \   00000014   0x0200             LSLS     R0,R0,#+8
   \   00000016   0xD505             BPL.N    ??SpiQueryReceiveStatus_3
    397              {
    398                psSpiPeripheral_->u32PrivateFlags &= ~_SPI_PERIPHERAL_RX_COMPLETE;
   \   00000018   0x6908             LDR      R0,[R1, #+16]
   \   0000001A   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   0000001E   0x6108             STR      R0,[R1, #+16]
    399                return SPI_RX_COMPLETE;
   \   00000020   0x2003             MOVS     R0,#+3
   \   00000022   0xE007             B.N      ??SpiQueryReceiveStatus_1
    400              }
    401              /* Otherwise it's just empty */
    402              else
    403              {
    404                return SPI_RX_EMPTY;
   \                     ??SpiQueryReceiveStatus_3: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE005             B.N      ??SpiQueryReceiveStatus_1
    405              }
    406            }
    407            /* If there are bytes waiting, check if waiting or in progress */
    408            else
    409            {
    410              if(psSpiPeripheral_->u32PrivateFlags & _SPI_PERIPHERAL_RX)
   \                     ??SpiQueryReceiveStatus_2: (+1)
   \   00000028   0x6908             LDR      R0,[R1, #+16]
   \   0000002A   0x0240             LSLS     R0,R0,#+9
   \   0000002C   0xD501             BPL.N    ??SpiQueryReceiveStatus_4
    411              {
    412                return SPI_RX_RECEIVING;
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0xE000             B.N      ??SpiQueryReceiveStatus_1
    413              }
    414              else
    415              {
    416                return SPI_RX_WAITING;
   \                     ??SpiQueryReceiveStatus_4: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \                     ??SpiQueryReceiveStatus_1: (+1)
   \   00000034   0x4770             BX       LR               ;; return
    417              }
    418            }
    419            
    420          } /* end SpiQueryReceiveStatus() */
    421          
    422          
    423          /*--------------------------------------------------------------------------------------------------------------------*/
    424          /*! @protectedsection */                                                                                            
    425          /*--------------------------------------------------------------------------------------------------------------------*/
    426          
    427          /*!--------------------------------------------------------------------------------------------------------------------
    428          @fn void SpiInitialize(void)
    429          
    430          @brief Initializes the SPI application and its variables.  
    431          
    432          The peripheral is not configured until requested by a calling application.
    433          
    434          Requires:
    435          - NONE
    436          
    437          Promises:
    438          - SPI peripheral object is ready 
    439          - SPI application set to Idle
    440          
    441          */

   \                                 In section .text, align 2, keep-with-next
    442          void SpiInitialize(void)
    443          {
   \                     SpiInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    444            /* Initialize the SPI peripheral structures */
    445            SPI_Peripheral0.pBaseAddress     = AT91C_BASE_SPI0;
   \   00000002   0x....             LDR.N    R0,??DataTable11_8  ;; 0x40008000
   \   00000004   0x....             LDR.N    R1,??DataTable11_3
   \   00000006   0x6008             STR      R0,[R1, #+0]
    446            SPI_Peripheral0.u8PeripheralId   = AT91C_ID_SPI0;
   \   00000008   0x2014             MOVS     R0,#+20
   \   0000000A   0x....             LDR.N    R1,??DataTable11_3
   \   0000000C   0x7388             STRB     R0,[R1, #+14]
    447            SPI_Peripheral0.pCsGpioAddress   = NULL;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x....             LDR.N    R1,??DataTable11_3
   \   00000012   0x6048             STR      R0,[R1, #+4]
    448            SPI_Peripheral0.psTransmitBuffer = NULL;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable11_3
   \   00000018   0x6208             STR      R0,[R1, #+32]
    449            SPI_Peripheral0.pu8RxBuffer      = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             LDR.N    R1,??DataTable11_3
   \   0000001E   0x6148             STR      R0,[R1, #+20]
    450            SPI_Peripheral0.u16RxBufferSize  = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable11_3
   \   00000024   0x8388             STRH     R0,[R1, #+28]
    451            SPI_Peripheral0.ppu8RxNextByte   = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R1,??DataTable11_3
   \   0000002A   0x6188             STR      R0,[R1, #+24]
    452            SPI_Peripheral0.u32PrivateFlags  = 0;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x....             LDR.N    R1,??DataTable11_3
   \   00000030   0x6108             STR      R0,[R1, #+16]
    453          
    454            /* Clear all flags */
    455            SPI_u32Flags = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x....             LDR.N    R1,??DataTable11_9
   \   00000036   0x6008             STR      R0,[R1, #+0]
    456            G_u32Spi0ApplicationFlags = 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x....             LDR.N    R1,??DataTable11_10
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    457            
    458            /* Set application pointer */
    459            Spi_pfnStateMachine = SpiSM_Idle;
   \   0000003E   0x.... 0x....      ADR.W    R0,SpiSM_Idle
   \   00000042   0x....             LDR.N    R1,??DataTable11_11
   \   00000044   0x6008             STR      R0,[R1, #+0]
    460            DebugPrintf("SPI Peripheral Ready\n\r");
   \   00000046   0x....             LDR.N    R0,??DataTable11_12
   \   00000048   0x.... 0x....      BL       DebugPrintf
    461          
    462          } /* end SpiInitialize() */
   \   0000004C   0xBD01             POP      {R0,PC}          ;; return
    463          
    464          
    465          /*!----------------------------------------------------------------------------------------------------------------------
    466          @fn void SpiRunActiveState(void)
    467          
    468          @brief Selects and runs one iteration of the current state in the state machine.
    469          
    470          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    471          may take 1ms / n to execute.
    472          
    473          Requires:
    474          - State machine function pointer points at current state
    475          
    476          Promises:
    477          - Calls the function to pointed by the state machine function pointer
    478          
    479          */

   \                                 In section .text, align 2, keep-with-next
    480          void SpiRunActiveState(void)
    481          {
   \                     SpiRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    482            Spi_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable11_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    483          
    484          } /* end SpiRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    485          
    486          
    487          /*!----------------------------------------------------------------------------------------------------------------------
    488          @fn void SpiManualMode(void)
    489          
    490          @brief Runs a transmit cycle of the SPI application to clock out a message.  This function is used only during
    491          initialization.
    492          
    493          Requires:
    494          - G_u32SystemFlags _SYSTEM_INITIALIZING is set
    495          - SPI application has been initialized.
    496          
    497          Promises:
    498          - All currently queued SPI Master transmit and receive operations are completed.
    499          
    500          */

   \                                 In section .text, align 2, keep-with-next
    501          void SpiManualMode(void)
    502          {
   \                     SpiManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    503            u32 u32Timer;
    504            
    505            /* Set up for manual mode */
    506            SPI_u32Flags |= _SPI_MANUAL_MODE;
   \   00000002   0x....             LDR.N    R0,??DataTable11_9
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x....             LDR.N    R1,??DataTable11_9
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    507          
    508            /* Run the SPI state machine so all SPI peripherals send their current message */  
    509            while(SPI_u32Flags & _SPI_MANUAL_MODE)
   \                     ??SpiManualMode_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable11_9
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD511             BPL.N    ??SpiManualMode_1
    510            {
    511              WATCHDOG_BONE();
   \   00000016   0x....             LDR.N    R0,??DataTable11_13  ;; 0xa5000001
   \   00000018   0x....             LDR.N    R1,??DataTable11_14  ;; 0x400e1250
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    512              Spi_pfnStateMachine();
   \   0000001C   0x....             LDR.N    R0,??DataTable11_11
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4780             BLX      R0
    513              MessagingRunActiveState();
   \   00000022   0x.... 0x....      BL       MessagingRunActiveState
    514              
    515              u32Timer = G_u32SystemTime1ms;
   \   00000026   0x....             LDR.N    R0,??DataTable11_15
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    516              while( !IsTimeUp(&u32Timer, 1) );
   \                     ??SpiManualMode_2: (+1)
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       IsTimeUp
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD1EA             BNE.N    ??SpiManualMode_0
   \   00000038   0xE7F8             B.N      ??SpiManualMode_2
    517            }
    518                
    519          } /* end SpiManualMode() */
   \                     ??SpiManualMode_1: (+1)
   \   0000003A   0xBD01             POP      {R0,PC}          ;; return
    520          
    521          
    522          /*!----------------------------------------------------------------------------------------------------------------------
    523          @fn ISR void SPI0_IrqHandler(void)
    524          
    525          @brief Handler for expected SPI interrupts
    526          
    527          Requires:
    528          - None
    529          
    530          Promises:
    531          - Each interrupt has different outcomes for the system depending on the SPI mode.  
    532            See each section for more details.
    533          
    534          */

   \                                 In section .text, align 2, keep-with-next
    535          void SPI0_IrqHandler(void)
    536          {
   \                     SPI0_IrqHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    537            u32 u32Byte;
    538            u32 u32Current_SR;
    539          
    540            /* Get a copy of SR */
    541            u32Current_SR = SPI_Peripheral0.pBaseAddress->SPI_SR;
   \   00000002   0x....             LDR.N    R0,??DataTable11_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x0005             MOVS     R5,R0
    542          
    543            /*** SPI ISR receive handling (RDRF) for Master and Slave ***/
    544            if( (SPI_Peripheral0.pBaseAddress->SPI_IMR & AT91C_SPI_RDRF) && 
    545                (u32Current_SR & AT91C_SPI_RDRF) )
   \   0000000A   0x....             LDR.N    R0,??DataTable11_3
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x69C0             LDR      R0,[R0, #+28]
   \   00000010   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000014   0xF015 0x0101      ANDS     R1,R5,#0x1
   \   00000018   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xD04B             BEQ.N    ??SPI0_IrqHandler_0
    546            {
    547              /* Master mode has special conditions if receiving a known number of bytes */
    548              if( (SPI_Peripheral0.eSpiMode == SPI_MASTER) &&
    549                  (SPI_Peripheral0.u32PrivateFlags & _SPI_PERIPHERAL_RX) )
   \   0000001E   0x....             LDR.N    R0,??DataTable11_3
   \   00000020   0x7B40             LDRB     R0,[R0, #+13]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD120             BNE.N    ??SPI0_IrqHandler_1
   \   00000026   0x....             LDR.N    R0,??DataTable11_3
   \   00000028   0x6900             LDR      R0,[R0, #+16]
   \   0000002A   0x0240             LSLS     R0,R0,#+9
   \   0000002C   0xD51C             BPL.N    ??SPI0_IrqHandler_1
    550              {
    551                /* Decrement counter and read the byte */
    552                SPI_Peripheral0.u16RxBytes--;
   \   0000002E   0x....             LDR.N    R0,??DataTable11_3
   \   00000030   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable11_3
   \   00000036   0x83C8             STRH     R0,[R1, #+30]
    553                
    554                /* Check if reception is complete */
    555                if(SPI_Peripheral0.u16RxBytes == 0)
   \   00000038   0x....             LDR.N    R0,??DataTable11_3
   \   0000003A   0x8BC0             LDRH     R0,[R0, #+30]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD113             BNE.N    ??SPI0_IrqHandler_1
    556                {
    557                  /* Reset the byte counter and clear the RX flag */
    558                  SPI_Peripheral0.u32PrivateFlags &= ~_SSP_PERIPHERAL_RX;
   \   00000040   0x....             LDR.N    R0,??DataTable11_3
   \   00000042   0x6900             LDR      R0,[R0, #+16]
   \   00000044   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000048   0x....             LDR.N    R1,??DataTable11_3
   \   0000004A   0x6108             STR      R0,[R1, #+16]
    559                  SPI_Peripheral0.u32PrivateFlags |=  _SSP_PERIPHERAL_RX_COMPLETE;
   \   0000004C   0x....             LDR.N    R0,??DataTable11_3
   \   0000004E   0x6900             LDR      R0,[R0, #+16]
   \   00000050   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000054   0x....             LDR.N    R1,??DataTable11_3
   \   00000056   0x6108             STR      R0,[R1, #+16]
    560                       
    561                  /* Disable the receive interrupt */
    562                  SPI_Peripheral0.pBaseAddress->SPI_IDR = AT91C_SPI_RDRF;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x....             LDR.N    R1,??DataTable11_3
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6188             STR      R0,[R1, #+24]
    563          
    564                  /* Disable the SPI peripheral since the transfer must now be complete */
    565                  SPI_Peripheral0.pBaseAddress->SPI_CR = AT91C_SPI_SPIDIS;
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x....             LDR.N    R1,??DataTable11_3
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
    566                }
    567              }
    568                  
    569              /* Common receive functionality */
    570                
    571              /* Read the received byte */
    572              u32Byte = 0x000000FF & SPI_Peripheral0.pBaseAddress->SPI_RDR;
   \                     ??SPI0_IrqHandler_1: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable11_3
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000070   0x0004             MOVS     R4,R0
    573          
    574              /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    575              if(SPI_Peripheral0.eBitOrder == SPI_LSB_FIRST)
   \   00000072   0x....             LDR.N    R0,??DataTable11_3
   \   00000074   0x7B00             LDRB     R0,[R0, #+12]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD103             BNE.N    ??SPI0_IrqHandler_2
    576              {
    577                u32Byte = __RBIT(u32Byte) >> 24;
   \   0000007A   0xFA94 0xF0A4      RBIT     R0,R4
   \   0000007E   0x0E00             LSRS     R0,R0,#+24
   \   00000080   0x0004             MOVS     R4,R0
    578              }
    579          
    580              /* Put the byte in the client's Rx buffer */
    581              **(SPI_Peripheral0.ppu8RxNextByte) = (u8)u32Byte; 
   \                     ??SPI0_IrqHandler_2: (+1)
   \   00000082   0x....             LDR.N    R0,??DataTable11_3
   \   00000084   0x6980             LDR      R0,[R0, #+24]
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x7004             STRB     R4,[R0, #+0]
    582          
    583              /* Update the pointer to the next valid Rx location (account for Slave's circular buffer) */
    584              (*SPI_Peripheral0.ppu8RxNextByte)++;
   \   0000008A   0x....             LDR.N    R0,??DataTable11_3
   \   0000008C   0x6980             LDR      R0,[R0, #+24]
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x1C40             ADDS     R0,R0,#+1
   \   00000092   0x....             LDR.N    R1,??DataTable11_3
   \   00000094   0x6989             LDR      R1,[R1, #+24]
   \   00000096   0x6008             STR      R0,[R1, #+0]
    585              if( *SPI_Peripheral0.ppu8RxNextByte == (SPI_Peripheral0.pu8RxBuffer + (u32)SPI_Peripheral0.u16RxBufferSize) )
   \   00000098   0x....             LDR.N    R0,??DataTable11_3
   \   0000009A   0x6980             LDR      R0,[R0, #+24]
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x....             LDR.N    R1,??DataTable11_3
   \   000000A0   0x6949             LDR      R1,[R1, #+20]
   \   000000A2   0x....             LDR.N    R2,??DataTable11_3
   \   000000A4   0x8B92             LDRH     R2,[R2, #+28]
   \   000000A6   0x1851             ADDS     R1,R2,R1
   \   000000A8   0x4288             CMP      R0,R1
   \   000000AA   0xD104             BNE.N    ??SPI0_IrqHandler_0
    586              {
    587                *SPI_Peripheral0.ppu8RxNextByte = SPI_Peripheral0.pu8RxBuffer;  
   \   000000AC   0x....             LDR.N    R0,??DataTable11_3
   \   000000AE   0x6940             LDR      R0,[R0, #+20]
   \   000000B0   0x....             LDR.N    R1,??DataTable11_3
   \   000000B2   0x6989             LDR      R1,[R1, #+24]
   \   000000B4   0x6008             STR      R0,[R1, #+0]
    588              }
    589            } /* end AT91C_SPI_RDRF handling */
    590          
    591          
    592            /*** SPI ISR transmit handling (TDRE) for Master and Slave ***/
    593            if( (SPI_Peripheral0.pBaseAddress->SPI_IMR & AT91C_SPI_TDRE) && 
    594                (u32Current_SR & AT91C_SPI_TDRE) )
   \                     ??SPI0_IrqHandler_0: (+1)
   \   000000B6   0x....             LDR.N    R0,??DataTable11_3
   \   000000B8   0x6800             LDR      R0,[R0, #+0]
   \   000000BA   0x69C0             LDR      R0,[R0, #+28]
   \   000000BC   0x0780             LSLS     R0,R0,#+30
   \   000000BE   0xD53E             BPL.N    ??SPI0_IrqHandler_3
   \   000000C0   0x07A8             LSLS     R0,R5,#+30
   \   000000C2   0xD53C             BPL.N    ??SPI0_IrqHandler_3
    595            {
    596              /* Decrement counter and check if Tx is complete */
    597              SPI_Peripheral0.u32CurrentTxBytesRemaining--;
   \   000000C4   0x....             LDR.N    R0,??DataTable11_3
   \   000000C6   0x6A40             LDR      R0,[R0, #+36]
   \   000000C8   0x1E40             SUBS     R0,R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable11_3
   \   000000CC   0x6248             STR      R0,[R1, #+36]
    598              if(SPI_Peripheral0.u32CurrentTxBytesRemaining != 0)
   \   000000CE   0x....             LDR.N    R0,??DataTable11_3
   \   000000D0   0x6A40             LDR      R0,[R0, #+36]
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD016             BEQ.N    ??SPI0_IrqHandler_4
    599              {
    600                /* Advance the pointer (non-circular buffer)and load the next byte */
    601                SPI_Peripheral0.pu8CurrentTxData++;
   \   000000D6   0x....             LDR.N    R0,??DataTable11_3
   \   000000D8   0x6A80             LDR      R0,[R0, #+40]
   \   000000DA   0x1C40             ADDS     R0,R0,#+1
   \   000000DC   0x....             LDR.N    R1,??DataTable11_3
   \   000000DE   0x6288             STR      R0,[R1, #+40]
    602                u32Byte = 0x000000FF & *SPI_Peripheral0.pu8CurrentTxData;
   \   000000E0   0x....             LDR.N    R0,??DataTable11_3
   \   000000E2   0x6A80             LDR      R0,[R0, #+40]
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x0004             MOVS     R4,R0
    603          
    604                /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    605                if(SPI_Peripheral0.eBitOrder == SPI_LSB_FIRST)
   \   000000E8   0x....             LDR.N    R0,??DataTable11_3
   \   000000EA   0x7B00             LDRB     R0,[R0, #+12]
   \   000000EC   0x2801             CMP      R0,#+1
   \   000000EE   0xD103             BNE.N    ??SPI0_IrqHandler_5
    606                {
    607                  u32Byte = __RBIT(u32Byte) >> 24;
   \   000000F0   0xFA94 0xF0A4      RBIT     R0,R4
   \   000000F4   0x0E00             LSRS     R0,R0,#+24
   \   000000F6   0x0004             MOVS     R4,R0
    608                }
    609              
    610                /* Load register (clears interrupt flag) */
    611                SPI_Peripheral0.pBaseAddress->SPI_TDR = (u8)u32Byte; 
   \                     ??SPI0_IrqHandler_5: (+1)
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000FC   0x....             LDR.N    R1,??DataTable11_3
   \   000000FE   0x6809             LDR      R1,[R1, #+0]
   \   00000100   0x60C8             STR      R0,[R1, #+12]
   \   00000102   0xE01C             B.N      ??SPI0_IrqHandler_3
    612              }
    613              else
    614              {
    615                /* Done! Disable TX interrupt */
    616                SPI_Peripheral0.pBaseAddress->SPI_IDR = AT91C_SPI_TDRE;
   \                     ??SPI0_IrqHandler_4: (+1)
   \   00000104   0x2002             MOVS     R0,#+2
   \   00000106   0x....             LDR.N    R1,??DataTable11_3
   \   00000108   0x6809             LDR      R1,[R1, #+0]
   \   0000010A   0x6188             STR      R0,[R1, #+24]
    617                
    618                /* If this was a transmit operation, clean up the message status and flags */
    619                if(SPI_Peripheral0.u32PrivateFlags & _SPI_PERIPHERAL_TX)
   \   0000010C   0x....             LDR.N    R0,??DataTable11_3
   \   0000010E   0x6900             LDR      R0,[R0, #+16]
   \   00000110   0x0280             LSLS     R0,R0,#+10
   \   00000112   0xD514             BPL.N    ??SPI0_IrqHandler_3
    620                {
    621                  SPI_Peripheral0.u32PrivateFlags &= ~_SPI_PERIPHERAL_TX;  
   \   00000114   0x....             LDR.N    R0,??DataTable11_3
   \   00000116   0x6900             LDR      R0,[R0, #+16]
   \   00000118   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   0000011C   0x....             LDR.N    R1,??DataTable11_3
   \   0000011E   0x6108             STR      R0,[R1, #+16]
    622                  G_u32Spi0ApplicationFlags |= _SPI_TX_COMPLETE; 
   \   00000120   0x....             LDR.N    R0,??DataTable11_10
   \   00000122   0x6800             LDR      R0,[R0, #+0]
   \   00000124   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000128   0x....             LDR.N    R1,??DataTable11_10
   \   0000012A   0x6008             STR      R0,[R1, #+0]
    623                  UpdateMessageStatus(SPI_Peripheral0.psTransmitBuffer->u32Token, COMPLETE);
   \   0000012C   0x2103             MOVS     R1,#+3
   \   0000012E   0x....             LDR.N    R0,??DataTable11_3
   \   00000130   0x6A00             LDR      R0,[R0, #+32]
   \   00000132   0x6800             LDR      R0,[R0, #+0]
   \   00000134   0x.... 0x....      BL       UpdateMessageStatus
    624                  DeQueueMessage(&SPI_Peripheral0.psTransmitBuffer);
   \   00000138   0x....             LDR.N    R0,??DataTable11_16
   \   0000013A   0x.... 0x....      BL       DeQueueMessage
    625                }
    626              }
    627            } /* end AT91C_SPI_TDRE */
    628            
    629          } /* end SPI0_IrqHandler() */
   \                     ??SPI0_IrqHandler_3: (+1)
   \   0000013E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    630          
    631          
    632          
    633          /*----------------------------------------------------------------------------------------------------------------------*/
    634          /*! @privatesection */                                                                                            
    635          /*----------------------------------------------------------------------------------------------------------------------*/
    636          
    637          
    638          /***********************************************************************************************************************
    639          State Machine Function Definitions
    640          
    641          The SPI state machine monitors messaging activity on the SPI Master peripheral.  
    642          It manages all SPI outgoing messages and will transmit any message that has been queued.  
    643          ***********************************************************************************************************************/
    644          
    645          /*!-------------------------------------------------------------------------------------------------------------------
    646          @fn static void SpiSM_Idle(void)
    647          
    648          @brief Wait for a transmit message to be queued -- this can include a dummy transmission 
    649          to receive bytes.
    650          Half duplex transmissions are always assumed. Check one peripheral per iteration. 
    651          
    652          */

   \                                 In section .text, align 4, keep-with-next
    653          static void SpiSM_Idle(void)
    654          {
   \                     SpiSM_Idle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    655            u32 u32Byte;
    656          
    657            if( ( (SPI_Peripheral0.psTransmitBuffer != NULL) || (SPI_Peripheral0.u16RxBytes !=0) ) && 
    658               !(SPI_Peripheral0.u32PrivateFlags & (_SPI_PERIPHERAL_TX | _SPI_PERIPHERAL_RX) ) 
    659              )
   \   00000002   0x....             LDR.N    R0,??DataTable11_3
   \   00000004   0x6A00             LDR      R0,[R0, #+32]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD103             BNE.N    ??SpiSM_Idle_0
   \   0000000A   0x....             LDR.N    R0,??DataTable11_3
   \   0000000C   0x8BC0             LDRH     R0,[R0, #+30]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD062             BEQ.N    ??SpiSM_Idle_1
   \                     ??SpiSM_Idle_0: (+1)
   \   00000012   0x....             LDR.N    R0,??DataTable11_3
   \   00000014   0x6900             LDR      R0,[R0, #+16]
   \   00000016   0xF410 0x0FC0      TST      R0,#0x600000
   \   0000001A   0xD15D             BNE.N    ??SpiSM_Idle_1
    660            {
    661              /* Receiving (Master only): Check if the message is receiving based on expected byte count.
    662              Do not need to check for Master because a Slave is not allowed to change u16RxBytes. */
    663              if(SPI_Peripheral0.u16RxBytes !=0)
   \   0000001C   0x....             LDR.N    R0,??DataTable11_3
   \   0000001E   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD02A             BEQ.N    ??SpiSM_Idle_2
    664              {
    665                /* Receiving: flag that the peripheral is now busy */
    666                SPI_Peripheral0.u32PrivateFlags |= _SPI_PERIPHERAL_RX;    
   \   00000024   0x....             LDR.N    R0,??DataTable11_3
   \   00000026   0x6900             LDR      R0,[R0, #+16]
   \   00000028   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   0000002C   0x....             LDR.N    R1,??DataTable11_3
   \   0000002E   0x6108             STR      R0,[R1, #+16]
    667                
    668                /* Initialize the receive buffer so we can see data changes but also so we send
    669                predictable dummy bytes since we'll point to this buffer to source the transmit dummies */
    670                memset(SPI_Peripheral0.pu8RxBuffer, SPI_DUMMY, SPI_Peripheral0.u16RxBufferSize);
   \   00000030   0x....             LDR.N    R0,??DataTable11_3
   \   00000032   0x8B85             LDRH     R5,[R0, #+28]
   \   00000034   0x26AA             MOVS     R6,#+170
   \   00000036   0x....             LDR.N    R0,??DataTable11_3
   \   00000038   0x6947             LDR      R7,[R0, #+20]
   \   0000003A   0x0032             MOVS     R2,R6
   \   0000003C   0x0029             MOVS     R1,R5
   \   0000003E   0x0038             MOVS     R0,R7
   \   00000040   0x.... 0x....      BL       __aeabi_memset
    671                
    672                /* Transmit drives the receive operation, so set it up */
    673                SPI_Peripheral0.u32CurrentTxBytesRemaining = SPI_Peripheral0.u16RxBytes;
   \   00000044   0x....             LDR.N    R0,??DataTable11_3
   \   00000046   0x8BC0             LDRH     R0,[R0, #+30]
   \   00000048   0x....             LDR.N    R1,??DataTable11_3
   \   0000004A   0x6248             STR      R0,[R1, #+36]
    674                SPI_Peripheral0.pu8CurrentTxData = SPI_Peripheral0.pu8RxBuffer;
   \   0000004C   0x....             LDR.N    R0,??DataTable11_3
   \   0000004E   0x6940             LDR      R0,[R0, #+20]
   \   00000050   0x....             LDR.N    R1,??DataTable11_3
   \   00000052   0x6288             STR      R0,[R1, #+40]
    675                SPI_Peripheral0.pBaseAddress->SPI_TDR = *SPI_Peripheral0.pu8CurrentTxData;
   \   00000054   0x....             LDR.N    R0,??DataTable11_3
   \   00000056   0x6A80             LDR      R0,[R0, #+40]
   \   00000058   0x7800             LDRB     R0,[R0, #+0]
   \   0000005A   0x....             LDR.N    R1,??DataTable11_3
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x60C8             STR      R0,[R1, #+12]
    676                
    677                /* Enable the SPI peripheral */
    678                SPI_Peripheral0.pBaseAddress->SPI_CR = AT91C_SPI_SPIEN;
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable11_3
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6008             STR      R0,[R1, #+0]
    679          
    680                /* Make sure RDR is clear then enable the transmit and receive interrupts */
    681                u32Byte = SPI_Peripheral0.pBaseAddress->SPI_RDR;
   \   00000068   0x....             LDR.N    R0,??DataTable11_3
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x6880             LDR      R0,[R0, #+8]
   \   0000006E   0x0004             MOVS     R4,R0
    682                SPI_Peripheral0.pBaseAddress->SPI_IER = (AT91C_SPI_TDRE | AT91C_SPI_RDRF);
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0x....             LDR.N    R1,??DataTable11_3
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0x6148             STR      R0,[R1, #+20]
   \   00000078   0xE02E             B.N      ??SpiSM_Idle_1
    683          
    684                
    685              } /* end of receive function */
    686              else
    687              {
    688                /* Transmitting: update the message's status and flag that the peripheral is now busy */
    689                UpdateMessageStatus(SPI_Peripheral0.psTransmitBuffer->u32Token, SENDING);
   \                     ??SpiSM_Idle_2: (+1)
   \   0000007A   0x2102             MOVS     R1,#+2
   \   0000007C   0x....             LDR.N    R0,??DataTable11_3
   \   0000007E   0x6A00             LDR      R0,[R0, #+32]
   \   00000080   0x6800             LDR      R0,[R0, #+0]
   \   00000082   0x.... 0x....      BL       UpdateMessageStatus
    690                SPI_Peripheral0.u32PrivateFlags |= _SPI_PERIPHERAL_TX;    
   \   00000086   0x....             LDR.N    R0,??DataTable11_3
   \   00000088   0x6900             LDR      R0,[R0, #+16]
   \   0000008A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000008E   0x....             LDR.N    R1,??DataTable11_3
   \   00000090   0x6108             STR      R0,[R1, #+16]
    691                
    692                /* Load in the message parameters. */
    693                SPI_Peripheral0.u32CurrentTxBytesRemaining = SPI_Peripheral0.psTransmitBuffer->u32Size;
   \   00000092   0x....             LDR.N    R0,??DataTable11_3
   \   00000094   0x6A00             LDR      R0,[R0, #+32]
   \   00000096   0x6840             LDR      R0,[R0, #+4]
   \   00000098   0x....             LDR.N    R1,??DataTable11_3
   \   0000009A   0x6248             STR      R0,[R1, #+36]
    694                SPI_Peripheral0.pu8CurrentTxData = SPI_Peripheral0.psTransmitBuffer->pu8Message;
   \   0000009C   0x....             LDR.N    R0,??DataTable11_3
   \   0000009E   0x6A00             LDR      R0,[R0, #+32]
   \   000000A0   0x3008             ADDS     R0,R0,#+8
   \   000000A2   0x....             LDR.N    R1,??DataTable11_3
   \   000000A4   0x6288             STR      R0,[R1, #+40]
    695                 
    696                /* Load first byte.  If we need LSB first, use inline assembly to flip bits with a single instruction. */
    697                u32Byte = 0x000000FF &  *SPI_Peripheral0.pu8CurrentTxData;
   \   000000A6   0x....             LDR.N    R0,??DataTable11_3
   \   000000A8   0x6A80             LDR      R0,[R0, #+40]
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x0004             MOVS     R4,R0
    698                if(SPI_Peripheral0.eBitOrder == SPI_LSB_FIRST)
   \   000000AE   0x....             LDR.N    R0,??DataTable11_3
   \   000000B0   0x7B00             LDRB     R0,[R0, #+12]
   \   000000B2   0x2801             CMP      R0,#+1
   \   000000B4   0xD103             BNE.N    ??SpiSM_Idle_3
    699                {
    700                  u32Byte = __RBIT(u32Byte) >> 24;
   \   000000B6   0xFA94 0xF0A4      RBIT     R0,R4
   \   000000BA   0x0E00             LSRS     R0,R0,#+24
   \   000000BC   0x0004             MOVS     R4,R0
    701                }
    702                 
    703                /* Enable the SPI peripheral, load the byte, then enable interrupts */
    704                SPI_Peripheral0.pBaseAddress->SPI_CR = AT91C_SPI_SPIEN;
   \                     ??SpiSM_Idle_3: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable11_3
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    705                SPI_Peripheral0.pBaseAddress->SPI_TDR = (u8)u32Byte; 
   \   000000C6   0x0020             MOVS     R0,R4
   \   000000C8   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000000CA   0x....             LDR.N    R1,??DataTable11_3
   \   000000CC   0x6809             LDR      R1,[R1, #+0]
   \   000000CE   0x60C8             STR      R0,[R1, #+12]
    706                SPI_Peripheral0.pBaseAddress->SPI_IER = (AT91C_SPI_TDRE | AT91C_SPI_RDRF);
   \   000000D0   0x2003             MOVS     R0,#+3
   \   000000D2   0x....             LDR.N    R1,??DataTable11_3
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x6148             STR      R0,[R1, #+20]
    707                
    708              } /* end of transmitting function */
    709              
    710            } /* end if */
    711            
    712          } /* end SpiSM_Idle() */
   \                     ??SpiSM_Idle_1: (+1)
   \   000000D8   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     SPI_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x05303001         DC32     0x5303001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     SPI_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     G_u32Spi0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     Spi_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0xA5000001         DC32     0xa5000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x400E1250         DC32     0x400e1250

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_15:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_16:
   \   00000000   0x........         DC32     SPI_Peripheral0+0x20

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012SPI message too large\012\015"
   \              0x53 0x50    
   \              0x49 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x61    
   \              0x72 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x53 0x50          DC8 "SPI Peripheral Ready\012\015"
   \              0x49 0x20    
   \              0x50 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x61 0x6C    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x0A 0x0D    
   \              0x00         
   \   00000017   0x00               DC8 0
    713          
    714          
    715          #if 0
    716          /*!-------------------------------------------------------------------------------------------------------------------
    717          @fn static void SpiSM_Error(void)          
    718          
    719          @brief Handle an error 
    720          
    721          */
    722          static void SpiSM_Error(void)          
    723          {
    724            Spi_pfnStateMachine = SpiSM_Idle;
    725            
    726          } /* end SpiSM_Error() */
    727          #endif
    728                  
    729          
    730          
    731          
    732          
    733          /*--------------------------------------------------------------------------------------------------------------------*/
    734          /* End of File */
    735          /*--------------------------------------------------------------------------------------------------------------------*/
    736          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
      16   SPI0_IrqHandler
        16   -> DeQueueMessage
        16   -> UpdateMessageStatus
       8   SpiInitialize
         8   -> DebugPrintf
       8   SpiManualMode
         8   -- Indirect call
         8   -> IsTimeUp
         8   -> MessagingRunActiveState
       0   SpiQueryReceiveStatus
       0   SpiReadByte
      16   SpiReadData
        16   -> DebugPrintf
       8   SpiRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      24   SpiRequest
        24   -> NVIC_ClearPendingIRQ
        24   -> NVIC_EnableIRQ
        24   -> __aeabi_memset
       8   SpiRunActiveState
         8   -- Indirect call
      24   SpiSM_Idle
        24   -> UpdateMessageStatus
        24   -> __aeabi_memset
      24   SpiWriteByte
        24   -> QueueMessage
        24   -> SpiManualMode
      24   SpiWriteData
        24   -> QueueMessage
        24   -> SpiManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_15
       4  ??DataTable11_16
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      28  ?_0
      24  ?_1
       4  G_u32Spi0ApplicationFlags
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
     320  SPI0_IrqHandler
      44  SPI_Peripheral0
       4  SPI_u32Flags
      78  SpiInitialize
      60  SpiManualMode
      54  SpiQueryReceiveStatus
      36  SpiReadByte
      56  SpiReadData
      80  SpiRelease
     334  SpiRequest
      10  SpiRunActiveState
     218  SpiSM_Idle
      48  SpiWriteByte
      56  SpiWriteData
       4  Spi_pfnStateMachine

 
    56 bytes in section .bss
    52 bytes in section .rodata
 1 484 bytes in section .text
 
 1 484 bytes of CODE  memory
    52 bytes of CONST memory
    56 bytes of DATA  memory

Errors: none
Warnings: none
