###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:31
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\application\debug.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\application\debug.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\debug.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\debug.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\application\debug.c
      1          /*!**********************************************************************************************************************
      2          @file debug.c 
      3          @brief Debugging functions and state machine. 
      4          
      5          *** Note that there is a maximum of 32 message slots for all system messaging, 
      6          and every call to DebugPrintf takes one of those slots.  It tends to be easy 
      7          to queue 10-20 DebugPrintf messages in a single function before any of them
      8          get processed through the system.  In this case, you end up with unexpected
      9          behavior. ****
     10          
     11          Provides the terminal interface and also a local command-driven debugging
     12          system for teh system.
     13          
     14          Since the system is small, debugger commands will be strictly numerical, 
     15          though each command will have a string name that can
     16          be requested by the user.  The debugger will print a list of these commands if 
     17          requested using en+c00.  Commands range from 01 to 99 (must include the leading 0
     18          for single-digit commands) and all commands must have the prefix en+c. 
     19          The current command list can be quickly checked in debug_x.h (where x is application-specific)
     20          
     21          This application requires a UART resource for input/output data.
     22          
     23          The terminal program used to interface to the debugger should be set to:
     24          - no local echo
     25          - send "CR" for new line
     26          - 115200-8-N-1
     27          
     28          ------------------------------------------------------------------------------------------------------------------------
     29          GLOBALS
     30          - G_au8DebugScanfBuffer[] is the DebugScanf() input buffer that can be read directly.
     31            It is cleared whenever DebugScanf() is called.
     32          - G_u8DebugScanfCharCount holds number of characters in Debug_au8ScanfBuffer.
     33            It is cleared whenever DebugScanf() is called.
     34          
     35          Copy the following into your task in section global "Existing variables":
     36          
     37          extern u8 G_au8DebugScanfBuffer[DEBUG_SCANF_BUFFER_SIZE]; // From debug.c
     38          extern u8 G_u8DebugScanfCharCount;                        // From debug.c
     39          
     40          CONSTANTS
     41          - DEBUG_SCANF_BUFFER_SIZE is the size of G_au8DebugScanfBuffer and thus the max of G_u8DebugScanfCharCount
     42          
     43          TYPES
     44          - NONE
     45          
     46          PUBLIC FUNCTIONS
     47          - u32 DebugPrintf(u8* u8String_)
     48          - void DebugLineFeed(void)
     49          - void DebugPrintNumber(u32 u32Number_)
     50          - u8 DebugScanf(u8* pu8Buffer_)
     51          - void DebugSetPassthrough(void)
     52          - void DebugClearPassthrough(void)
     53          
     54          
     55          ***********************************************************************************************************************/
     56          
     57          #include "configuration.h"
     58          
     59          /***********************************************************************************************************************
     60          Global variable definitions with scope across entire project.
     61          All Global variable names shall start with "G_<type>Debug"
     62          ***********************************************************************************************************************/
     63          /* New variables */

   \                                 In section .bss, align 4
     64          u32 G_u32DebugFlags;                                   /*!< @brief Debug flag register */
   \                     G_u32DebugFlags:
   \   00000000                      DS8 4
     65          

   \                                 In section .bss, align 4
     66          u8 G_au8DebugScanfBuffer[DEBUG_SCANF_BUFFER_SIZE];     /*!< @brief Space to latch characters for DebugScanf() */
   \                     G_au8DebugScanfBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 1
     67          u8 G_u8DebugScanfCharCount = 0;                        /*!< @brief Counter for # of characters in Debug_au8ScanfBuffer */
   \                     G_u8DebugScanfCharCount:
   \   00000000                      DS8 1
     68          
     69          
     70          /*--------------------------------------------------------------------------------------------------------------------*/
     71          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     72          extern volatile u32 G_u32SystemTime1ms;                /*!< @brief From main.c */
     73          extern volatile u32 G_u32SystemTime1s;                 /*!< @brief From main.c */
     74          extern volatile u32 G_u32SystemFlags;                  /*!< @brief From main.c */
     75          extern volatile u32 G_u32ApplicationFlags;             /*!< @brief From main.c */
     76          
     77          extern const u8 G_aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE]; /*!< @brief From main.c */
     78          
     79          extern u8 G_au8UtilMessageON[];                        /*!< @brief From utilities.c */
     80          extern u8 G_au8UtilMessageOFF[];                       /*!< @brief From utilities.c */
     81          
     82          
     83          /***********************************************************************************************************************
     84          Global variable definitions with scope limited to this local application.
     85          Variable names shall start with "Debug_<type>" and be declared as static.
     86          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     87          static fnCode_type Debug_pfnStateMachine;                /*!< @brief The Debug state machine function pointer */
   \                     Debug_pfnStateMachine:
   \   00000000                      DS8 4
     88          

   \                                 In section .bss, align 4
     89          static UartPeripheralType* Debug_Uart;                   /*!< @brief Pointer to debug UART peripheral object */
   \                     Debug_Uart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     90          static u8 Debug_u8ErrorCode;                             /*!< @brief Error code */
   \                     Debug_u8ErrorCode:
   \   00000000                      DS8 1
     91          

   \                                 In section .bss, align 4
     92          static u8 Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE];       /*!< @brief Space for incoming characters of debug commands */
   \                     Debug_au8RxBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
     93          static u8 *Debug_pu8RxBufferNextChar;                    /*!< @brief Pointer to next spot in the Rxbuffer */
   \                     Debug_pu8RxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     94          static u8 *Debug_pu8RxBufferParser;                      /*!< @brief Pointer to loop through the Rx buffer */
   \                     Debug_pu8RxBufferParser:
   \   00000000                      DS8 4
     95          

   \                                 In section .bss, align 4
     96          static u32 Debug_au32MsgTokens[DEBUG_TOKEN_ARRAY_SIZE];  /*!< @brief Message tokens for transfers */
   \                     Debug_au32MsgTokens:
   \   00000000                      DS8 64

   \                                 In section .bss, align 1
     97          static u8 Debug_u8TokenCounter;                          /*!< @brief Number of stored tokens */
   \                     Debug_u8TokenCounter:
   \   00000000                      DS8 1
     98          

   \                                 In section .bss, align 4
     99          static u8 Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]; /*!< @brief Space to store chars as they build up to the next command */ 
   \                     Debug_au8CommandBuffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
    100          static u8 *Debug_pu8CmdBufferNextChar;                   /*!< @brief Pointer to incoming char location in the command buffer */
   \                     Debug_pu8CmdBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    101          static u16 Debug_u16CommandSize;                         /*!< @brief Number of characters in the command buffer */
   \                     Debug_u16CommandSize:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
    102          static u8 Debug_u8Command;                               /*!< @brief A validated command number */
   \                     Debug_u8Command:
   \   00000000                      DS8 1
    103          
    104          /*! @brief Add commands by updating debug.h in the Command-Specific Definitions section, then update this list
    105          with the function name to call for the corresponding command: */
    106          #ifdef EIE_ASCII

   \                                 In section .data, align 4
    107          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = 
   \                     Debug_au8Commands:
   \   00000000   0x........         DC32 ?_0, DebugCommandPrepareList, ?_1, DebugCommandLedTestToggle, ?_2
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 DebugCommandSysTimeToggle, ?_3, DebugCommandDummy, ?_4
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 DebugCommandDummy, ?_5, DebugCommandDummy, ?_6, DebugCommandDummy
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 ?_7, DebugCommandDummy
   \              0x........   
    108          { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
    109            {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    110            {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    111            {DEBUG_CMD_NAME03, DebugCommandDummy},
    112            {DEBUG_CMD_NAME04, DebugCommandDummy},
    113            {DEBUG_CMD_NAME05, DebugCommandDummy},
    114            {DEBUG_CMD_NAME06, DebugCommandDummy},
    115            {DEBUG_CMD_NAME07, DebugCommandDummy} 
    116          };
    117          

   \                                 In section .data, align 4
    118          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 ASCII LCD DEVELOPMENT BOARD ***\n\n\r";
   \                     Debug_au8StartupMsg:
   \   00000000   0x0A 0x0A          DC8 0AH, 0AH, 0DH, 2AH, 2AH, 2AH, 20H, 52H
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x20 0x52    
   \   00000008   0x41 0x5A          DC8 41H, 5AH, 4FH, 52H, 20H, 53H, 41H, 4DH
   \              0x4F 0x52    
   \              0x20 0x53    
   \              0x41 0x4D    
   \   00000010   0x33 0x55          DC8 33H, 55H, 32H, 20H, 41H, 53H, 43H, 49H
   \              0x32 0x20    
   \              0x41 0x53    
   \              0x43 0x49    
   \   00000018   0x49 0x20          DC8 49H, 20H, 4CH, 43H, 44H, 20H, 44H, 45H
   \              0x4C 0x43    
   \              0x44 0x20    
   \              0x44 0x45    
   \   00000020   0x56 0x45          DC8 56H, 45H, 4CH, 4FH, 50H, 4DH, 45H, 4EH
   \              0x4C 0x4F    
   \              0x50 0x4D    
   \              0x45 0x4E    
   \   00000028   0x54 0x20          DC8 54H, 20H, 42H, 4FH, 41H, 52H, 44H, 20H
   \              0x42 0x4F    
   \              0x41 0x52    
   \              0x44 0x20    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 0AH, 0AH, 0DH, 0
   \              0x2A 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000037   0x00               DC8 0
    119          #endif /* EIE_ASCII */
    120          
    121          #ifdef EIE_DOTMATRIX
    122          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = 
    123          { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
    124            {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    125            {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    126            {DEBUG_CMD_NAME03, DebugCommandCaptouchValuesToggle},
    127            {DEBUG_CMD_NAME04, DebugCommandDummy},
    128            {DEBUG_CMD_NAME05, DebugCommandDummy},
    129            {DEBUG_CMD_NAME06, DebugCommandDummy},
    130            {DEBUG_CMD_NAME07, DebugCommandDummy} 
    131          };
    132          
    133          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 DOT MATRIX LCD DEVELOPMENT BOARD ***\n\n\r";
    134          #endif /* EIE_DOTMATRIX */
    135          
    136          
    137          /***********************************************************************************************************************
    138          * Function Definitions
    139          ***********************************************************************************************************************/
    140          
    141          /*--------------------------------------------------------------------------------------------------------------------*/
    142          /*! @publicsection */                                                                                            
    143          /*--------------------------------------------------------------------------------------------------------------------*/
    144          
    145          /*!----------------------------------------------------------------------------------------------------------------------
    146          @fn u32 DebugPrintf(u8* u8String_)
    147          
    148          @brief Queues the string pointed to by u8String_ to the Debug port.  
    149          
    150          The string must be null-terminated.  It may also contain control characters 
    151          like newline (\n) and linefeed (\f)
    152          
    153          Example:
    154          u8 u8String[] = "A string to print.\n\r"
    155          
    156          DebugPrintf(u8String);
    157          
    158          Requires:
    159          - The debug UART resource has been setup for the debug application.
    160          - The size of the string will not exceed the total available message
    161            slots in the system.  As a guideline, this should be less than
    162            10 x U16_MAX_TX_MESSAGE_LENGTH but this is not enforced.
    163          
    164          @param u8String_ is a NULL-terminated C-string
    165          
    166          Promises:
    167          - The string is queued to the debug UART.
    168          - The message token is returned
    169          
    170          */

   \                                 In section .text, align 2, keep-with-next
    171          u32 DebugPrintf(u8* u8String_)
    172          {
   \                     DebugPrintf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    173            u8* pu8Parser = u8String_;
   \   00000004   0x0025             MOVS     R5,R4
    174            u32 u32Size = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    175            
    176            while(*pu8Parser != '\0') 
   \                     ??DebugPrintf_0: (+1)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??DebugPrintf_1
    177            {
    178              u32Size++;
   \   0000000E   0x1C76             ADDS     R6,R6,#+1
    179              pu8Parser++;
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \   00000012   0xE7F9             B.N      ??DebugPrintf_0
    180            }
    181              
    182            return( UartWriteData(Debug_Uart, u32Size, u8String_) );
   \                     ??DebugPrintf_1: (+1)
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       UartWriteData
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    183           
    184          } /* end DebugPrintf() */
    185          
    186          
    187          /*!----------------------------------------------------------------------------------------------------------------------
    188          @fn void DebugLineFeed(void)
    189          
    190          @brief Queues a <CR><LF> sequence to the debug UART.  
    191          
    192          This is slightly more efficient than calling DebugPrintf("\n\r");
    193          
    194          
    195          Requires:
    196          - NONE
    197          
    198          Promises:
    199          - <CR><LF> sequence is sent to the debug UART
    200          
    201          */

   \                                 In section .text, align 2, keep-with-next
    202          void DebugLineFeed(void)
    203          {
   \                     DebugLineFeed: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    204            u8 au8Linefeed[] = {ASCII_LINEFEED, ASCII_CARRIAGE_RETURN};
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_1
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    205            
    206            UartWriteData(Debug_Uart, sizeof(au8Linefeed), &au8Linefeed[0]);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       UartWriteData
    207          
    208          } /* end DebugLineFeed() */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    209          
    210          
    211          /*!-----------------------------------------------------------------------------/
    212          @fn void DebugPrintNumber(u32 u32Number_)
    213          @brief Formats a long into an ASCII string and queues to print.  
    214          
    215          Leading zeros are not printed. Unsigned (positive) values only.
    216          
    217          Example:
    218          
    219          u32 u32Number = 1234567;
    220          
    221          DebugPrintNumber(u32Number);
    222          
    223          
    224          Requires:
    225          - Enough space is available on the heap to temporarily store the number array
    226          
    227          @param u32Number_ is the number to print.
    228          
    229          Promises:
    230          - The number is converted to an array of ascii without leading zeros and sent to UART
    231          
    232          */

   \                                 In section .text, align 2, keep-with-next
    233          void DebugPrintNumber(u32 u32Number_)
    234          {
   \                     DebugPrintNumber: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    235            bool bFoundDigit = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
    236            u8 au8AsciiNumber[10];
    237            u8 u8CharCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    238            u32 u32Temp, u32Divider = 1000000000;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable18_2  ;; 0x3b9aca00
    239            u8 *pu8Data;
    240            
    241            /* Parse out all the digits, start counting after leading zeros */
    242            for(u8 index = 0; index < 10; index++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??DebugPrintNumber_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xDA19             BGE.N    ??DebugPrintNumber_1
    243            {
    244              /* Get the digit and add offset to get ASCII character */
    245              au8AsciiNumber[index] = (u32Number_ / u32Divider) + NUMBER_ASCII_TO_DEC;
   \   00000016   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000001A   0x3130             ADDS     R1,R1,#+48
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x5481             STRB     R1,[R0, R2]
    246              if(au8AsciiNumber[index] != '0')
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x5C41             LDRB     R1,[R0, R1]
   \   00000028   0x2930             CMP      R1,#+48
   \   0000002A   0xD001             BEQ.N    ??DebugPrintNumber_2
    247              {
    248                bFoundDigit = TRUE;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x000D             MOVS     R5,R1
    249              }
    250              if(bFoundDigit)
   \                     ??DebugPrintNumber_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD000             BEQ.N    ??DebugPrintNumber_3
    251              {
    252                u8CharCount++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    253              }
    254              u32Number_ %= u32Divider;
   \                     ??DebugPrintNumber_3: (+1)
   \   00000038   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000003C   0xFB08 0x4411      MLS      R4,R8,R1,R4
    255              u32Divider /= 10;
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0xFBB8 0xF8F1      UDIV     R8,R8,R1
    256            }
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE7E2             B.N      ??DebugPrintNumber_0
    257            
    258            /* Handle special case where u32Number == 0 */
    259            if(!bFoundDigit)
   \                     ??DebugPrintNumber_1: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD101             BNE.N    ??DebugPrintNumber_4
    260            {
    261              u8CharCount = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0006             MOVS     R6,R0
    262            }
    263            
    264            /* Allocate memory for the number and copy the array */
    265            pu8Data = malloc(u8CharCount);
   \                     ??DebugPrintNumber_4: (+1)
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       malloc
   \   0000005C   0x4681             MOV      R9,R0
    266            if (pu8Data == NULL)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD108             BNE.N    ??DebugPrintNumber_5
    267            {
    268              Debug_u8ErrorCode = DEBUG_ERROR_MALLOC;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable18_3
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    269              Debug_pfnStateMachine = DebugSM_Error;
   \   0000006C   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \   00000074   0x6008             STR      R0,[R1, #+0]
    270            }
    271            
    272            u32Temp = 9;
   \                     ??DebugPrintNumber_5: (+1)
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0x0007             MOVS     R7,R0
    273            for(u8 index = u8CharCount; index != 0; index--)
   \   0000007A   0x0030             MOVS     R0,R6
   \                     ??DebugPrintNumber_6: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD009             BEQ.N    ??DebugPrintNumber_7
    274            {
    275              pu8Data[index - 1] = au8AsciiNumber[u32Temp--];
   \   00000082   0xA900             ADD      R1,SP,#+0
   \   00000084   0x5C79             LDRB     R1,[R7, R1]
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xEB10 0x0209      ADDS     R2,R0,R9
   \   0000008C   0xF802 0x1C01      STRB     R1,[R2, #-1]
   \   00000090   0x1E7F             SUBS     R7,R7,#+1
    276            }
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0xE7F2             B.N      ??DebugPrintNumber_6
    277              
    278            /* Print the ascii string and free the memory */
    279            UartWriteData(Debug_Uart, u8CharCount, pu8Data);
   \                     ??DebugPrintNumber_7: (+1)
   \   00000096   0x464A             MOV      R2,R9
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UartWriteData
    280            free(pu8Data);
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       free
    281            
    282          } /* end DebugDebugPrintNumber() */
   \   000000AC   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    283          
    284          
    285          /*!----------------------------------------------------------------------------------------------------------------------
    286          @fn u8 DebugScanf(u8* pu8Buffer_)
    287          
    288          @brief Copies G_u8DebugScanfCharCount characters from G_au8DebugScanfBuffer to a target array 
    289          so the input can be saved.  
    290          
    291          Once copied, G_au8DebugScanfBuffer is cleared and G_u8DebugScanfCharCount is zeroed.
    292          Note that the debug task is blocked here so new characters are not added while
    293          the function executes.
    294          
    295          Example:
    296          
    297          u8 u8MyBuffer[SCANF_BUFFER_SIZE]
    298          
    299          u8 u8NumChars;
    300          
    301          u8NumChars = DebugScanf(u8MyBuffer);
    302          
    303          Requires:
    304          - G_u8DebugScanfCharCount holds the number of characters in the G_au8DebugScanfBuffer
    305          
    306          @param pu8Buffer_ points to an array large enough to hold G_u8DebugScanfCharCount characters
    307          
    308          Promises:
    309          - pu8Buffer_ receives G_u8DebugScanfCharCount characters 
    310          - G_au8DebugScanfBuffer[i] = '\0', where 0 <= i <= DEBUG_SCANF_BUFFER_SIZE
    311          - G_u8DebugScanfCharCount = 0
    312          
    313          */

   \                                 In section .text, align 2, keep-with-next
    314          u8 DebugScanf(u8* pu8Buffer_)
    315          {
   \                     DebugScanf: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    316            u8 u8Temp = G_u8DebugScanfCharCount;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable18_5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
    317            
    318            /* Copy the characters, clearing as we go */
    319            for(u8 i = 0; i < G_u8DebugScanfCharCount; i++)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??DebugScanf_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable18_5
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD20C             BCS.N    ??DebugScanf_1
    320            {
    321              *(pu8Buffer_ + i) = G_au8DebugScanfBuffer[i];
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable18_6
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x5CD3             LDRB     R3,[R2, R3]
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x5453             STRB     R3,[R2, R1]
    322              G_au8DebugScanfBuffer[i] = '\0';
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable18_6
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x5513             STRB     R3,[R2, R4]
    323            }
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \   00000030   0xE7EC             B.N      ??DebugScanf_0
    324            
    325            G_u8DebugScanfCharCount = 0;
   \                     ??DebugScanf_1: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable18_5
   \   00000038   0x701A             STRB     R2,[R3, #+0]
    326            return u8Temp;
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    327            
    328          } /* end DebugScanf() */
    329          
    330          
    331          /*!----------------------------------------------------------------------------------------------------------------------
    332          @fn void DebugSetPassthrough(void)
    333          
    334          @brief Puts the Debug task in Passthrough mode.
    335          
    336          ALL characters received are put in to the Scanf buffer and
    337          the Debug task does not look for input for the menu system. 
    338          This allows task to have full access to 
    339          terminal input without the Debug task printing messages or 
    340          stealing Backspace characters.
    341          
    342          Passthrough mode does NOT disable any other Debug functions that 
    343          have already been enabled.  For example, if you want the 1ms timing 
    344          violation warning you can enable this and then enable Passthrough mode.
    345          
    346          Requires:
    347          - NONE
    348          
    349          Promises:
    350          @param G_u32DebugFlags _DEBUG_PASSTHROUGH is set
    351          
    352          */

   \                                 In section .text, align 2, keep-with-next
    353          void DebugSetPassthrough(void)
    354          {
   \                     DebugSetPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    355            G_u32DebugFlags |= _DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable18_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    356            
    357            DebugPrintf("\n\n\r***Debug Passthrough enabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_8
   \   00000016   0x.... 0x....      BL       DebugPrintf
    358          
    359          } /* end DebugSetPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    360          
    361          
    362          /*!----------------------------------------------------------------------------------------------------------------------
    363          @fn void DebugClearPassthrough(void)
    364          
    365          @brief Takes the Debug task out of Passthrough mode.
    366          
    367          Requires:
    368          - NONE
    369          
    370          Promises:
    371          @param G_u32DebugFlags _DEBUG_PASSTHROUGH is cleared
    372          
    373          */

   \                                 In section .text, align 2, keep-with-next
    374          void DebugClearPassthrough(void)
    375          {
   \                     DebugClearPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    376            G_u32DebugFlags &= ~_DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable18_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    377            
    378            DebugPrintf("\n\n\r***Debug Passthrough disabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable18_9
   \   00000016   0x.... 0x....      BL       DebugPrintf
    379            
    380          } /* end DebugClearPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    381          
    382          
    383          /*!----------------------------------------------------------------------------------------------------------------------
    384          @fn void SystemStatusReport(void)
    385          
    386          @brief Reports system-level messages from the Debug task.
    387          
    388          Right now, the system status is limited to the start-up results of each task. 
    389          However if a task crashes or reaches an unknown state, it can change its
    390          status flag and then SystemStatus report could display this.  
    391          
    392          When a new task is added:
    393          - G_u32ApplicationFlags (configuration.h) should get a new flag for the task
    394          - NUMBER_APPLICATIONS (configuration.h) should be incremented
    395          - G_aau8AppShortNames list should get a message string for the task name. This
    396          list must match the order of the flags in G_u32ApplicationFlags.
    397          
    398          This function can be used if the system is in initialization state 
    399          
    400          Requires:
    401          @param G_u32SystemFlags up to date with system status
    402          
    403          Promises:
    404          - Prints out messages for any system test that failed
    405          - Prints out overall good message if all tests passed
    406          - Prints instructions to access the Debug menu
    407          
    408          */

   \                                 In section .text, align 2, keep-with-next
    409          void SystemStatusReport(void)
    410          {
   \                     SystemStatusReport: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB098             SUB      SP,SP,#+96
    411            u8 au8SystemPassed[] = "No failed tasks.\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_10
   \   0000000A   0x2213             MOVS     R2,#+19
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    412            u8 au8SystemReady[] = "\n\rInitialization complete. Type en+c00 for debug menu.  Failed tasks:\n\r";
   \   00000010   0xA805             ADD      R0,SP,#+20
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable18_11
   \   00000016   0x2248             MOVS     R2,#+72
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    413            u32 u32TaskFlagMaskBit = (u32)0x01;
   \   0000001C   0x2401             MOVS     R4,#+1
    414            bool bNoFailedTasks = TRUE;
   \   0000001E   0x2501             MOVS     R5,#+1
    415          
    416          
    417            /* Announce init complete then report any tasks that failed init */
    418            DebugPrintf(au8SystemReady);
   \   00000020   0xA805             ADD      R0,SP,#+20
   \   00000022   0x.... 0x....      BL       DebugPrintf
    419              
    420            for(u8 i = 0; i < NUMBER_APPLICATIONS; i++)
   \   00000026   0x2600             MOVS     R6,#+0
   \                     ??SystemStatusReport_0: (+1)
   \   00000028   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000002A   0x2E07             CMP      R6,#+7
   \   0000002C   0xDA13             BGE.N    ??SystemStatusReport_1
    421            {
    422              if( !(u32TaskFlagMaskBit & G_u32ApplicationFlags) )
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable18_12
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x4204             TST      R4,R0
   \   00000036   0xD10B             BNE.N    ??SystemStatusReport_2
    423              {
    424                bNoFailedTasks = FALSE;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x0005             MOVS     R5,R0
    425                DebugPrintf((u8*)&G_aau8AppShortNames[i][0]);
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_13
   \   00000040   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000048   0x.... 0x....      BL       DebugPrintf
    426                DebugLineFeed();
   \   0000004C   0x.... 0x....      BL       DebugLineFeed
    427              }
    428              
    429              u32TaskFlagMaskBit <<= 1;
   \                     ??SystemStatusReport_2: (+1)
   \   00000050   0x0064             LSLS     R4,R4,#+1
    430            }     
   \   00000052   0x1C76             ADDS     R6,R6,#+1
   \   00000054   0xE7E8             B.N      ??SystemStatusReport_0
    431                  
    432            if( bNoFailedTasks)
   \                     ??SystemStatusReport_1: (+1)
   \   00000056   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000058   0x2D00             CMP      R5,#+0
   \   0000005A   0xD002             BEQ.N    ??SystemStatusReport_3
    433            {
    434              DebugPrintf(au8SystemPassed);
   \   0000005C   0xA800             ADD      R0,SP,#+0
   \   0000005E   0x.... 0x....      BL       DebugPrintf
    435            }
    436            
    437            DebugLineFeed();
   \                     ??SystemStatusReport_3: (+1)
   \   00000062   0x.... 0x....      BL       DebugLineFeed
    438            
    439          } /* end SystemStatusReport() */
   \   00000066   0xB018             ADD      SP,SP,#+96
   \   00000068   0xBD70             POP      {R4-R6,PC}       ;; return
    440          
    441          
    442          /*--------------------------------------------------------------------------------------------------------------------*/
    443          /*! @protectedsection */                                                                                            
    444          /*--------------------------------------------------------------------------------------------------------------------*/
    445          
    446          /*!----------------------------------------------------------------------------------------------------------------------
    447          @fn void DebugInitialize(void)
    448          
    449          @brief Sets up the debug command list and activates the debug functionality.
    450          
    451          Should only be called once in main init section.
    452          
    453          Requires:
    454          - The debug application is not yet running
    455          - The UART resource requested should be free
    456          
    457          Promises:
    458          - Debug_au8RxBuffer[] initialized to all 0
    459          
    460          @param Debug_pu8CmdBufferCurrentChar set to Debug_au8RxBuffer[0]
    461          @param Debug_pu8RxBufferParser set to Debug_au8RxBuffer[0]
    462          @param Debug_pfnStateMachine set to Idle
    463          
    464          */

   \                                 In section .text, align 2, keep-with-next
    465          void DebugInitialize(void)
    466          {
   \                     DebugInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    467            u8 au8FirmwareVersion[] = FIRMWARE_VERSION;
   \   00000004   0xA804             ADD      R0,SP,#+16
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_14
   \   0000000A   0x221C             MOVS     R2,#+28
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    468            UartConfigurationType sUartConfig;  
    469          
    470            /* Clear the receive buffer and initialize its pointers */
    471            for (u16 i = 0; i < DEBUG_RX_BUFFER_SIZE; i++)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_0: (+1)
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x2880             CMP      R0,#+128
   \   00000016   0xDA06             BGE.N    ??DebugInitialize_1
    472            {
    473              Debug_au8RxBuffer[i] = 0;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x.... 0x....      LDR.W    R2,??DataTable18_15
   \   0000001E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000020   0x5481             STRB     R1,[R0, R2]
    474            }
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7F5             B.N      ??DebugInitialize_0
    475          
    476            Debug_pu8RxBufferParser    = &Debug_au8RxBuffer[0];
   \                     ??DebugInitialize_1: (+1)
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable18_15
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable18_16
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    477            Debug_pu8RxBufferNextChar  = &Debug_au8RxBuffer[0]; 
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable18_15
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable18_17
   \   00000038   0x6008             STR      R0,[R1, #+0]
    478          
    479            /* Clear the scanf buffer and counter */
    480            G_u8DebugScanfCharCount = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable18_5
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    481            for (u8 i = 0; i < DEBUG_SCANF_BUFFER_SIZE; i++)
   \   00000042   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_2: (+1)
   \   00000044   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000046   0x2880             CMP      R0,#+128
   \   00000048   0xDA06             BGE.N    ??DebugInitialize_3
    482            {
    483              G_au8DebugScanfBuffer[i] = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x.... 0x....      LDR.W    R2,??DataTable18_6
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0x5481             STRB     R1,[R0, R2]
    484            }
   \   00000054   0x1C40             ADDS     R0,R0,#+1
   \   00000056   0xE7F5             B.N      ??DebugInitialize_2
    485          
    486            /* Initailze the command array as needed */
    487            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0]; 
   \                     ??DebugInitialize_3: (+1)
   \   00000058   0x.... 0x....      LDR.W    R0,??DataTable18_18
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable18_19
   \   00000060   0x6008             STR      R0,[R1, #+0]
    488          
    489            /* Request the UART resource to be used for the Debug application */
    490            sUartConfig.UartPeripheral     = DEBUG_UART;
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0xF88D 0x0000      STRB     R0,[SP, #+0]
    491            sUartConfig.pu8RxBufferAddress = &Debug_au8RxBuffer[0];
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable18_15
   \   0000006C   0x9001             STR      R0,[SP, #+4]
    492            sUartConfig.pu8RxNextByte      = &Debug_pu8RxBufferNextChar;
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable18_17
   \   00000072   0x9002             STR      R0,[SP, #+8]
    493            sUartConfig.u16RxBufferSize    = DEBUG_RX_BUFFER_SIZE;
   \   00000074   0x2080             MOVS     R0,#+128
   \   00000076   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    494            sUartConfig.fnRxCallback       = DebugRxCallback;
   \   0000007A   0x.... 0x....      ADR.W    R0,DebugRxCallback
   \   0000007E   0x9003             STR      R0,[SP, #+12]
    495            
    496            Debug_Uart = UartRequest(&sUartConfig);
   \   00000080   0xA800             ADD      R0,SP,#+0
   \   00000082   0x.... 0x....      BL       UartRequest
   \   00000086   0x.... 0x....      LDR.W    R1,??DataTable18
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    497            
    498            /* Go to error state if the UartRequest failed */
    499            if(Debug_Uart == NULL)
   \   0000008C   0x.... 0x....      LDR.W    R0,??DataTable18
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD105             BNE.N    ??DebugInitialize_4
    500            {
    501              Debug_pfnStateMachine = DebugSM_Error;
   \   00000096   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \   0000009E   0x6008             STR      R0,[R1, #+0]
   \   000000A0   0xE013             B.N      ??DebugInitialize_5
    502          
    503            }
    504            /* Otherwise send the first message, set "good" flag and head to Idle */
    505            else
    506            {
    507              DebugPrintf(Debug_au8StartupMsg);   
   \                     ??DebugInitialize_4: (+1)
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable18_20
   \   000000A6   0x.... 0x....      BL       DebugPrintf
    508              DebugPrintf(au8FirmwareVersion);
   \   000000AA   0xA804             ADD      R0,SP,#+16
   \   000000AC   0x.... 0x....      BL       DebugPrintf
    509              
    510              G_u32ApplicationFlags |= _APPLICATION_FLAGS_DEBUG;
   \   000000B0   0x.... 0x....      LDR.W    R0,??DataTable18_12
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable18_12
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    511              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000C0   0x.... 0x....      ADR.W    R0,DebugSM_Idle
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable18_4
   \   000000C8   0x6008             STR      R0,[R1, #+0]
    512            }
    513            
    514          } /* end  DebugInitialize() */
   \                     ??DebugInitialize_5: (+1)
   \   000000CA   0xB00B             ADD      SP,SP,#+44
   \   000000CC   0xBD00             POP      {PC}             ;; return
    515          
    516          
    517          /*!----------------------------------------------------------------------------------------------------------------------
    518          @fn void DebugRunActiveState(void)
    519          
    520          @brief Selects and runs one iteration of the current state in the state machine.
    521          
    522          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    523          may take 1ms / n to execute.
    524          
    525          Requires:
    526          - State machine function pointer points at current state
    527          
    528          Promises:
    529          - Calls the function to pointed by the state machine function pointer
    530          */

   \                                 In section .text, align 2, keep-with-next
    531          void DebugRunActiveState(void)
    532          {
   \                     DebugRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    533            Debug_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable18_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    534          
    535          } /* end DebugRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    536          
    537          
    538          /*!----------------------------------------------------------------------------------------------------------------------
    539          @fn void DebugRxCallback(void)
    540          
    541          @brief Callback function used when character received.
    542          
    543          Requires:
    544          - None
    545          
    546          Promises:
    547          @param Debug_pu8RxBufferNextChar is advanced safely
    548          
    549          */

   \                                 In section .text, align 4, keep-with-next
    550          void DebugRxCallback(void)
    551          {
    552            /* Safely advance the NextChar pointer */
    553            Debug_pu8RxBufferNextChar++;
   \                     DebugRxCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable18_17
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable18_17
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    554            if(Debug_pu8RxBufferNextChar == &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_17
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable18_21
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??DebugRxCallback_0
    555            {
    556              Debug_pu8RxBufferNextChar = &Debug_au8RxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable18_15
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable18_17
   \   00000024   0x6008             STR      R0,[R1, #+0]
    557            }
    558            
    559          } /* end DebugRxCallback() */
   \                     ??DebugRxCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    560          
    561          
    562          /*------------------------------------------------------------------------------------------------------------------*/
    563          /*! @privatesection */                                                                                            
    564          /*--------------------------------------------------------------------------------------------------------------------*/
    565          
    566          
    567          /*!----------------------------------------------------------------------------------------------------------------------
    568          @fn inline static void AdvanceTokenCounter(void)
    569          
    570          @brief Safely increments Debug_u8TokenCounter.
    571          
    572          The Debug task keeps track of the messages it queues so it can clear them from the
    573          messaging status array.  
    574          
    575          Requires:
    576          - Do not call from ISR
    577          
    578          Promises:
    579          - Debug_u8TokenCounter is incremeted or wrapped if it at end
    580          */

   \                                 In section .text, align 2, keep-with-next
    581          inline static void AdvanceTokenCounter(void)
    582          {
    583            Debug_u8TokenCounter++;
   \                     AdvanceTokenCounter: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable18_22
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable18_22
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
    584            if(Debug_u8TokenCounter == DEBUG_TOKEN_ARRAY_SIZE)
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable18_22
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD103             BNE.N    ??AdvanceTokenCounter_0
    585            {
    586              Debug_u8TokenCounter = 0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable18_22
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
    587            }
    588            
    589          } /* end AdvanceTokenCounter() */
   \                     ??AdvanceTokenCounter_0: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    590          
    591          
    592          /*!----------------------------------------------------------------------------------------------------------------------
    593          @fn static void DebugCommandPrepareList(void)
    594          
    595          @brief Queues the entire list of debug commands available in the system so 
    596          they will be sent out the debug UART for the user to view.
    597          
    598          
    599          Requires:
    600          - Message Sender application is running
    601          
    602          Promises:
    603          - Command numbers and names of all installed commands are queued to messagesender.
    604          
    605          */

   \                                 In section .text, align 2, keep-with-next
    606          static void DebugCommandPrepareList(void)
    607          {
   \                     DebugCommandPrepareList: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    608            u8 au8ListHeading[] = "\n\n\rAvailable commands:\n\r";
   \   00000004   0xA80A             ADD      R0,SP,#+40
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_23
   \   0000000A   0x2219             MOVS     R2,#+25
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    609            u8 au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + DEBUG_CMD_POSTFIX_LENGTH];
    610            
    611            /* Write static characters to command list line */
    612            au8CommandLine[2] = ':';
   \   00000010   0x203A             MOVS     R0,#+58
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    613            au8CommandLine[3] = ' ';
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    614            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH] = '\n';
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0xF88D 0x0024      STRB     R0,[SP, #+36]
    615            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 1] = '\r';
   \   00000022   0x200D             MOVS     R0,#+13
   \   00000024   0xF88D 0x0025      STRB     R0,[SP, #+37]
    616            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 2] = '\0';
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0026      STRB     R0,[SP, #+38]
    617          
    618            /* Prepare a nicely formatted list of commands */
    619            DebugPrintf(au8ListHeading);
   \   0000002E   0xA80A             ADD      R0,SP,#+40
   \   00000030   0x.... 0x....      BL       DebugPrintf
    620            
    621            /* Loop through the array of commands parsing out the command number
    622            and printing it along with the command name. */  
    623            for(u8 i = 0; i < DEBUG_COMMANDS; i++)
   \   00000034   0x2400             MOVS     R4,#+0
   \                     ??DebugCommandPrepareList_0: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C08             CMP      R4,#+8
   \   0000003A   0xDA2C             BGE.N    ??DebugCommandPrepareList_1
    624            {
    625              /* Get the command number in ASCII */
    626              if(i >= 10)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C0A             CMP      R4,#+10
   \   00000040   0xDB07             BLT.N    ??DebugCommandPrepareList_2
    627              {
    628                au8CommandLine[0] = (i / 10) + NUMBER_ASCII_TO_DEC;
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000004A   0x3030             ADDS     R0,R0,#+48
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000050   0xE002             B.N      ??DebugCommandPrepareList_3
    629              }
    630              else
    631              {
    632                au8CommandLine[0] = NUMBER_ASCII_TO_DEC;
   \                     ??DebugCommandPrepareList_2: (+1)
   \   00000052   0x2030             MOVS     R0,#+48
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    633              }
    634              
    635              au8CommandLine[1] = (i % 10) + NUMBER_ASCII_TO_DEC;
   \                     ??DebugCommandPrepareList_3: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   00000060   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   00000064   0x3030             ADDS     R0,R0,#+48
   \   00000066   0xF88D 0x0001      STRB     R0,[SP, #+1]
    636              
    637              /* Read the command name */
    638              for(u8 j = 0; j < DEBUG_CMD_NAME_LENGTH; j++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??DebugCommandPrepareList_4: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xDA0C             BGE.N    ??DebugCommandPrepareList_5
    639              {
    640                au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + j] = Debug_au8Commands[i].pu8CommandName[j];
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable18_24
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0xF851 0x1034      LDR      R1,[R1, R4, LSL #+3]
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x5C41             LDRB     R1,[R0, R1]
   \   00000080   0xAA00             ADD      R2,SP,#+0
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x1882             ADDS     R2,R0,R2
   \   00000086   0x7111             STRB     R1,[R2, #+4]
    641              }
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xE7EF             B.N      ??DebugCommandPrepareList_4
    642              
    643              /* Queue the command name to the UART */
    644              DebugPrintf(au8CommandLine);
   \                     ??DebugCommandPrepareList_5: (+1)
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       DebugPrintf
    645            }
   \   00000092   0x1C64             ADDS     R4,R4,#+1
   \   00000094   0xE7CF             B.N      ??DebugCommandPrepareList_0
    646          
    647            DebugLineFeed();
   \                     ??DebugCommandPrepareList_1: (+1)
   \   00000096   0x.... 0x....      BL       DebugLineFeed
    648            
    649          } /* end DebugCommandPrepareList() */
   \   0000009A   0xB012             ADD      SP,SP,#+72
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    650          
    651          
    652          /*!----------------------------------------------------------------------------------------------------------------------
    653          @fn static void DebugCommandDummy(void)
    654          
    655          @brief A command place-holder.
    656          
    657          Use this function when adding new commands that do not exist yet.  This is 
    658          handy if you are out of space in the command list and might as well add a 
    659          group of new commands instead of just one.  Or perhaps you just need a
    660          temporary place holder.
    661          
    662          
    663          Requires:
    664          - NONE
    665          
    666          Promises:
    667          - A string is printed to tell the user they are using a command 
    668          that does not exist.
    669          
    670          */

   \                                 In section .text, align 2, keep-with-next
    671          static void DebugCommandDummy(void)
    672          {
   \                     DebugCommandDummy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    673            u8 au8DummyCommand[] = "\n\rDummy!\n\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_25
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    674            
    675            DebugPrintf(au8DummyCommand);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    676            
    677          } /* end DebugCommandDummy() */
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return
    678          
    679          
    680          #ifdef EIE_ASCII
    681          /*!----------------------------------------------------------------------------------------------------------------------
    682          @fn static void DebugCommandLedTestToggle(void)
    683          
    684          @brief Toggles and reports the active state of the LED test.
    685          
    686          This implementation is specific to the target hardware.
    687          
    688          Requires:
    689          - NONE
    690          
    691          Promises:
    692          @param G_u32DebugFlags flag _DEBUG_LED_TEST_ENABLE is toggled
    693          
    694          */

   \                                 In section .text, align 2, keep-with-next
    695          static void DebugCommandLedTestToggle(void)
    696          {
   \                     DebugCommandLedTestToggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    697            u8 au8LedTestMessage[] = "\n\rLed Test ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_26
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    698            
    699            /* Print message and toggle the flag */
    700            DebugPrintf(au8LedTestMessage);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    701            if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD50C             BPL.N    ??DebugCommandLedTestToggle_0
    702            {
    703              G_u32DebugFlags &= ~_DEBUG_LED_TEST_ENABLE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable18_7
   \   00000030   0x6008             STR      R0,[R1, #+0]
    704              DebugPrintf(G_au8UtilMessageOFF);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable18_27
   \   00000036   0x.... 0x....      BL       DebugPrintf
   \   0000003A   0xE023             B.N      ??DebugCommandLedTestToggle_1
    705            }
    706            else
    707            {
    708              G_u32DebugFlags |= _DEBUG_LED_TEST_ENABLE;
   \                     ??DebugCommandLedTestToggle_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable18_7
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable18_7
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    709              DebugPrintf(G_au8UtilMessageON);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable18_28
   \   00000050   0x.... 0x....      BL       DebugPrintf
    710              
    711              LedOn(WHITE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       LedOn
    712              LedOn(PURPLE);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       LedOn
    713              LedOn(BLUE);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       LedOn
    714              LedOn(CYAN);
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       LedOn
    715              LedOn(GREEN);
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0x.... 0x....      BL       LedOn
    716              LedOn(YELLOW);
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x.... 0x....      BL       LedOn
    717              LedOn(ORANGE);
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0x.... 0x....      BL       LedOn
    718              LedOn(RED);
   \   0000007E   0x2007             MOVS     R0,#+7
   \   00000080   0x.... 0x....      BL       LedOn
    719            }
    720            
    721          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugCommandLedTestToggle_1: (+1)
   \   00000084   0xBD1F             POP      {R0-R4,PC}       ;; return
    722          
    723          
    724          /*!----------------------------------------------------------------------------------------------------------------------
    725          @fn static void DebugLedTestCharacter(u8 u8Char_)
    726          
    727          @brief Checks the character and toggles associated LED if applicable.
    728          
    729          Only responds to UPPER CASE characters.
    730          This implementation is specific to the target hardware.
    731          
    732          For EIE_ASCII: W, P, B, C, G, Y, O, R
    733          
    734          Requires:
    735          @param u8Char_ is the character to check
    736          
    737          Promises:
    738          - If u8Char_ is a valid toggling character, the corresponding LED will be toggled.
    739          
    740          */

   \                                 In section .text, align 2, keep-with-next
    741          static void DebugLedTestCharacter(u8 u8Char_)
    742          {
   \                     DebugLedTestCharacter: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    743            LedNameType eLed;
    744            bool bValidLed = TRUE;
   \   00000004   0x2601             MOVS     R6,#+1
    745            
    746            /* Check the char to see if an LED should be toggled */  
    747            switch (u8Char_)
   \   00000006   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x2842             CMP      R0,#+66
   \   0000000C   0xD014             BEQ.N    ??DebugLedTestCharacter_0
   \   0000000E   0x2843             CMP      R0,#+67
   \   00000010   0xD015             BEQ.N    ??DebugLedTestCharacter_1
   \   00000012   0x2847             CMP      R0,#+71
   \   00000014   0xD016             BEQ.N    ??DebugLedTestCharacter_2
   \   00000016   0x284F             CMP      R0,#+79
   \   00000018   0xD01A             BEQ.N    ??DebugLedTestCharacter_3
   \   0000001A   0x2850             CMP      R0,#+80
   \   0000001C   0xD009             BEQ.N    ??DebugLedTestCharacter_4
   \   0000001E   0x2852             CMP      R0,#+82
   \   00000020   0xD019             BEQ.N    ??DebugLedTestCharacter_5
   \   00000022   0x2857             CMP      R0,#+87
   \   00000024   0xD002             BEQ.N    ??DebugLedTestCharacter_6
   \   00000026   0x2859             CMP      R0,#+89
   \   00000028   0xD00F             BEQ.N    ??DebugLedTestCharacter_7
   \   0000002A   0xE017             B.N      ??DebugLedTestCharacter_8
    748            {
    749              case 'W':
    750              {
    751                eLed = WHITE;
   \                     ??DebugLedTestCharacter_6: (+1)
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x0005             MOVS     R5,R0
    752                break;
   \   00000030   0xE016             B.N      ??DebugLedTestCharacter_9
    753              }  
    754          
    755              case 'P':
    756              {
    757                eLed = PURPLE;
   \                     ??DebugLedTestCharacter_4: (+1)
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x0005             MOVS     R5,R0
    758                break;
   \   00000036   0xE013             B.N      ??DebugLedTestCharacter_9
    759              }  
    760          
    761              case 'B':
    762              {
    763                eLed = BLUE;
   \                     ??DebugLedTestCharacter_0: (+1)
   \   00000038   0x2002             MOVS     R0,#+2
   \   0000003A   0x0005             MOVS     R5,R0
    764                break;
   \   0000003C   0xE010             B.N      ??DebugLedTestCharacter_9
    765              }  
    766          
    767              case 'C':
    768              {
    769                eLed = CYAN;
   \                     ??DebugLedTestCharacter_1: (+1)
   \   0000003E   0x2003             MOVS     R0,#+3
   \   00000040   0x0005             MOVS     R5,R0
    770                break;
   \   00000042   0xE00D             B.N      ??DebugLedTestCharacter_9
    771              }  
    772          
    773              case 'G':
    774              {
    775                eLed = GREEN;
   \                     ??DebugLedTestCharacter_2: (+1)
   \   00000044   0x2004             MOVS     R0,#+4
   \   00000046   0x0005             MOVS     R5,R0
    776                break;
   \   00000048   0xE00A             B.N      ??DebugLedTestCharacter_9
    777              }  
    778          
    779              case 'Y':
    780              {
    781                eLed = YELLOW;
   \                     ??DebugLedTestCharacter_7: (+1)
   \   0000004A   0x2005             MOVS     R0,#+5
   \   0000004C   0x0005             MOVS     R5,R0
    782                break;
   \   0000004E   0xE007             B.N      ??DebugLedTestCharacter_9
    783              }  
    784          
    785              case 'O':
    786              {
    787                eLed = ORANGE;
   \                     ??DebugLedTestCharacter_3: (+1)
   \   00000050   0x2006             MOVS     R0,#+6
   \   00000052   0x0005             MOVS     R5,R0
    788                break;
   \   00000054   0xE004             B.N      ??DebugLedTestCharacter_9
    789              }  
    790          
    791              case 'R':
    792              {
    793                eLed = RED;
   \                     ??DebugLedTestCharacter_5: (+1)
   \   00000056   0x2007             MOVS     R0,#+7
   \   00000058   0x0005             MOVS     R5,R0
    794                break;
   \   0000005A   0xE001             B.N      ??DebugLedTestCharacter_9
    795              }  
    796              
    797            default:
    798              {
    799                bValidLed = FALSE;
   \                     ??DebugLedTestCharacter_8: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x0006             MOVS     R6,R0
    800                break;
    801              }
    802            } /* end switch */
    803            
    804            if(bValidLed)
   \                     ??DebugLedTestCharacter_9: (+1)
   \   00000060   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000062   0x2E00             CMP      R6,#+0
   \   00000064   0xD003             BEQ.N    ??DebugLedTestCharacter_10
    805            {
    806              LedToggle(eLed);
   \   00000066   0x0028             MOVS     R0,R5
   \   00000068   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006A   0x.... 0x....      BL       LedToggle
    807            }
    808              
    809          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugLedTestCharacter_10: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    810          #endif /* EIE_ASCII */
    811          
    812          
    813          #ifdef EIE_DOTMATRIX
    814          /*!----------------------------------------------------------------------------------------------------------------------
    815          @fn static void DebugCommandLedTestToggle(void)
    816          
    817          @brief Toggles and reports the active state of the LED test.
    818          
    819          This implementation is specific to the target hardware.
    820          
    821          Requires:
    822          - NONE
    823          
    824          Promises:
    825          @param G_u32DebugFlags flag _DEBUG_LED_TEST_ENABLE is toggled
    826          
    827          */
    828          static void DebugCommandLedTestToggle(void)
    829          {
    830            u8 au8LedTestMessage[] = "\n\rLed Test ";
    831            
    832            /* Print message and toggle the flag */
    833            DebugPrintf(au8LedTestMessage);
    834            if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
    835            {
    836              G_u32DebugFlags &= ~_DEBUG_LED_TEST_ENABLE;
    837              DebugPrintf(G_au8UtilMessageOFF);
    838            }
    839            else
    840            {
    841              G_u32DebugFlags |= _DEBUG_LED_TEST_ENABLE;
    842              DebugPrintf(G_au8UtilMessageON);
    843              
    844              LedOn(RED0);
    845              LedOn(RED1);
    846              LedOn(RED2);
    847              LedOn(RED3);
    848              LedOn(GREEN0);
    849              LedOn(GREEN1);
    850              LedOn(GREEN2);
    851              LedOn(GREEN3);
    852              LedOn(BLUE0);
    853              LedOn(BLUE1);
    854              LedOn(BLUE2);
    855              LedOn(BLUE3);
    856            }
    857            
    858          } /* end DebugCommandLedTestToggle() */
    859          
    860          
    861          /*!----------------------------------------------------------------------------------------------------------------------
    862          @fn static void DebugLedTestCharacter(u8 u8Char_)
    863          
    864          @brief Checks the character and toggles associated LED if applicable.
    865          
    866          Only responds to UPPER CASE characters.
    867          This implementation is specific to the target hardware.
    868          
    869          For EIE_DOTMATRIX: R, G, B
    870          
    871          Requires:
    872          @param u8Char_ is the character to check
    873          
    874          Promises:
    875          - If u8Char_ is a valid toggling character, the corresponding LEDs will be toggled.
    876          
    877          */
    878          static void DebugLedTestCharacter(u8 u8Char_)
    879          {
    880            /* Check the char to see if an LED group should be toggled */  
    881            if(u8Char_ == 'R')
    882            {
    883              LedToggle(RED0);
    884              LedToggle(RED1);
    885              LedToggle(RED2);
    886              LedToggle(RED3);
    887            }  
    888            
    889            if(u8Char_ == 'G')
    890            {
    891              LedToggle(GREEN0);
    892              LedToggle(GREEN1);
    893              LedToggle(GREEN2);
    894              LedToggle(GREEN3);
    895            }  
    896          
    897            if(u8Char_ == 'B')
    898            {
    899              LedToggle(BLUE0);
    900              LedToggle(BLUE1);
    901              LedToggle(BLUE2);
    902              LedToggle(BLUE3);
    903            }  
    904          
    905          } /* end DebugCommandLedTestToggle() */
    906          #endif /* EIE_DOTMATRIX */
    907          
    908          
    909          /*!----------------------------------------------------------------------------------------------------------------------
    910          @fn static void DebugCommandSysTimeToggle(void)
    911          
    912          @brief Toggles the active state of the 1ms violation warning.
    913          
    914          Requires:
    915          - NONE
    916          
    917          Promises:
    918          @param G_u32DebugFlags flag _DEBUG_TIME_WARNING_ENABLE is toggled
    919          
    920          */

   \                                 In section .text, align 2, keep-with-next
    921          static void DebugCommandSysTimeToggle(void)
    922          {
   \                     DebugCommandSysTimeToggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    923            u8 au8SysTimeTestMessage[] = "\n\rSystem time violation reporting ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable18_29
   \   0000000A   0x2223             MOVS     R2,#+35
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    924            
    925            /* Print message and toggle the flag */
    926            DebugPrintf(au8SysTimeTestMessage);
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       DebugPrintf
    927            if(G_u32DebugFlags & _DEBUG_TIME_WARNING_ENABLE)
   \   00000016   0x....             LDR.N    R0,??DataTable18_7
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD50A             BPL.N    ??DebugCommandSysTimeToggle_0
    928            {
    929              G_u32DebugFlags &= ~_DEBUG_TIME_WARNING_ENABLE;
   \   0000001E   0x....             LDR.N    R0,??DataTable18_7
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable18_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    930              DebugPrintf(G_au8UtilMessageOFF);
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable18_27
   \   0000002E   0x.... 0x....      BL       DebugPrintf
   \   00000032   0xE009             B.N      ??DebugCommandSysTimeToggle_1
    931            }
    932            else
    933            {
    934              G_u32DebugFlags |= _DEBUG_TIME_WARNING_ENABLE;
   \                     ??DebugCommandSysTimeToggle_0: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable18_7
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003C   0x....             LDR.N    R1,??DataTable18_7
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    935              DebugPrintf(G_au8UtilMessageON);
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable18_28
   \   00000044   0x.... 0x....      BL       DebugPrintf
    936            }
    937            
    938          } /* end DebugCommandSysTimeToggle() */
   \                     ??DebugCommandSysTimeToggle_1: (+1)
   \   00000048   0xB009             ADD      SP,SP,#+36
   \   0000004A   0xBD00             POP      {PC}             ;; return
    939          
    940          /* EIE_DOTMATRIX only tests */
    941          #ifdef EIE_DOTMATRIX 
    942          /*!----------------------------------------------------------------------------------------------------------------------
    943          @fn DebugCommandCaptouchValuesToggle
    944          
    945          @brief Toggles printing the current Captouch horizontal and vertical values.
    946          
    947          Requires:
    948          - NONE
    949          
    950          Promises:
    951          @param G_u32DebugFlags flag _DEBUG_CAPTOUCH_VALUES_ENABLE is toggled
    952          
    953          */
    954          static void DebugCommandCaptouchValuesToggle(void)
    955          {
    956            u8 au8CaptouchDisplayMessage[] = "\n\rDisplay Captouch values ";
    957            u8 au8CaptouchOnMessage[] = "No values displayed if Captouch is OFF\n\r";
    958            
    959            /* Print message and toggle the flag */
    960            DebugPrintf(au8CaptouchDisplayMessage);
    961            if(G_u32DebugFlags & _DEBUG_CAPTOUCH_VALUES_ENABLE)
    962            {
    963              G_u32DebugFlags &= ~_DEBUG_CAPTOUCH_VALUES_ENABLE;
    964              DebugPrintf(G_au8UtilMessageOFF);
    965            }
    966            else
    967            {
    968              G_u32DebugFlags |= _DEBUG_CAPTOUCH_VALUES_ENABLE;
    969              DebugPrintf(G_au8UtilMessageON);
    970              DebugPrintf(au8CaptouchOnMessage);
    971            }
    972            
    973          } /* end DebugCommandCaptouchValuesToggle() */
    974          #endif /* EIE_DOTMATRIX only tests */
    975          
    976          
    977          /***********************************************************************************************************************
    978          State Machine Function Declarations
    979          ***********************************************************************************************************************/
    980          
    981          /***********************************************************************************************************************
    982          State Machine Function Declarations
    983          
    984          The debugger state machine monitors the receive buffer to grab characters as they come in
    985          from the interrupt-driven receiver and store them in the debug command buffer.  Nothing happens 
    986          until the user sends a CR indicating they think they've entered a valid command.  The command is
    987          checked and reacted to accordingly.
    988          ***********************************************************************************************************************/
    989          
    990          /*!--------------------------------------------------------------------------------------------------------------------
    991          @fn void DebugSM_Idle(void)               
    992          
    993          @brief Waits for a byte to appear in the Rx buffer.  
    994          
    995          The BufferParser is always moved through all new characters placing them into 
    996          the command buffer until it hits a CR or there are no new characters to read. 
    997          If there is no CR in this iteration, nothing else occurs.
    998          
    999          Backspace: Echo the backspace and a space character to clear the character on 
   1000          screen; move Debug_pu8BufferCurrentChar back.
   1001          
   1002          CR: Advance states to process the command.
   1003          
   1004          Any other character: Echo it to the UART Tx and place a copy in Debug_au8CommandBuffer.
   1005          
   1006          */

   \                                 In section .text, align 4, keep-with-next
   1007          void DebugSM_Idle(void)               
   1008          {
   \                     DebugSM_Idle: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1009            bool bCommandFound = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
   1010            u8 u8CurrentByte;
   1011            u8 u8Counter;
   1012            static u8 au8BackspaceSequence[] = {ASCII_BACKSPACE, ' ', ASCII_BACKSPACE};
   1013            static u8 au8CommandOverflow[] = "\r\n*** Command too long ***\r\n\n";
   1014            
   1015            /* Parse any new characters that have come in until no more chars or a command is found */
   1016            while( (Debug_pu8RxBufferParser != Debug_pu8RxBufferNextChar) && (bCommandFound == FALSE) )
   \                     ??DebugSM_Idle_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable18_16
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable18_17
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xF000 0x80AD      BEQ.W    ??DebugSM_Idle_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xF040 0x80A9      BNE.W    ??DebugSM_Idle_1
   1017            {
   1018              /* Grab a copy of the current byte */
   1019              u8CurrentByte = *Debug_pu8RxBufferParser;
   \   0000001A   0x....             LDR.N    R0,??DataTable18_16
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0005             MOVS     R5,R0
   1020                  
   1021              /* Process the character */
   1022              switch (u8CurrentByte)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD002             BEQ.N    ??DebugSM_Idle_2
   \   0000002A   0x280D             CMP      R0,#+13
   \   0000002C   0xD03A             BEQ.N    ??DebugSM_Idle_3
   \   0000002E   0xE043             B.N      ??DebugSM_Idle_4
   1023              {
   1024                /* Backspace: update command buffer pointer and send sequence to delete the char on the terminal */
   1025                case(ASCII_BACKSPACE): 
   1026                {
   1027                  /* Process for scanf as long as we are not in Passthrough mode */
   1028                  if( G_u32DebugFlags & _DEBUG_PASSTHROUGH )
   \                     ??DebugSM_Idle_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable18_7
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x0740             LSLS     R0,R0,#+29
   \   00000036   0xD50D             BPL.N    ??DebugSM_Idle_5
   1029                  {        
   1030                    if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \   00000038   0x....             LDR.N    R0,??DataTable18_5
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2880             CMP      R0,#+128
   \   0000003E   0xDA26             BGE.N    ??DebugSM_Idle_6
   1031                    {
   1032                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   00000040   0x....             LDR.N    R0,??DataTable18_6
   \   00000042   0x....             LDR.N    R1,??DataTable18_5
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x540D             STRB     R5,[R1, R0]
   1033                      G_u8DebugScanfCharCount++;
   \   00000048   0x....             LDR.N    R0,??DataTable18_5
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable18_5
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0xE01C             B.N      ??DebugSM_Idle_6
   1034                    }
   1035                  }
   1036                  else
   1037                  {
   1038                    /* Process for scanf */
   1039                    if(G_u8DebugScanfCharCount != 0)
   \                     ??DebugSM_Idle_5: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable18_5
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD009             BEQ.N    ??DebugSM_Idle_7
   1040                    {
   1041                      G_u8DebugScanfCharCount--;
   \   0000005C   0x....             LDR.N    R0,??DataTable18_5
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable18_5
   \   00000064   0x7008             STRB     R0,[R1, #+0]
   1042                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = '\0';
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable18_6
   \   0000006A   0x....             LDR.N    R2,??DataTable18_5
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x5450             STRB     R0,[R2, R1]
   1043                    }
   1044          
   1045                    /* Process for command */
   1046                    if(Debug_pu8CmdBufferNextChar != &Debug_au8CommandBuffer[0])
   \                     ??DebugSM_Idle_7: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable18_19
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x....             LDR.N    R1,??DataTable18_18
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD009             BEQ.N    ??DebugSM_Idle_6
   1047                    {
   1048                      Debug_pu8CmdBufferNextChar--;
   \   0000007A   0x....             LDR.N    R0,??DataTable18_19
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable18_19
   \   00000082   0x6008             STR      R0,[R1, #+0]
   1049                      Debug_u16CommandSize--;
   \   00000084   0x....             LDR.N    R0,??DataTable18_30
   \   00000086   0x8800             LDRH     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x....             LDR.N    R1,??DataTable18_30
   \   0000008C   0x8008             STRH     R0,[R1, #+0]
   1050                    }
   1051                  }
   1052                          
   1053                  /* Send the Backspace sequence to clear the character on the terminal */
   1054                  Debug_au32MsgTokens[Debug_u8TokenCounter] = DebugPrintf(au8BackspaceSequence);
   \                     ??DebugSM_Idle_6: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable18_31
   \   00000090   0x.... 0x....      BL       DebugPrintf
   \   00000094   0x....             LDR.N    R1,??DataTable18_32
   \   00000096   0x....             LDR.N    R2,??DataTable18_22
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   1055                  AdvanceTokenCounter();
   \   0000009E   0x.... 0x....      BL       AdvanceTokenCounter
   1056                  break;
   \   000000A2   0xE04C             B.N      ??DebugSM_Idle_8
   1057                } /* end case(ASCII_BACKSPACE) */
   1058          
   1059                /* Carriage return: change states to process new command and fall through to echo character */
   1060                case(ASCII_CARRIAGE_RETURN): 
   1061                {
   1062                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \                     ??DebugSM_Idle_3: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable18_7
   \   000000A6   0x7800             LDRB     R0,[R0, #+0]
   \   000000A8   0x0740             LSLS     R0,R0,#+29
   \   000000AA   0xD405             BMI.N    ??DebugSM_Idle_4
   1063                  {
   1064                    bCommandFound = TRUE;
   \   000000AC   0x2001             MOVS     R0,#+1
   \   000000AE   0x0004             MOVS     R4,R0
   1065                    Debug_pfnStateMachine = DebugSM_CheckCmd;
   \   000000B0   0x.... 0x....      ADR.W    R0,DebugSM_CheckCmd
   \   000000B4   0x....             LDR.N    R1,??DataTable18_4
   \   000000B6   0x6008             STR      R0,[R1, #+0]
   1066                  }
   1067                  
   1068                  /* Fall through to default */        
   1069                } /* end case(ASCII_CARRIAGE_RETURN) */
   1070                  
   1071                /* Add to command buffer and echo */
   1072                default: 
   1073                {
   1074                  /* Process for scanf */
   1075                  if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \                     ??DebugSM_Idle_4: (+1)
   \   000000B8   0x....             LDR.N    R0,??DataTable18_5
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2880             CMP      R0,#+128
   \   000000BE   0xDA08             BGE.N    ??DebugSM_Idle_9
   1076                  {
   1077                    G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   000000C0   0x....             LDR.N    R0,??DataTable18_6
   \   000000C2   0x....             LDR.N    R1,??DataTable18_5
   \   000000C4   0x7809             LDRB     R1,[R1, #+0]
   \   000000C6   0x540D             STRB     R5,[R1, R0]
   1078                    G_u8DebugScanfCharCount++;
   \   000000C8   0x....             LDR.N    R0,??DataTable18_5
   \   000000CA   0x7800             LDRB     R0,[R0, #+0]
   \   000000CC   0x1C40             ADDS     R0,R0,#+1
   \   000000CE   0x....             LDR.N    R1,??DataTable18_5
   \   000000D0   0x7008             STRB     R0,[R1, #+0]
   1079                  }
   1080                  
   1081                  /* Echo the character back to the terminal */
   1082                  Debug_au32MsgTokens[Debug_u8TokenCounter] = UartWriteByte(Debug_Uart, u8CurrentByte);
   \                     ??DebugSM_Idle_9: (+1)
   \   000000D2   0x0029             MOVS     R1,R5
   \   000000D4   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000D6   0x....             LDR.N    R0,??DataTable18
   \   000000D8   0x6800             LDR      R0,[R0, #+0]
   \   000000DA   0x.... 0x....      BL       UartWriteByte
   \   000000DE   0x....             LDR.N    R1,??DataTable18_32
   \   000000E0   0x....             LDR.N    R2,??DataTable18_22
   \   000000E2   0x7812             LDRB     R2,[R2, #+0]
   \   000000E4   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   1083                  AdvanceTokenCounter();
   \   000000E8   0x.... 0x....      BL       AdvanceTokenCounter
   1084                  
   1085                  /* As long as Passthrough mode is not active, then update the command buffer */
   1086                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \   000000EC   0x....             LDR.N    R0,??DataTable18_7
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x0740             LSLS     R0,R0,#+29
   \   000000F2   0xD424             BMI.N    ??DebugSM_Idle_10
   1087                  {
   1088                    *Debug_pu8CmdBufferNextChar = u8CurrentByte;
   \   000000F4   0x....             LDR.N    R0,??DataTable18_19
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x7005             STRB     R5,[R0, #+0]
   1089                    Debug_pu8CmdBufferNextChar++;
   \   000000FA   0x....             LDR.N    R0,??DataTable18_19
   \   000000FC   0x6800             LDR      R0,[R0, #+0]
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0x....             LDR.N    R1,??DataTable18_19
   \   00000102   0x6008             STR      R0,[R1, #+0]
   1090                    Debug_u16CommandSize++;
   \   00000104   0x....             LDR.N    R0,??DataTable18_30
   \   00000106   0x8800             LDRH     R0,[R0, #+0]
   \   00000108   0x1C40             ADDS     R0,R0,#+1
   \   0000010A   0x....             LDR.N    R1,??DataTable18_30
   \   0000010C   0x8008             STRH     R0,[R1, #+0]
   1091          
   1092                    /* If the command buffer is now full but the last character was not ASCII_CARRIAGE_RETURN, throw out the whole
   1093                    buffer and report an error message */
   1094                    if( (Debug_pu8CmdBufferNextChar >= &Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]) &&
   1095                        (u8CurrentByte != ASCII_CARRIAGE_RETURN) )
   \   0000010E   0x....             LDR.N    R0,??DataTable18_19
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x....             LDR.N    R1,??DataTable18_33
   \   00000114   0x4288             CMP      R0,R1
   \   00000116   0xD312             BCC.N    ??DebugSM_Idle_10
   \   00000118   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000011A   0x2D0D             CMP      R5,#+13
   \   0000011C   0xD00F             BEQ.N    ??DebugSM_Idle_10
   1096                    {
   1097                      Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   0000011E   0x....             LDR.N    R0,??DataTable18_18
   \   00000120   0x....             LDR.N    R1,??DataTable18_19
   \   00000122   0x6008             STR      R0,[R1, #+0]
   1098                      Debug_u16CommandSize = 0;
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x....             LDR.N    R1,??DataTable18_30
   \   00000128   0x8008             STRH     R0,[R1, #+0]
   1099          
   1100                      Debug_au32MsgTokens[Debug_u8TokenCounter] = DebugPrintf(au8CommandOverflow);
   \   0000012A   0x....             LDR.N    R0,??DataTable18_34
   \   0000012C   0x.... 0x....      BL       DebugPrintf
   \   00000130   0x....             LDR.N    R1,??DataTable18_32
   \   00000132   0x....             LDR.N    R2,??DataTable18_22
   \   00000134   0x7812             LDRB     R2,[R2, #+0]
   \   00000136   0xF841 0x0022      STR      R0,[R1, R2, LSL #+2]
   1101                      AdvanceTokenCounter();
   \   0000013A   0x.... 0x....      BL       AdvanceTokenCounter
   1102                    }
   1103                  }
   1104                  break;
   1105                } /* end default */
   1106          
   1107              } /* end switch (u8CurrentByte) */
   1108          
   1109              /* If the LED test is active, toggle LEDs based on characters */
   1110              if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \                     ??DebugSM_Idle_10: (+1)
   \                     ??DebugSM_Idle_8: (+1)
   \   0000013E   0x....             LDR.N    R0,??DataTable18_7
   \   00000140   0x7800             LDRB     R0,[R0, #+0]
   \   00000142   0x07C0             LSLS     R0,R0,#+31
   \   00000144   0xD503             BPL.N    ??DebugSM_Idle_11
   1111              {
   1112                DebugLedTestCharacter(u8CurrentByte);
   \   00000146   0x0028             MOVS     R0,R5
   \   00000148   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014A   0x.... 0x....      BL       DebugLedTestCharacter
   1113              }
   1114              
   1115              /* In all cases, advance the RxBufferParser pointer safely */
   1116              Debug_pu8RxBufferParser++;
   \                     ??DebugSM_Idle_11: (+1)
   \   0000014E   0x....             LDR.N    R0,??DataTable18_16
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x1C40             ADDS     R0,R0,#+1
   \   00000154   0x....             LDR.N    R1,??DataTable18_16
   \   00000156   0x6008             STR      R0,[R1, #+0]
   1117              if(Debug_pu8RxBufferParser >= &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   00000158   0x....             LDR.N    R0,??DataTable18_16
   \   0000015A   0x6800             LDR      R0,[R0, #+0]
   \   0000015C   0x....             LDR.N    R1,??DataTable18_21
   \   0000015E   0x4288             CMP      R0,R1
   \   00000160   0xF4FF 0xAF50      BCC.W    ??DebugSM_Idle_0
   1118              {
   1119                Debug_pu8RxBufferParser = &Debug_au8RxBuffer[0];
   \   00000164   0x....             LDR.N    R0,??DataTable18_15
   \   00000166   0x....             LDR.N    R1,??DataTable18_16
   \   00000168   0x6008             STR      R0,[R1, #+0]
   \   0000016A   0xE74B             B.N      ??DebugSM_Idle_0
   1120              }
   1121              
   1122            } /* end while */
   1123            
   1124            /* Clear out any completed messages (Query automatically removes if complete ) */
   1125            u8Counter = 0;
   \                     ??DebugSM_Idle_1: (+1)
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x0006             MOVS     R6,R0
   1126            while ( (u8Counter < DEBUG_TOKEN_ARRAY_SIZE) &&
   1127                    (Debug_au32MsgTokens[u8Counter] != 0) )
   \                     ??DebugSM_Idle_12: (+1)
   \   00000170   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000172   0x2E10             CMP      R6,#+16
   \   00000174   0xDA0D             BGE.N    ??DebugSM_Idle_13
   \   00000176   0x....             LDR.N    R0,??DataTable18_32
   \   00000178   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000017A   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000017E   0x2800             CMP      R0,#+0
   \   00000180   0xD007             BEQ.N    ??DebugSM_Idle_13
   1128            {
   1129              QueryMessageStatus(Debug_au32MsgTokens[u8Counter]);
   \   00000182   0x....             LDR.N    R0,??DataTable18_32
   \   00000184   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000186   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000018A   0x.... 0x....      BL       QueryMessageStatus
   1130              u8Counter++;
   \   0000018E   0x1C76             ADDS     R6,R6,#+1
   \   00000190   0xE7EE             B.N      ??DebugSM_Idle_12
   1131            }
   1132              
   1133          } /* end DebugSM_Idle() */
   \                     ??DebugSM_Idle_13: (+1)
   \   00000192   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8BackspaceSequence:
   \   00000000   0x08 0x20          DC8 8, 32, 8, 0
   \              0x08 0x00    

   \                                 In section .data, align 4
   \                     ??au8CommandOverflow:
   \   00000000   0x0D 0x0A          DC8 "\015\012*** Command too long ***\015\012\012"
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0D 0x0A    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
   1134          
   1135          
   1136          /*!----------------------------------------------------------------------------------------------------------------------
   1137          @fn void DebugSM_CheckCmd(void)        
   1138          
   1139          @brief Checks to see if a string entered is a valid command.
   1140          
   1141          At the start of this state, the command buffer has a candidate command terminated in CR.
   1142          There is a strict rule that commands are of the form en+cxx where xx is any number
   1143          from 0 to DEBUG_COMMANDS, so parsing can be done based on that rule.  All other 
   1144          strings are invalid.  
   1145          
   1146          */

   \                                 In section .text, align 4, keep-with-next
   1147          void DebugSM_CheckCmd(void)        
   1148          {
   \                     DebugSM_CheckCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1149            static u8 au8CommandHeader[] = "en+c";
   1150            static u8 au8InvalidCommand[] = "\nInvalid command.  Use en+c##\n\n\r"; 
   1151            bool bGoodCommand = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
   1152            u8 u8Index;
   1153            s8 s8Temp;
   1154            
   1155            /* Verify that the command starts with en+c */
   1156            u8Index = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
   1157            do
   1158            {
   1159              if(Debug_au8CommandBuffer[u8Index] != au8CommandHeader[u8Index])
   \                     ??DebugSM_CheckCmd_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable18_18
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x5C28             LDRB     R0,[R5, R0]
   \   0000000E   0x....             LDR.N    R1,??DataTable18_35
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5C69             LDRB     R1,[R5, R1]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD001             BEQ.N    ??DebugSM_CheckCmd_1
   1160              {
   1161                bGoodCommand = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0004             MOVS     R4,R0
   1162              }
   1163          
   1164              u8Index++;
   \                     ??DebugSM_CheckCmd_1: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   1165            } while ( bGoodCommand && (u8Index < 4) );
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ.N    ??DebugSM_CheckCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xDBEE             BLT.N    ??DebugSM_CheckCmd_0
   1166            
   1167            /* On good header, read the command number */
   1168            if(bGoodCommand)
   \                     ??DebugSM_CheckCmd_2: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD02E             BEQ.N    ??DebugSM_CheckCmd_3
   1169            {
   1170              /* Make an assumption */
   1171              bGoodCommand = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
   1172          
   1173              /* Verify the next char is a digit */
   1174              s8Temp = Debug_au8CommandBuffer[u8Index++] - NUMBER_ASCII_TO_DEC;
   \   00000034   0x....             LDR.N    R0,??DataTable18_18
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x5628             LDRSB    R0,[R5, R0]
   \   0000003A   0x3830             SUBS     R0,R0,#+48
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   1175            
   1176              if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000040   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD423             BMI.N    ??DebugSM_CheckCmd_3
   \   00000046   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000048   0x2E0A             CMP      R6,#+10
   \   0000004A   0xDA20             BGE.N    ??DebugSM_CheckCmd_3
   1177              {
   1178                Debug_u8Command = s8Temp * 10;
   \   0000004C   0x200A             MOVS     R0,#+10
   \   0000004E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000052   0x....             LDR.N    R1,??DataTable18_36
   \   00000054   0x7008             STRB     R0,[R1, #+0]
   1179            
   1180                /* Verify the next char is a digit */
   1181                s8Temp = Debug_au8CommandBuffer[u8Index++] - NUMBER_ASCII_TO_DEC;
   \   00000056   0x....             LDR.N    R0,??DataTable18_18
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x5628             LDRSB    R0,[R5, R0]
   \   0000005C   0x3830             SUBS     R0,R0,#+48
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   1182                if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000062   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD412             BMI.N    ??DebugSM_CheckCmd_3
   \   00000068   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000006A   0x2E0A             CMP      R6,#+10
   \   0000006C   0xDA0F             BGE.N    ??DebugSM_CheckCmd_3
   1183                {
   1184                  Debug_u8Command += s8Temp;
   \   0000006E   0x....             LDR.N    R0,??DataTable18_36
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x1830             ADDS     R0,R6,R0
   \   00000074   0x....             LDR.N    R1,??DataTable18_36
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1185                  
   1186                  /* Check that the command number is within the range of commands available and the last char is CR */
   1187                  if( (Debug_u8Command < DEBUG_COMMANDS) && (Debug_au8CommandBuffer[u8Index] == ASCII_CARRIAGE_RETURN) )
   \   00000078   0x....             LDR.N    R0,??DataTable18_36
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x2808             CMP      R0,#+8
   \   0000007E   0xDA06             BGE.N    ??DebugSM_CheckCmd_3
   \   00000080   0x....             LDR.N    R0,??DataTable18_18
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x5C28             LDRB     R0,[R5, R0]
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD101             BNE.N    ??DebugSM_CheckCmd_3
   1188                  {
   1189                    bGoodCommand = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x0004             MOVS     R4,R0
   1190                  }
   1191                }
   1192              }
   1193            }
   1194                     
   1195            /* If still good command */
   1196            if( bGoodCommand )
   \                     ??DebugSM_CheckCmd_3: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD004             BEQ.N    ??DebugSM_CheckCmd_4
   1197            {
   1198              Debug_pfnStateMachine = DebugSM_ProcessCmd;
   \   00000094   0x.... 0x....      ADR.W    R0,DebugSM_ProcessCmd
   \   00000098   0x....             LDR.N    R1,??DataTable18_4
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE005             B.N      ??DebugSM_CheckCmd_5
   1199            }
   1200            /* Otherwise print an error message and return to Idle */
   1201            else
   1202            { 
   1203              DebugPrintf(au8InvalidCommand);
   \                     ??DebugSM_CheckCmd_4: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable18_37
   \   000000A0   0x.... 0x....      BL       DebugPrintf
   1204              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000A4   0x....             LDR.N    R0,??DataTable18_38
   \   000000A6   0x....             LDR.N    R1,??DataTable18_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1205            }
   1206          
   1207            /* Reset the command buffer next char pointer */
   1208            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \                     ??DebugSM_CheckCmd_5: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable18_18
   \   000000AC   0x....             LDR.N    R1,??DataTable18_19
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1209          
   1210          } /* end DebugSM_CheckCmd() */
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8CommandHeader:
   \   00000000   0x65 0x6E          DC8 "en+c"
   \              0x2B 0x63    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8InvalidCommand:
   \   00000000   0x0A 0x49          DC8 "\012Invalid command.  Use en+c##\012\012\015"
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x20    
   \              0x20 0x55    
   \              0x73 0x65    
   \              0x20 0x65    
   \              0x6E 0x2B    
   \              0x63 0x23    
   \              0x23 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1211          
   1212          
   1213          /*!----------------------------------------------------------------------------------------------------------------------
   1214          @fn void DebugSM_ProcessCmd(void)         
   1215          
   1216          @brief Carry out the debug instruction. 
   1217          
   1218          */

   \                                 In section .text, align 4, keep-with-next
   1219          void DebugSM_ProcessCmd(void)         
   1220          {
   \                     DebugSM_ProcessCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1221            /* Setup for return to Idle state */
   1222            Debug_pfnStateMachine = DebugSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable18_38
   \   00000004   0x....             LDR.N    R1,??DataTable18_4
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1223          
   1224            /* Call the command function in the function array (may change next state ) */
   1225            Debug_au8Commands[Debug_u8Command].DebugFunction();
   \   00000008   0x....             LDR.N    R0,??DataTable18_24
   \   0000000A   0x....             LDR.N    R1,??DataTable18_36
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x4780             BLX      R0
   1226            
   1227          } /* end DebugSM_ProcessCmd() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1228          
   1229          
   1230          /*!----------------------------------------------------------------------------------------------------------------------
   1231          @fn void DebugSM_Error(void)         
   1232          
   1233          @brief The Error state for the task.
   1234          
   1235          Attempt to print an error message.  However if the Debug UART has failed, then 
   1236          it obviously cannot print a message to tell you that.
   1237          
   1238          */

   \                                 In section .text, align 4, keep-with-next
   1239          void DebugSM_Error(void)         
   1240          {
   \                     DebugSM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1241            static u8 au8DebugErrorMsg[] = "\n\nDebug task error: ";
   1242            
   1243            /* Flag an error and report it (if possible) */
   1244            G_u32DebugFlags |= _DEBUG_FLAG_ERROR;
   \   00000002   0x....             LDR.N    R0,??DataTable18_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x....             LDR.N    R1,??DataTable18_7
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1245            DebugPrintf(au8DebugErrorMsg);
   \   0000000E   0x....             LDR.N    R0,??DataTable18_39
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1246            DebugPrintNumber( (u32)(Debug_u8ErrorCode) );
   \   00000014   0x....             LDR.N    R0,??DataTable18_3
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       DebugPrintNumber
   1247            DebugLineFeed();
   \   0000001C   0x.... 0x....      BL       DebugLineFeed
   1248            
   1249            /* Return to Idle state */
   1250            Debug_u16CommandSize = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable18_30
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   1251            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000026   0x....             LDR.N    R0,??DataTable18_18
   \   00000028   0x....             LDR.N    R1,??DataTable18_19
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1252            Debug_pfnStateMachine = DebugSM_Idle;
   \   0000002C   0x....             LDR.N    R0,??DataTable18_38
   \   0000002E   0x....             LDR.N    R1,??DataTable18_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1253          
   1254          } /* end DebugSM_Error() */
   \   00000032   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8DebugErrorMsg:
   \   00000000   0x0A 0x0A          DC8 "\012\012Debug task error: "
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x........         DC32     Debug_Uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x........         DC32     Debug_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x........         DC32     Debug_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x........         DC32     G_u8DebugScanfCharCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x........         DC32     G_au8DebugScanfBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x........         DC32     G_u32DebugFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x........         DC32     G_aau8AppShortNames

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_14:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_15:
   \   00000000   0x........         DC32     Debug_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_16:
   \   00000000   0x........         DC32     Debug_pu8RxBufferParser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_17:
   \   00000000   0x........         DC32     Debug_pu8RxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_18:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_19:
   \   00000000   0x........         DC32     Debug_pu8CmdBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_20:
   \   00000000   0x........         DC32     Debug_au8StartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_21:
   \   00000000   0x........         DC32     Debug_au8RxBuffer+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_22:
   \   00000000   0x........         DC32     Debug_u8TokenCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_23:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_24:
   \   00000000   0x........         DC32     Debug_au8Commands

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_25:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_26:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_27:
   \   00000000   0x........         DC32     G_au8UtilMessageOFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_28:
   \   00000000   0x........         DC32     G_au8UtilMessageON

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_29:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_30:
   \   00000000   0x........         DC32     Debug_u16CommandSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_31:
   \   00000000   0x........         DC32     ??au8BackspaceSequence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_32:
   \   00000000   0x........         DC32     Debug_au32MsgTokens

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_33:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_34:
   \   00000000   0x........         DC32     ??au8CommandOverflow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_35:
   \   00000000   0x........         DC32     ??au8CommandHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_36:
   \   00000000   0x........         DC32     Debug_u8Command

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_37:
   \   00000000   0x........         DC32     ??au8InvalidCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_38:
   \   00000000   0x........         DC32     DebugSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_39:
   \   00000000   0x........         DC32     ??au8DebugErrorMsg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x68          DC8 "Show debug command list         "
   \              0x6F 0x77    
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x6C    
   \              0x69 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x6F          DC8 "Toggle LED test                 "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x4C    
   \              0x45 0x44    
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x6F          DC8 "Toggle system timing warning    "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x20    
   \              0x74 0x69    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x77    
   \              0x61 0x72    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x44 0x75          DC8 "Dummy3                          "
   \              0x6D 0x6D    
   \              0x79 0x33    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x44 0x75          DC8 "Dummy4                          "
   \              0x6D 0x6D    
   \              0x79 0x34    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x44 0x75          DC8 "Dummy5                          "
   \              0x6D 0x6D    
   \              0x79 0x35    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x44 0x75          DC8 "Dummy6                          "
   \              0x6D 0x6D    
   \              0x79 0x36    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x44 0x75          DC8 "Dummy7                          "
   \              0x6D 0x6D    
   \              0x79 0x37    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \                     ?_8:
   \   00000000   0x0A 0x0D          DC8 10, 13

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough enabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough disabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x2A 0x2A    
   \              0x2A 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x4E 0x6F          DC8 "No failed tasks.\012\015"
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x73 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 49H, 6EH, 69H, 74H, 69H, 61H
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \   00000008   0x6C 0x69          DC8 6CH, 69H, 7AH, 61H, 74H, 69H, 6FH, 6EH
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000010   0x20 0x63          DC8 20H, 63H, 6FH, 6DH, 70H, 6CH, 65H, 74H
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \   00000018   0x65 0x2E          DC8 65H, 2EH, 20H, 54H, 79H, 70H, 65H, 20H
   \              0x20 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \   00000020   0x65 0x6E          DC8 65H, 6EH, 2BH, 63H, 30H, 30H, 20H, 66H
   \              0x2B 0x63    
   \              0x30 0x30    
   \              0x20 0x66    
   \   00000028   0x6F 0x72          DC8 6FH, 72H, 20H, 64H, 65H, 62H, 75H, 67H
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \   00000030   0x20 0x6D          DC8 20H, 6DH, 65H, 6EH, 75H, 2EH, 20H, 20H
   \              0x65 0x6E    
   \              0x75 0x2E    
   \              0x20 0x20    
   \   00000038   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000040   0x61 0x73          DC8 61H, 73H, 6BH, 73H, 3AH, 0AH, 0DH, 0
   \              0x6B 0x73    
   \              0x3A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x46 0x69          DC8 70, 105, 114, 109, 119, 97, 114, 101, 32, 118, 101, 114, 115, 105
   \              0x72 0x6D    
   \              0x77 0x61    
   \              0x72 0x65    
   \              0x20 0x76    
   \              0x65 0x72    
   \              0x73 0x69    
   \   0000000E   0x6F 0x6E          DC8 111, 110, 58, 32, 49, 46, 48, 48, 10, 10, 13, 0, 0, 0
   \              0x3A 0x20    
   \              0x31 0x2E    
   \              0x30 0x30    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015Available commands:\012\015"
   \              0x0D 0x41    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x0A 0x0D          DC8 "\012\015Dummy!\012\012\015"
   \              0x44 0x75    
   \              0x6D 0x6D    
   \              0x79 0x21    
   \              0x0A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x0A 0x0D          DC8 "\012\015Led Test "
   \              0x4C 0x65    
   \              0x64 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x0A 0x0D          DC8 "\012\015System time violation reporting "
   \              0x53 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x76 0x69    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   00000023   0x00               DC8 0
   1255          
   1256                    
   1257                       
   1258          /*--------------------------------------------------------------------------------------------------------------------*/
   1259          /* End of File                                                                                                        */
   1260          /*--------------------------------------------------------------------------------------------------------------------*/
   1261          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AdvanceTokenCounter
       8   DebugClearPassthrough
         8   -> DebugPrintf
      24   DebugCommandDummy
        24   -> DebugPrintf
      24   DebugCommandLedTestToggle
        24   -> DebugPrintf
        24   -> LedOn
      80   DebugCommandPrepareList
        80   -> DebugLineFeed
        80   -> DebugPrintf
        80   -> __aeabi_memcpy
      40   DebugCommandSysTimeToggle
        40   -> DebugPrintf
        40   -> __aeabi_memcpy
      48   DebugInitialize
        48   -> DebugPrintf
        48   -> UartRequest
        48   -> __aeabi_memcpy4
      16   DebugLedTestCharacter
        16   -> LedToggle
       8   DebugLineFeed
         8   -> UartWriteData
      40   DebugPrintNumber
        40   -> UartWriteData
        40   -> free
        40   -> malloc
      16   DebugPrintf
        16   -> UartWriteData
       8   DebugRunActiveState
         8   -- Indirect call
       0   DebugRxCallback
      16   DebugSM_CheckCmd
        16   -> DebugPrintf
       8   DebugSM_Error
         8   -> DebugLineFeed
         8   -> DebugPrintNumber
         8   -> DebugPrintf
      16   DebugSM_Idle
        16   -> AdvanceTokenCounter
        16   -> DebugLedTestCharacter
        16   -> DebugPrintf
        16   -> QueryMessageStatus
        16   -> UartWriteByte
       8   DebugSM_ProcessCmd
         8   -- Indirect call
       4   DebugScanf
       8   DebugSetPassthrough
         8   -> DebugPrintf
     112   SystemStatusReport
       112   -> DebugLineFeed
       112   -> DebugPrintf
       112   -> __aeabi_memcpy
       112   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_14
       4  ??DataTable18_15
       4  ??DataTable18_16
       4  ??DataTable18_17
       4  ??DataTable18_18
       4  ??DataTable18_19
       4  ??DataTable18_2
       4  ??DataTable18_20
       4  ??DataTable18_21
       4  ??DataTable18_22
       4  ??DataTable18_23
       4  ??DataTable18_24
       4  ??DataTable18_25
       4  ??DataTable18_26
       4  ??DataTable18_27
       4  ??DataTable18_28
       4  ??DataTable18_29
       4  ??DataTable18_3
       4  ??DataTable18_30
       4  ??DataTable18_31
       4  ??DataTable18_32
       4  ??DataTable18_33
       4  ??DataTable18_34
       4  ??DataTable18_35
       4  ??DataTable18_36
       4  ??DataTable18_37
       4  ??DataTable18_38
       4  ??DataTable18_39
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
      36  ?_0
      36  ?_1
      40  ?_10
      20  ?_11
      72  ?_12
      28  ?_13
      28  ?_14
      12  ?_15
      12  ?_16
      36  ?_17
      36  ?_2
      36  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
       2  ?_8
      40  ?_9
      34  AdvanceTokenCounter
      28  DebugClearPassthrough
      26  DebugCommandDummy
     134  DebugCommandLedTestToggle
     158  DebugCommandPrepareList
      76  DebugCommandSysTimeToggle
     206  DebugInitialize
     112  DebugLedTestCharacter
      28  DebugLineFeed
     176  DebugPrintNumber
      36  DebugPrintf
      12  DebugRunActiveState
      40  DebugRxCallback
     178  DebugSM_CheckCmd
      52  DebugSM_Error
     404  DebugSM_Idle
      24  DebugSM_ProcessCmd
      64  DebugScanf
      28  DebugSetPassthrough
       4  Debug_Uart
      64  Debug_au32MsgTokens
      64  Debug_au8CommandBuffer
      64  Debug_au8Commands
     128  Debug_au8RxBuffer
      56  Debug_au8StartupMsg
       4  Debug_pfnStateMachine
       4  Debug_pu8CmdBufferNextChar
       4  Debug_pu8RxBufferNextChar
       4  Debug_pu8RxBufferParser
       2  Debug_u16CommandSize
       1  Debug_u8Command
       1  Debug_u8ErrorCode
       1  Debug_u8TokenCounter
     128  G_au8DebugScanfBuffer
       4  G_u32DebugFlags
       1  G_u8DebugScanfCharCount
     106  SystemStatusReport
       4  au8BackspaceSequence
       8  au8CommandHeader
      32  au8CommandOverflow
      24  au8DebugErrorMsg
      36  au8InvalidCommand

 
   414 bytes in section .bss
   224 bytes in section .data
   578 bytes in section .rodata
 2 082 bytes in section .text
 
 2 082 bytes of CODE  memory
   578 bytes of CONST memory
   638 bytes of DATA  memory

Errors: none
Warnings: none
