###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.1.7305/W32 for ARM        05/Jan/2020  11:19:33
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_ssp.c
#    Command line =  
#        F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_ssp.c -D
#        EIE_ASCII --preprocess=cl
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -lC
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\ -o
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\ --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Software\Develop\IAR for
#        ARM\arm\INC\c\DLib_Config_Normal.h" -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\bsp\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\drivers\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\application\ -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\application\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\bsp\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\cmsis\
#        -I
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\..\..\firmware_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "C:\Software\Develop\IAR
#        for ARM\arm\CMSIS\Include\"
#    List file    =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\List\sam3u_ssp.lst
#    Object file  =  
#        F:\EIE_TEXT\二进制计数器\firmware_ascii\iar_7_20_1\Debug\Obj\sam3u_ssp.o
#
###############################################################################

F:\EIE_TEXT\二进制计数器\firmware_common\drivers\sam3u_ssp.c
      1          /*!**********************************************************************************************************************
      2          @file sam3u_ssp.c                                                                
      3          @brief Provides a driver to use a USART peripheral in SPI/SSP mode to send and 
      4          receive data using interrupts and peripheral DMA.
      5          
      6          Note that Master SPI devices keep CS as a GPIO so it can be managed manually to 
      7          more easily work with the multitude of variants in Slave device CS requirements.
      8          
      9          This driver should work for SPI Slaves with or without flow control, though you may 
     10          need to make adjustments to how data is timed.  A Slave with flow control is 
     11          implemented with callback functions to manage flow control lines.
     12          
     13          When a USART peripheral on the SAM3U2 is configured in SPI mode, the bit that controls
     14          MSB vs. LSB first is used for CPOL and therefore not available.  Sending MSB vs. LSB 
     15          first is currently only selectable in Slave mode with Flow Control which does not use 
     16          DMA and thus the byte can be processed (flipped) as it is loaded.  If LSB-first data 
     17          is required for other modes, data arrays will have to be pre-flipped by the application.
     18          
     19          
     20          INITIALIZATION 
     21          This should take place in application's initialization function.
     22          
     23          1. Create a variable of SspConfigurationType in your application and initialize it 
     24          to the desired SSP peripheral, and the size & address of the receive buffer in the 
     25          application.
     26          
     27          2. Call SspRequest() with pointer to the configuration variable created in step 1.  
     28          The returned pointer is the SspPeripheralType object created that will be used by 
     29          your application for all API calls.
     30          
     31          3. If the application no longer needs the SSP resource, call SspRelease().  
     32          Note: if multiple tasks share an SSP peripheral & bus, SspRequest() and 
     33          SspRelease() will be used frequently to allow traffic to both devices. 
     34          
     35          
     36          MASTER MODE DATA TRANSFER
     37          Transmitted data is queued using one of two functions, SspWriteByte() and 
     38          SspWriteData() which both return a message token unique to the queued message.  
     39          Once the data is queued, it is sent by the SSP as soon as possible.  Different 
     40          SSP resources may transmit and receive data simultaneously.  
     41          
     42          The SPI protocol always receives a byte with every transmitted byte.  This may 
     43          be a defined dummy byte, or it may be 0xFF or 0x00 depending on the idle state 
     44          of the MISO line.  Your application must process the received bytes and determine 
     45          if they are dummy bytes or useful data.
     46          
     47          To receive data from an SSP Slave, call SspReadByte() for a single 
     48          byte or SspReadData() for multiple bytes.  These functions will automatically 
     49          queue SSP_DUMMY bytes to transmit and activate the clock.
     50          
     51          Received bytes on the allocated peripheral will be dropped into the application's 
     52          designated receive buffer.  The buffer is written circularly, with no provision 
     53          to monitor bytes that are overwritten.  The application is responsible for 
     54          processing all received data.  The application must provide its own parsing
     55          pointer to read the receive buffer and properly wrap around.  This pointer 
     56          will not be impacted by the interrupt service routine.  Data may be added to
     57          the application's receive buffer at any time.
     58          
     59          
     60          SLAVE MODE DATA TRANSFER (NO FLOW CONTROL)
     61          In Slave mode, the peripheral is always ready to receive bytes from the Master. 
     62          Since SPI always sends and receives with every transaction, the Slave receiver
     63          must always examine data received even if the transaction was expected to be a
     64          transmit from Slave to Master.
     65          
     66          Received bytes on the allocated peripheral will be dropped into the receive
     67          buffer that the application specifies upon requesting the SPI peripheral.  The buffer 
     68          is written circularly, with no provision to monitor bytes that are overwritten.  The 
     69          application is responsible for processing all received data.  The application must 
     70          provide its own parsing pointer to read the receive buffer and properly wrap around.  
     71          This pointer will not be impacted by the interrupt service routine that may add 
     72          additional characters at any time.
     73          
     74          Transmitting data from a Slave to Master without flow control is slightly awkward 
     75          in this system. If a Master requests data, it must allow at least 2ms for the Slave
     76          to process the data request and queue the required data response.
     77          Transmitted data is queued using one of two functions, SspWriteByte() and 
     78          SspWriteData().  Once the data is queued, the SSP is ready to send via DMA
     79          with the expected number of bytes.  The Master should clock all of these bytes.
     80          
     81          If the correct number of clocks are provided, the ENDTX interrupt will fire
     82          
     83          If not enough clocks are sent and the Master de-asserts CS, then the transmission
     84          is aborted and the message is flushed out.
     85          
     86          If too many clocks are provided, the Slave will resort to sending dummy bytes.
     87          
     88          
     89          SLAVE DATA TRANSFER WITH FLOW CONTROL
     90          Flow control is offered in Slave mode through callback functions. Data transfer is
     91          managed by the peripheral DMA controller byte-by-byte so the system can run
     92          the callbacks and manage flow control lines.  
     93          
     94          ------------------------------------------------------------------------------------------------------------------------
     95          GLOBALS
     96          - G_u32Ssp0ApplicationFlags
     97          - G_u32Ssp1ApplicationFlags
     98          - G_u32Ssp2ApplicationFlags
     99          
    100          CONSTANTS
    101          - NONE
    102          
    103          TYPES
    104          - SspBitOrderType
    105          - SspModeType
    106          - SspRxStatusType
    107          - SspConfigurationType
    108          - SspPeripheralType
    109          
    110          PUBLIC FUNCTIONS
    111          - SspPeripheralType* SspRequest(SspConfigurationType* psSspConfig_)
    112          - void SspRelease(SspPeripheralType* psSspPeripheral_)
    113          - void SspAssertCS(SspPeripheralType* psSspPeripheral_)
    114          - void SspDeAssertCS(SspPeripheralType* psSspPeripheral_)
    115          - u32 SspWriteByte(SspPeripheralType* psSspPeripheral_, u8 u8Byte_)
    116          - u32 SspWriteData(SspPeripheralType* psSspPeripheral_, u32 u32Size_, u8* pu8Data_)
    117          
    118          Master mode only:
    119          - bool SspReadByte(SspPeripheralType* psSspPeripheral_)
    120          - bool SspReadData(SspPeripheralType* psSspPeripheral_, u16 u16Size_)
    121          - SspRxStatusType SspQueryReceiveStatus(SspPeripheralType* psSspPeripheral_)
    122          
    123          PROTECTED FUNCTIONS
    124          - void SspInitialize(void)
    125          - void SspRunActiveState(void)
    126          - void SspManualMode(void)
    127          - void SSP0_IRQHandler(void)
    128          - void SSP1_IRQHandler(void)
    129          - void SSP2_IRQHandler(void)
    130          
    131          
    132          **********************************************************************************************************************/
    133          
    134          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable15_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
    135          
    136          /***********************************************************************************************************************
    137          Global variable definitions with scope across entire project.
    138          All Global variable names shall start with "G_<type>Ssp"
    139          ***********************************************************************************************************************/
    140          /* New variables */

   \                                 In section .bss, align 4
    141          u32 G_u32Ssp0ApplicationFlags;                   /*!< @brief Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp0ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    142          u32 G_u32Ssp1ApplicationFlags;                   /*!< @brief Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp1ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    143          u32 G_u32Ssp2ApplicationFlags;                   /*!< @brief Status flags meant for application using this SSP peripheral */
   \                     G_u32Ssp2ApplicationFlags:
   \   00000000                      DS8 4
    144          
    145          
    146          /*--------------------------------------------------------------------------------------------------------------------*/
    147          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
    148          extern volatile u32 G_u32SystemTime1ms;          /*!< @brief From main.c */
    149          extern volatile u32 G_u32SystemTime1s;           /*!< @brief From main.c */
    150          extern volatile u32 G_u32SystemFlags;            /*!< @brief From main.c */
    151          extern volatile u32 G_u32ApplicationFlags;       /*!< @brief From main.c */
    152          
    153          
    154          /***********************************************************************************************************************
    155          Global variable definitions with scope limited to this local application.
    156          Variable names shall start with "SSP_<type>" and be declared as static.
    157          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
    158          static fnCode_type Ssp_pfnStateMachine;          /*!< @brief The SSP application state machine */
   \                     Ssp_pfnStateMachine:
   \   00000000                      DS8 4
    159          

   \                                 In section .bss, align 4
    160          static u32 SSP_u32Flags;                         /*!< @brief Application flags for SSP */
   \                     SSP_u32Flags:
   \   00000000                      DS8 4
    161          

   \                                 In section .bss, align 4
    162          static SspPeripheralType SSP_Peripheral0;        /*!< @brief SSP0 peripheral object */
   \                     SSP_Peripheral0:
   \   00000000                      DS8 56

   \                                 In section .bss, align 4
    163          static SspPeripheralType SSP_Peripheral1;        /*!< @brief SSP1 peripheral object */
   \                     SSP_Peripheral1:
   \   00000000                      DS8 56

   \                                 In section .bss, align 4
    164          static SspPeripheralType SSP_Peripheral2;        /*!< @brief SSP2 peripheral object */
   \                     SSP_Peripheral2:
   \   00000000                      DS8 56
    165          

   \                                 In section .bss, align 4
    166          static SspPeripheralType* SSP_psCurrentSsp;      /*!< @brief Current SSP peripheral being processed task */
   \                     SSP_psCurrentSsp:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    167          static SspPeripheralType* SSP_psCurrentISR;      /*!< @brief Current SSP peripheral being processed in ISR */
   \                     SSP_psCurrentISR:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    168          static u32* SSP_pu32SspApplicationFlagsISR;      /*!< @brief Current SSP application status flags in ISR */
   \                     SSP_pu32SspApplicationFlagsISR:
   \   00000000                      DS8 4
    169          

   \                                 In section .bss, align 1
    170          static u8 SSP_u8Dummies = SSP_DUMMY_BYTE;        /*!< @brief Dummy source byte */
   \                     SSP_u8Dummies:
   \   00000000                      DS8 1
    171          
    172          /*! @cond DOXYGEN_EXCLUDE */

   \                                 In section .bss, align 4
    173          static u32 SSP_u32Int0Count = 0;                 /* Debug counter for SSP0 interrupts */
   \                     SSP_u32Int0Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    174          static u32 SSP_u32Int1Count = 0;                 /* Debug counter for SSP1 interrupts */
   \                     SSP_u32Int1Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    175          static u32 SSP_u32Int2Count = 0;                 /* Debug counter for SSP2 interrupts */
   \                     SSP_u32Int2Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    176          static u32 SSP_u32AntCounter = 0;                /* Debug counter */
   \                     SSP_u32AntCounter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    177          static u32 SSP_u32RxCounter = 0;                 /* Debug counter */
   \                     SSP_u32RxCounter:
   \   00000000                      DS8 4
    178          /*! @endcond */
    179          
    180          
    181          /***********************************************************************************************************************
    182          Function Definitions
    183          ***********************************************************************************************************************/
    184          
    185          /*--------------------------------------------------------------------------------------------------------------------*/
    186          /*! @publicsection */                                                                                            
    187          /*--------------------------------------------------------------------------------------------------------------------*/
    188          
    189          /*!---------------------------------------------------------------------------------------------------------------------
    190          @fn SspPeripheralType* SspRequest(SspConfigurationType* psSspConfig_)
    191          
    192          @brief Requests access to an SSP resource.  
    193          
    194          If the resource is available, the transmit and receive parameters are set up
    195          and the peripheral is made ready to use in the application. The peripheral will be 
    196          configured in different ways for different SSP modes.  The following modes are supported:
    197          
    198          SPI_MASTER: transmit and receive using peripheral DMA controller; transmit occurs 
    199          through the Message API
    200          
    201          SSP_SLAVE: transmit through Message Task; receive set up per-byte using current 
    202          and next DMA pointers and managed into circular buffer.
    203          
    204          SSP_SLAVE_FLOW_CONTROL: transmit through interrupt-driven single byte transfers 
    205          and call-back; receive using peripheral DMA controller direct to task buffer.
    206          
    207          Requires:
    208          - SSP peripheral register initialization values in configuration.h must be set 
    209            correctly; currently this does not support different SSP configurations 
    210            for multiple slaves on the same bus - all peripherals on the bus must work with
    211            the same setup.
    212          
    213          @param psSspConfig_ has the SSP peripheral number, address of the RxBuffer and the RxBuffer size
    214          
    215          Promises:
    216          - Returns a pointer to the requested SSP peripheral object if the resource is available; otherwise returns NULL
    217          - Peripheral is enabled
    218          - Peripheral interrupts are enabled.
    219          
    220          */

   \                                 In section .text, align 2, keep-with-next
    221          SspPeripheralType* SspRequest(SspConfigurationType* psSspConfig_)
    222          {
   \                     SspRequest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    223            SspPeripheralType* psRequestedSsp; 
    224            u32 u32TargetCR, u32TargetMR, u32TargetIER, u32TargetIDR, u32TargetBRGR;
    225          
    226            /* Set the peripheral pointer to the correct resource */
    227            switch(psSspConfig_->SspPeripheral)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD004             BEQ.N    ??SspRequest_0
   \   0000000C   0xD334             BCC.N    ??SspRequest_1
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD021             BEQ.N    ??SspRequest_2
   \   00000012   0xD310             BCC.N    ??SspRequest_3
   \   00000014   0xE030             B.N      ??SspRequest_1
    228            {
    229              case USART0:
    230              {
    231                psRequestedSsp = &SSP_Peripheral0;
   \                     ??SspRequest_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   0000001A   0x0005             MOVS     R5,R0
    232                
    233                u32TargetCR   = USART0_US_CR_INIT;
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x0006             MOVS     R6,R0
    234                u32TargetMR   = USART0_US_MR_INIT; 
   \   00000020   0xF44F 0x600C      MOV      R0,#+2240
   \   00000024   0x0007             MOVS     R7,R0
    235                u32TargetIER  = USART0_US_IER_INIT; 
   \   00000026   0x2008             MOVS     R0,#+8
   \   00000028   0x4680             MOV      R8,R0
    236                u32TargetIDR  = USART0_US_IDR_INIT;
   \   0000002A   0xF07F 0x0008      MVNS     R0,#+8
   \   0000002E   0x4681             MOV      R9,R0
    237                u32TargetBRGR = USART0_US_BRGR_INIT;
   \   00000030   0x201A             MOVS     R0,#+26
   \   00000032   0x4682             MOV      R10,R0
    238                break;
   \   00000034   0xE022             B.N      ??SspRequest_4
    239              }
    240              case USART1:
    241              {
    242                psRequestedSsp = &SSP_Peripheral1;
   \                     ??SspRequest_3: (+1)
   \   00000036   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   0000003A   0x0005             MOVS     R5,R0
    243                
    244                u32TargetCR   = USART1_US_CR_INIT;
   \   0000003C   0x2050             MOVS     R0,#+80
   \   0000003E   0x0006             MOVS     R6,R0
    245                u32TargetMR   = USART1_US_MR_INIT; 
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable15_5  ;; 0x4518ce
   \   00000044   0x0007             MOVS     R7,R0
    246                u32TargetIER  = USART1_US_IER_INIT; 
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x4680             MOV      R8,R0
    247                u32TargetIDR  = USART1_US_IDR_INIT;
   \   0000004A   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000004E   0x4681             MOV      R9,R0
    248                u32TargetBRGR = USART1_US_BRGR_INIT;
   \   00000050   0x2030             MOVS     R0,#+48
   \   00000052   0x4682             MOV      R10,R0
    249                break;
   \   00000054   0xE012             B.N      ??SspRequest_4
    250              }
    251              case USART2:
    252              {
    253                psRequestedSsp = &SSP_Peripheral2;
   \                     ??SspRequest_2: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   0000005A   0x0005             MOVS     R5,R0
    254                
    255                u32TargetCR   = USART2_US_CR_INIT;
   \   0000005C   0x2050             MOVS     R0,#+80
   \   0000005E   0x0006             MOVS     R6,R0
    256                u32TargetMR   = USART2_US_MR_INIT; 
   \   00000060   0x.... 0x....      LDR.W    R0,??DataTable15_7  ;; 0x4118ff
   \   00000064   0x0007             MOVS     R7,R0
    257                u32TargetIER  = USART2_US_IER_INIT; 
   \   00000066   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000006A   0x4680             MOV      R8,R0
    258                u32TargetIDR  = USART2_US_IDR_INIT;
   \   0000006C   0xF47F 0x2000      MVNS     R0,#+524288
   \   00000070   0x4681             MOV      R9,R0
    259                u32TargetBRGR = USART2_US_BRGR_INIT;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x4682             MOV      R10,R0
    260                break;
   \   00000076   0xE001             B.N      ??SspRequest_4
    261              }
    262              
    263              default:
    264              {
    265                return(NULL);
   \                     ??SspRequest_1: (+1)
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE075             B.N      ??SspRequest_5
    266              }
    267            } /* end switch */
    268            
    269            /* If the requested peripheral is already assigned, return NULL now */
    270            if(psRequestedSsp->u32PrivateFlags & _SSP_PERIPHERAL_ASSIGNED)
   \                     ??SspRequest_4: (+1)
   \   0000007C   0x6928             LDR      R0,[R5, #+16]
   \   0000007E   0x02C0             LSLS     R0,R0,#+11
   \   00000080   0xD501             BPL.N    ??SspRequest_6
    271            {
    272              return(NULL);
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE070             B.N      ??SspRequest_5
    273            }
    274          
    275            /* Activate and configure the peripheral */
    276            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedSsp->u8PeripheralId);
   \                     ??SspRequest_6: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable15_8  ;; 0x400e0410
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x2101             MOVS     R1,#+1
   \   0000008E   0xF995 0x2028      LDRSB    R2,[R5, #+40]
   \   00000092   0x4091             LSLS     R1,R1,R2
   \   00000094   0x4308             ORRS     R0,R1,R0
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable15_8  ;; 0x400e0410
   \   0000009A   0x6008             STR      R0,[R1, #+0]
    277            
    278            psRequestedSsp->pCsGpioAddress   = psSspConfig_->pCsGpioAddress;
   \   0000009C   0x6860             LDR      R0,[R4, #+4]
   \   0000009E   0x6068             STR      R0,[R5, #+4]
    279            psRequestedSsp->u32CsPin         = psSspConfig_->u32CsPin;
   \   000000A0   0x68A0             LDR      R0,[R4, #+8]
   \   000000A2   0x60A8             STR      R0,[R5, #+8]
    280            psRequestedSsp->eBitOrder        = psSspConfig_->eBitOrder;
   \   000000A4   0x7B20             LDRB     R0,[R4, #+12]
   \   000000A6   0x7328             STRB     R0,[R5, #+12]
    281            psRequestedSsp->eSspMode         = psSspConfig_->eSspMode;
   \   000000A8   0x7B60             LDRB     R0,[R4, #+13]
   \   000000AA   0x7368             STRB     R0,[R5, #+13]
    282            psRequestedSsp->pu8RxBuffer      = psSspConfig_->pu8RxBufferAddress;
   \   000000AC   0x69A0             LDR      R0,[R4, #+24]
   \   000000AE   0x61E8             STR      R0,[R5, #+28]
    283            psRequestedSsp->ppu8RxNextByte   = psSspConfig_->ppu8RxNextByte;
   \   000000B0   0x69E0             LDR      R0,[R4, #+28]
   \   000000B2   0x6228             STR      R0,[R5, #+32]
    284            psRequestedSsp->u16RxBufferSize  = psSspConfig_->u16RxBufferSize;
   \   000000B4   0x8C20             LDRH     R0,[R4, #+32]
   \   000000B6   0x84A8             STRH     R0,[R5, #+36]
    285            psRequestedSsp->u32PrivateFlags |= _SSP_PERIPHERAL_ASSIGNED;
   \   000000B8   0x6928             LDR      R0,[R5, #+16]
   \   000000BA   0xF450 0x1080      ORRS     R0,R0,#0x100000
   \   000000BE   0x6128             STR      R0,[R5, #+16]
    286            psRequestedSsp->fnSlaveTxFlowCallback = psSspConfig_->fnSlaveTxFlowCallback;
   \   000000C0   0x6920             LDR      R0,[R4, #+16]
   \   000000C2   0x6168             STR      R0,[R5, #+20]
    287            psRequestedSsp->fnSlaveRxFlowCallback = psSspConfig_->fnSlaveRxFlowCallback;
   \   000000C4   0x6960             LDR      R0,[R4, #+20]
   \   000000C6   0x61A8             STR      R0,[R5, #+24]
    288             
    289            psRequestedSsp->pBaseAddress->US_CR   = u32TargetCR;
   \   000000C8   0x6828             LDR      R0,[R5, #+0]
   \   000000CA   0x6006             STR      R6,[R0, #+0]
    290            psRequestedSsp->pBaseAddress->US_MR   = u32TargetMR;
   \   000000CC   0x6828             LDR      R0,[R5, #+0]
   \   000000CE   0x6047             STR      R7,[R0, #+4]
    291            psRequestedSsp->pBaseAddress->US_IER  = u32TargetIER;
   \   000000D0   0x6828             LDR      R0,[R5, #+0]
   \   000000D2   0xF8C0 0x8008      STR      R8,[R0, #+8]
    292            psRequestedSsp->pBaseAddress->US_IDR  = u32TargetIDR;
   \   000000D6   0x6828             LDR      R0,[R5, #+0]
   \   000000D8   0xF8C0 0x900C      STR      R9,[R0, #+12]
    293            psRequestedSsp->pBaseAddress->US_BRGR = u32TargetBRGR;
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0xF8C0 0xA020      STR      R10,[R0, #+32]
    294            
    295            /* Special considerations for SPI Slaves */
    296            if(psRequestedSsp->eSspMode == SSP_SLAVE)
   \   000000E2   0x7B68             LDRB     R0,[R5, #+13]
   \   000000E4   0x2802             CMP      R0,#+2
   \   000000E6   0xD12D             BNE.N    ??SspRequest_7
    297            {
    298              /* Preset the PDC receive pointers and counters; the receive buffer must be starting 
    299              from [0] and be at least 2 bytes long)*/
    300              psRequestedSsp->pBaseAddress->US_RPR  = (u32)psSspConfig_->pu8RxBufferAddress;
   \   000000E8   0x69A0             LDR      R0,[R4, #+24]
   \   000000EA   0x6829             LDR      R1,[R5, #+0]
   \   000000EC   0xF8C1 0x0100      STR      R0,[R1, #+256]
    301              psRequestedSsp->pBaseAddress->US_RNPR = (u32)(psSspConfig_->pu8RxBufferAddress + 1);
   \   000000F0   0x69A0             LDR      R0,[R4, #+24]
   \   000000F2   0x1C40             ADDS     R0,R0,#+1
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0xF8C1 0x0110      STR      R0,[R1, #+272]
    302              psRequestedSsp->pBaseAddress->US_RCR  = 1;
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x6829             LDR      R1,[R5, #+0]
   \   000000FE   0xF8C1 0x0104      STR      R0,[R1, #+260]
    303              psRequestedSsp->pBaseAddress->US_RNCR = 1;
   \   00000102   0x2001             MOVS     R0,#+1
   \   00000104   0x6829             LDR      R1,[R5, #+0]
   \   00000106   0xF8C1 0x0114      STR      R0,[R1, #+276]
    304              psRequestedSsp->ppu8RxNextByte = NULL; /* not used for SSP_SLAVE */
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0x6228             STR      R0,[R5, #+32]
    305              
    306              /* Preset the PDC transmit registers to return predictable SPI dummy bytes
    307              if the Slave is receiving. These will be changed if the Slave transmit is queued
    308              by the application.  */
    309              psRequestedSsp->pBaseAddress->US_TPR  = (u32)&SSP_u8Dummies; 
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   00000112   0x6829             LDR      R1,[R5, #+0]
   \   00000114   0xF8C1 0x0108      STR      R0,[R1, #+264]
    310              psRequestedSsp->pBaseAddress->US_TNPR = (u32)&SSP_u8Dummies; 
   \   00000118   0x.... 0x....      LDR.W    R0,??DataTable15_9
   \   0000011C   0x6829             LDR      R1,[R5, #+0]
   \   0000011E   0xF8C1 0x0118      STR      R0,[R1, #+280]
    311              psRequestedSsp->pBaseAddress->US_TCR = 1;
   \   00000122   0x2001             MOVS     R0,#+1
   \   00000124   0x6829             LDR      R1,[R5, #+0]
   \   00000126   0xF8C1 0x010C      STR      R0,[R1, #+268]
    312              psRequestedSsp->pBaseAddress->US_TNCR = 1;
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0x6829             LDR      R1,[R5, #+0]
   \   0000012E   0xF8C1 0x011C      STR      R0,[R1, #+284]
    313          
    314              /* Enable the receiver and transmitter so they are ready to go if the Master starts clocking */
    315              psRequestedSsp->pBaseAddress->US_PTCR = (AT91C_PDC_RXTEN | AT91C_PDC_TXTEN);
   \   00000132   0xF240 0x1001      MOVW     R0,#+257
   \   00000136   0x6829             LDR      R1,[R5, #+0]
   \   00000138   0xF8C1 0x0120      STR      R0,[R1, #+288]
    316              psRequestedSsp->pBaseAddress->US_IER  = (AT91C_US_CTSIC | AT91C_US_ENDRX | AT91C_US_ENDTX);
   \   0000013C   0x.... 0x....      LDR.W    R0,??DataTable15_10  ;; 0x80018
   \   00000140   0x6829             LDR      R1,[R5, #+0]
   \   00000142   0x6088             STR      R0,[R1, #+8]
    317            }
    318          
    319            /* Special considerations for SPI Slaves with Flow Control */
    320            if(psRequestedSsp->eSspMode == SSP_SLAVE_FLOW_CONTROL)
   \                     ??SspRequest_7: (+1)
   \   00000144   0x7B68             LDRB     R0,[R5, #+13]
   \   00000146   0x2803             CMP      R0,#+3
   \   00000148   0xD103             BNE.N    ??SspRequest_8
    321            {
    322              /* Enable the CS interrupt */
    323              psRequestedSsp->pBaseAddress->US_IER = AT91C_US_CTSIC;
   \   0000014A   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000014E   0x6829             LDR      R1,[R5, #+0]
   \   00000150   0x6088             STR      R0,[R1, #+8]
    324            }
    325            
    326            /* Enable SSP interrupts */
    327            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedSsp->u8PeripheralId );
   \                     ??SspRequest_8: (+1)
   \   00000152   0xF995 0x0028      LDRSB    R0,[R5, #+40]
   \   00000156   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000158   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    328            NVIC_EnableIRQ( (IRQn_Type)psRequestedSsp->u8PeripheralId );
   \   0000015C   0xF995 0x0028      LDRSB    R0,[R5, #+40]
   \   00000160   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000162   0x.... 0x....      BL       NVIC_EnableIRQ
    329            
    330            return(psRequestedSsp);
   \   00000166   0x0028             MOVS     R0,R5
   \                     ??SspRequest_5: (+1)
   \   00000168   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    331            
    332          } /* end SspRequest() */
    333          
    334          
    335          /*!---------------------------------------------------------------------------------------------------------------------
    336          @fn void SspRelease(SspPeripheralType* psSspPeripheral_)
    337          
    338          @brief Releases an SSP resource.  
    339          
    340          Requires:
    341          - Receive operation is not in progress
    342          
    343          @param psSspPeripheral_ has the SSP peripheral number, address of the RxBuffer, 
    344          and the RxBuffer.
    345          
    346          Promises:
    347          - Resets peripheral object's pointers and data to safe values
    348          - Peripheral is disabled
    349          - Peripheral interrupts are disabled.
    350          
    351          */

   \                                 In section .text, align 2, keep-with-next
    352          void SspRelease(SspPeripheralType* psSspPeripheral_)
    353          {
   \                     SspRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    354            /* Check to see if the peripheral is already released */
    355            if( !(psSspPeripheral_->u32PrivateFlags) & _SSP_PERIPHERAL_ASSIGNED )
   \   00000004   0x6920             LDR      R0,[R4, #+16]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE.N    ??SspRelease_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xE000             B.N      ??SspRelease_1
   \                     ??SspRelease_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
    356            {
    357              return;
    358            }
    359            
    360            /* Disable interrupts */
    361            NVIC_DisableIRQ( (IRQn_Type)(psSspPeripheral_->u8PeripheralId) );
   \                     ??SspRelease_1: (+1)
   \   00000010   0xF994 0x0028      LDRSB    R0,[R4, #+40]
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x.... 0x....      BL       NVIC_DisableIRQ
    362            NVIC_ClearPendingIRQ( (IRQn_Type)(psSspPeripheral_->u8PeripheralId) );
   \   0000001A   0xF994 0x0028      LDRSB    R0,[R4, #+40]
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    363           
    364            /* Now it's safe to release all of the resources in the target peripheral */
    365            psSspPeripheral_->pCsGpioAddress  = NULL;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6060             STR      R0,[R4, #+4]
    366            psSspPeripheral_->pu8RxBuffer     = NULL;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x61E0             STR      R0,[R4, #+28]
    367            psSspPeripheral_->ppu8RxNextByte  = NULL;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x6220             STR      R0,[R4, #+32]
    368            psSspPeripheral_->u32PrivateFlags = 0;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6120             STR      R0,[R4, #+16]
    369            
    370            psSspPeripheral_->fnSlaveTxFlowCallback = NULL;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6160             STR      R0,[R4, #+20]
    371            psSspPeripheral_->fnSlaveRxFlowCallback = NULL;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x61A0             STR      R0,[R4, #+24]
    372          
    373            /* Empty the transmit buffer if there were leftover messages */
    374            while(psSspPeripheral_->psTransmitBuffer != NULL)
   \                     ??SspRelease_2: (+1)
   \   0000003C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD009             BEQ.N    ??SspRelease_3
    375            {
    376              UpdateMessageStatus(psSspPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   00000042   0x2105             MOVS     R1,#+5
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x.... 0x....      BL       UpdateMessageStatus
    377              DeQueueMessage(&psSspPeripheral_->psTransmitBuffer);
   \   0000004C   0xF114 0x002C      ADDS     R0,R4,#+44
   \   00000050   0x.... 0x....      BL       DeQueueMessage
   \   00000054   0xE7F2             B.N      ??SspRelease_2
    378            }
    379            
    380            /* Ensure the SM is in the Idle state */
    381            Ssp_pfnStateMachine = SspSM_Idle;
   \                     ??SspRelease_3: (+1)
   \   00000056   0x.... 0x....      ADR.W    R0,SspSM_Idle
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   0000005E   0x6008             STR      R0,[R1, #+0]
    382            
    383          } /* end SspRelease() */
   \   00000060   0xBD10             POP      {R4,PC}          ;; return
    384          
    385          
    386          /*!---------------------------------------------------------------------------------------------------------------------
    387          @fn void SspAssertCS(SspPeripheralType* psSspPeripheral_)
    388          
    389          @brief Master mode manual CS only. Asserts (CLEARS) the CS line on the target SSP peripheral.  
    390          
    391          Requires:
    392          - eSspMode should be SSP_MASTER_MANUAL_CS or function does nothing.
    393          
    394          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    395          
    396          Promises:
    397          - Target's CS line is LOW
    398          
    399          */

   \                                 In section .text, align 2, keep-with-next
    400          void SspAssertCS(SspPeripheralType* psSspPeripheral_)
    401          {
    402            if( psSspPeripheral_->eSspMode == SSP_MASTER_MANUAL_CS )
   \                     SspAssertCS: (+1)
   \   00000000   0x7B41             LDRB     R1,[R0, #+13]
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD102             BNE.N    ??SspAssertCS_0
    403            {
    404              psSspPeripheral_->pCsGpioAddress->PIO_CODR = psSspPeripheral_->u32CsPin;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6351             STR      R1,[R2, #+52]
    405            }
    406            
    407          } /* end SspAssertCS() */
   \                     ??SspAssertCS_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    408          
    409          
    410          /*!---------------------------------------------------------------------------------------------------------------------
    411          @fn void SspDeAssertCS(SspPeripheralType* psSspPeripheral_)
    412          
    413          @brief Master mode only. Deasserts (SETS) the CS line on the target SSP peripheral.  
    414          
    415          Requires:
    416          - eSspMode should be SSP_MASTER_MANUAL_CS or function does nothing.
    417          
    418          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    419          
    420          Promises:
    421          - Target's CS line is HIGH
    422          
    423          */

   \                                 In section .text, align 2, keep-with-next
    424          void SspDeAssertCS(SspPeripheralType* psSspPeripheral_)
    425          {
    426            if( psSspPeripheral_->eSspMode == SSP_MASTER_MANUAL_CS )
   \                     SspDeAssertCS: (+1)
   \   00000000   0x7B41             LDRB     R1,[R0, #+13]
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD102             BNE.N    ??SspDeAssertCS_0
    427            {
    428              psSspPeripheral_->pCsGpioAddress->PIO_SODR = psSspPeripheral_->u32CsPin;
   \   00000006   0x6881             LDR      R1,[R0, #+8]
   \   00000008   0x6842             LDR      R2,[R0, #+4]
   \   0000000A   0x6311             STR      R1,[R2, #+48]
    429            } 
    430            
    431          } /* end SspDessertCS() */
   \                     ??SspDeAssertCS_0: (+1)
   \   0000000C   0x4770             BX       LR               ;; return
    432          
    433          
    434          /*!---------------------------------------------------------------------------------------------------------------------
    435          @fn u32 SspWriteByte(SspPeripheralType* psSspPeripheral_, u8 u8Byte_)
    436          
    437          @brief Queues a single byte for transfer on the target SSP peripheral.  
    438          
    439          Requires:
    440          - A receive request cannot be in progress
    441          
    442          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    443          @param u8Byte_ is the byte to send
    444          
    445          Promises:
    446          - Creates a 1-byte message at psSspPeripheral_->psTransmitBuffer that will be sent 
    447            by the SSP application when it is available.
    448          - Returns the message token assigned to the message; 0 is returned if the message 
    449            cannot be queued in which case G_u32MessagingFlags can be checked for the reason
    450          
    451          */

   \                                 In section .text, align 2, keep-with-next
    452          u32 SspWriteByte(SspPeripheralType* psSspPeripheral_, u8 u8Byte_)
    453          {
   \                     SspWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    454            u32 u32Token;
    455            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    456          
    457            /* Make sure no receive function is already in progress based on the bytes in the buffer */
    458            if( psSspPeripheral_->u16RxBytes != 0)
   \   0000000C   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD001             BEQ.N    ??SspWriteByte_0
    459            {
    460              return(0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE010             B.N      ??SspWriteByte_1
    461            }
    462          
    463            u32Token = QueueMessage(&psSspPeripheral_->psTransmitBuffer, 1, &u8Data);
   \                     ??SspWriteByte_0: (+1)
   \   00000016   0xAA00             ADD      R2,SP,#+0
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0xF114 0x002C      ADDS     R0,R4,#+44
   \   0000001E   0x.... 0x....      BL       QueueMessage
   \   00000022   0x0006             MOVS     R6,R0
    464            if( u32Token != 0 )
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD006             BEQ.N    ??SspWriteByte_2
    465            {
    466              /* If the system is initializing, we want to manually cycle the SSP task through one iteration
    467              to send the message */
    468              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD501             BPL.N    ??SspWriteByte_2
    469              {
    470                SspManualMode();
   \   00000032   0x.... 0x....      BL       SspManualMode
    471              }
    472            }
    473            
    474            return(u32Token);
   \                     ??SspWriteByte_2: (+1)
   \   00000036   0x0030             MOVS     R0,R6
   \                     ??SspWriteByte_1: (+1)
   \   00000038   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    475            
    476          } /* end SspWriteByte() */
    477          
    478          
    479          /*!--------------------------------------------------------------------------------------------------------------------
    480          @fn u32 SspWriteData(SspPeripheralType* psSspPeripheral_, u32 u32Size_, u8* pu8Data_)
    481          
    482          @brief Queues a data array for transfer on the target SSP peripheral.  
    483          
    484          Requires:
    485          - A receive request cannot be in progress
    486          
    487          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    488          @param u32Size_ is the number of bytes in the data array
    489          @param pu8Data_ points to the first byte of the data array
    490          
    491          Promises:
    492          - adds the data message at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    493            when it is available.
    494          - Returns the message token assigned to the message; 0 is returned if the message 
    495            cannot be queued in which case G_u32MessagingFlags can be checked for the reason
    496          
    497          */

   \                                 In section .text, align 2, keep-with-next
    498          u32 SspWriteData(SspPeripheralType* psSspPeripheral_, u32 u32Size_, u8* pu8Data_)
    499          {
   \                     SspWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    500            u32 u32Token;
    501          
    502            /* Make sure no receive function is already in progress based on the bytes in the buffer */
    503            if( psSspPeripheral_->u16RxBytes != 0)
   \   00000008   0x8CE0             LDRH     R0,[R4, #+38]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ.N    ??SspWriteData_0
    504            {
    505              return(0);
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE012             B.N      ??SspWriteData_1
    506            }
    507          
    508            u32Token = QueueMessage(&psSspPeripheral_->psTransmitBuffer, u32Size_, pu8Data_);
   \                     ??SspWriteData_0: (+1)
   \   00000012   0x0032             MOVS     R2,R6
   \   00000014   0x0029             MOVS     R1,R5
   \   00000016   0xF114 0x002C      ADDS     R0,R4,#+44
   \   0000001A   0x.... 0x....      BL       QueueMessage
   \   0000001E   0x0007             MOVS     R7,R0
    509            if( u32Token == 0 )
   \   00000020   0x2F00             CMP      R7,#+0
   \   00000022   0xD101             BNE.N    ??SspWriteData_2
    510            {
    511              return(0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE007             B.N      ??SspWriteData_1
    512            }
    513            
    514            /* If the system is initializing, manually cycle the SSP task through one iteration to send the message */
    515            if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \                     ??SspWriteData_2: (+1)
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable15_12
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD501             BPL.N    ??SspWriteData_3
    516            {
    517              SspManualMode();
   \   00000032   0x.... 0x....      BL       SspManualMode
    518            }
    519          
    520            return(u32Token);
   \                     ??SspWriteData_3: (+1)
   \   00000036   0x0038             MOVS     R0,R7
   \                     ??SspWriteData_1: (+1)
   \   00000038   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    521          
    522          } /* end SspWriteData() */
    523          
    524          
    525          /*!--------------------------------------------------------------------------------------------------------------------
    526          @fn bool SspReadByte(SspPeripheralType* psSspPeripheral_)
    527          
    528          @brief Master mode only.  Queues a request for a single byte from the Slave on 
    529          the target SSP peripheral.  There cannot be pending writes.
    530          
    531          Requires:
    532          - Master mode 
    533          
    534          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    535          
    536          Promises:
    537          - Creates a message with one SSP_DUMMY_BYTE at psSspPeripheral_->psTransmitBuffer that will be sent by the SSP application
    538            when it is available and thus clock in a received byte to the target receive buffer.
    539          - Returns TRUE and loads the target SSP u16RxBytes
    540          
    541          */

   \                                 In section .text, align 2, keep-with-next
    542          bool SspReadByte(SspPeripheralType* psSspPeripheral_)
    543          {
   \                     SspReadByte: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    544            /* Confirm Master Mode */
    545            if( (psSspPeripheral_->eSspMode == SSP_SLAVE) || 
    546                (psSspPeripheral_->eSspMode == SSP_SLAVE_FLOW_CONTROL) )
   \   00000002   0x7B48             LDRB     R0,[R1, #+13]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD002             BEQ.N    ??SspReadByte_0
   \   00000008   0x7B48             LDRB     R0,[R1, #+13]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD101             BNE.N    ??SspReadByte_1
    547            {
    548              return FALSE;
   \                     ??SspReadByte_0: (+1)
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xE00A             B.N      ??SspReadByte_2
    549            }
    550          
    551            /* Make sure no Tx or Rx function is already in progress */
    552            if( (psSspPeripheral_->u16RxBytes != 0) || (psSspPeripheral_->psTransmitBuffer != NULL) )
   \                     ??SspReadByte_1: (+1)
   \   00000012   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??SspReadByte_3
   \   00000018   0x6AC8             LDR      R0,[R1, #+44]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??SspReadByte_4
    553            {
    554              return FALSE;
   \                     ??SspReadByte_3: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE002             B.N      ??SspReadByte_2
    555            }
    556            
    557            /* Load the counter and return success */
    558            psSspPeripheral_->u16RxBytes = 1;
   \                     ??SspReadByte_4: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x84C8             STRH     R0,[R1, #+38]
    559            return TRUE;
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??SspReadByte_2: (+1)
   \   00000028   0x4770             BX       LR               ;; return
    560            
    561          } /* end SspReadByte() */
    562          
    563          
    564          /*!--------------------------------------------------------------------------------------------------------------------
    565          @fn bool SspReadData(SspPeripheralType* psSspPeripheral_, u16 u16Size_)
    566          
    567          @brief Master mode only. Prepares to get multiple bytes from the Slave on the target SSP peripheral.  
    568          
    569          Requires:
    570          - Master mode 
    571          
    572          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    573          @param u16Size_ is the number of bytes to receive
    574          
    575          Promises:
    576          - Returns FALSE if the message is too big, or the peripheral already has a read request
    577          - Returns TRUE and loads the target SSP u16RxBytes
    578          
    579          */

   \                                 In section .text, align 2, keep-with-next
    580          bool SspReadData(SspPeripheralType* psSspPeripheral_, u16 u16Size_)
    581          {
   \                     SspReadData: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    582            /* Confirm Master Mode */
    583            if( (psSspPeripheral_->eSspMode == SSP_SLAVE) || 
    584                (psSspPeripheral_->eSspMode == SSP_SLAVE_FLOW_CONTROL) )
   \   00000006   0x7B60             LDRB     R0,[R4, #+13]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD002             BEQ.N    ??SspReadData_0
   \   0000000C   0x7B60             LDRB     R0,[R4, #+13]
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD101             BNE.N    ??SspReadData_1
    585            {
    586              return FALSE;
   \                     ??SspReadData_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE012             B.N      ??SspReadData_2
    587            }
    588          
    589            /* Make sure no Tx or Rx function is already in progress */
    590            if( (psSspPeripheral_->u16RxBytes != 0) || (psSspPeripheral_->psTransmitBuffer != NULL) )
   \                     ??SspReadData_1: (+1)
   \   00000016   0x8CE0             LDRH     R0,[R4, #+38]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD102             BNE.N    ??SspReadData_3
   \   0000001C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD001             BEQ.N    ??SspReadData_4
    591            {
    592              return FALSE;
   \                     ??SspReadData_3: (+1)
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0xE00A             B.N      ??SspReadData_2
    593            }
    594          
    595            /* Do not allow if requested size is too large */
    596            if(u16Size_ > U16_MAX_TX_MESSAGE_LENGTH)
   \                     ??SspReadData_4: (+1)
   \   00000026   0xB2AD             UXTH     R5,R5            ;; ZeroExt  R5,R5,#+16,#+16
   \   00000028   0x2D81             CMP      R5,#+129
   \   0000002A   0xDB05             BLT.N    ??SspReadData_5
    597            {
    598              DebugPrintf("\r\nSSP message too large\n\r");
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable15_13
   \   00000030   0x.... 0x....      BL       DebugPrintf
    599              return FALSE;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE001             B.N      ??SspReadData_2
    600            }
    601            
    602            /* Load the counter and return success */
    603            psSspPeripheral_->u16RxBytes = u16Size_;
   \                     ??SspReadData_5: (+1)
   \   00000038   0x84E5             STRH     R5,[R4, #+38]
    604            return TRUE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \                     ??SspReadData_2: (+1)
   \   0000003C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    605              
    606          } /* end SspReadData() */
    607          
    608          
    609          /*!--------------------------------------------------------------------------------------------------------------------
    610          @fn SspRxStatusType SspQueryReceiveStatus(SspPeripheralType* psSspPeripheral_)
    611          
    612          @brief Master mode only.  Returns status of currently requested receive data.
    613          
    614          Requires:
    615          @param psSspPeripheral_ is the SSP peripheral to use and it has already been requested.
    616          
    617          Promises:
    618          - Returns the SspRxStatusType status of the currently receiving message.
    619          
    620          */

   \                                 In section .text, align 2, keep-with-next
    621          SspRxStatusType SspQueryReceiveStatus(SspPeripheralType* psSspPeripheral_)
    622          {
   \                     SspQueryReceiveStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    623            /* Confirm Master Mode */
    624            if( (psSspPeripheral_->eSspMode == SSP_SLAVE) || 
    625                (psSspPeripheral_->eSspMode == SSP_SLAVE_FLOW_CONTROL) )
   \   00000002   0x7B48             LDRB     R0,[R1, #+13]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD002             BEQ.N    ??SspQueryReceiveStatus_0
   \   00000008   0x7B48             LDRB     R0,[R1, #+13]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD101             BNE.N    ??SspQueryReceiveStatus_1
    626            {
    627              return SSP_RX_INVALID;
   \                     ??SspQueryReceiveStatus_0: (+1)
   \   0000000E   0x2005             MOVS     R0,#+5
   \   00000010   0xE013             B.N      ??SspQueryReceiveStatus_2
    628            }
    629          
    630            /* Check for no current bytes queued */
    631            if(psSspPeripheral_->u16RxBytes == 0)
   \                     ??SspQueryReceiveStatus_1: (+1)
   \   00000012   0x8CC8             LDRH     R0,[R1, #+38]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD10A             BNE.N    ??SspQueryReceiveStatus_3
    632            {
    633              /* If a transfer just finished and has not be queried... */
    634              if(psSspPeripheral_->u32PrivateFlags & _SSP_PERIPHERAL_RX_COMPLETE)
   \   00000018   0x6908             LDR      R0,[R1, #+16]
   \   0000001A   0x0200             LSLS     R0,R0,#+8
   \   0000001C   0xD505             BPL.N    ??SspQueryReceiveStatus_4
    635              {
    636                psSspPeripheral_->u32PrivateFlags &= ~_SSP_PERIPHERAL_RX_COMPLETE;
   \   0000001E   0x6908             LDR      R0,[R1, #+16]
   \   00000020   0xF430 0x0000      BICS     R0,R0,#0x800000
   \   00000024   0x6108             STR      R0,[R1, #+16]
    637                return SSP_RX_COMPLETE;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xE007             B.N      ??SspQueryReceiveStatus_2
    638              }
    639              /* Otherwise it's just empty */
    640              else
    641              {
    642                return SSP_RX_EMPTY;
   \                     ??SspQueryReceiveStatus_4: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xE005             B.N      ??SspQueryReceiveStatus_2
    643              }
    644            }
    645            /* If there are bytes waiting, check if waiting or in progress */
    646            else
    647            {
    648              if(psSspPeripheral_->u32PrivateFlags & _SSP_PERIPHERAL_RX)
   \                     ??SspQueryReceiveStatus_3: (+1)
   \   0000002E   0x6908             LDR      R0,[R1, #+16]
   \   00000030   0x0240             LSLS     R0,R0,#+9
   \   00000032   0xD501             BPL.N    ??SspQueryReceiveStatus_5
    649              {
    650                return SSP_RX_RECEIVING;
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xE000             B.N      ??SspQueryReceiveStatus_2
    651              }
    652              else
    653              {
    654                return SSP_RX_WAITING;
   \                     ??SspQueryReceiveStatus_5: (+1)
   \   00000038   0x2001             MOVS     R0,#+1
   \                     ??SspQueryReceiveStatus_2: (+1)
   \   0000003A   0x4770             BX       LR               ;; return
    655              }
    656            }
    657            
    658          } /* end SspQueryReceiveStatus() */
    659          
    660          
    661          /*--------------------------------------------------------------------------------------------------------------------*/
    662          /*! @protectedsection */                                                                                            
    663          /*--------------------------------------------------------------------------------------------------------------------*/
    664          
    665          /*!--------------------------------------------------------------------------------------------------------------------
    666          @fn void SspInitialize(void)
    667          
    668          @brief Initializes the SSP application and its variables.  
    669          
    670          The peripherals themselves are not configured until requested by a calling application.
    671          
    672          Requires:
    673          - NONE
    674          
    675          Promises:
    676          - SSP peripheral objects are ready 
    677          - SSP application set to Idle
    678          
    679          */

   \                                 In section .text, align 2, keep-with-next
    680          void SspInitialize(void)
    681          {
   \                     SspInitialize: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    682            /* Initialize the SSP peripheral structures */
    683            SSP_Peripheral0.pBaseAddress     = AT91C_BASE_US0;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_14  ;; 0x40090000
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    684            SSP_Peripheral0.u8PeripheralId   = AT91C_ID_US0;
   \   0000000C   0x200D             MOVS     R0,#+13
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000012   0xF881 0x0028      STRB     R0,[R1, #+40]
    685            SSP_Peripheral0.pCsGpioAddress   = NULL;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000001C   0x6048             STR      R0,[R1, #+4]
    686            SSP_Peripheral0.psTransmitBuffer = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000024   0x62C8             STR      R0,[R1, #+44]
    687            SSP_Peripheral0.pu8RxBuffer      = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000002C   0x61C8             STR      R0,[R1, #+28]
    688            SSP_Peripheral0.u16RxBufferSize  = 0;
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000034   0x8488             STRH     R0,[R1, #+36]
    689            SSP_Peripheral0.ppu8RxNextByte   = NULL;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   0000003C   0x6208             STR      R0,[R1, #+32]
    690            SSP_Peripheral0.u32PrivateFlags  = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable15_3
   \   00000044   0x6108             STR      R0,[R1, #+16]
    691            
    692            SSP_Peripheral1.pBaseAddress     = AT91C_BASE_US1;
   \   00000046   0x.... 0x....      LDR.W    R0,??DataTable15_15  ;; 0x40094000
   \   0000004A   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    693            SSP_Peripheral1.u8PeripheralId   = AT91C_ID_US1;
   \   00000050   0x200E             MOVS     R0,#+14
   \   00000052   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000056   0xF881 0x0028      STRB     R0,[R1, #+40]
    694            SSP_Peripheral1.pCsGpioAddress   = NULL;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000060   0x6048             STR      R0,[R1, #+4]
    695            SSP_Peripheral1.psTransmitBuffer = NULL;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000068   0x62C8             STR      R0,[R1, #+44]
    696            SSP_Peripheral1.pu8RxBuffer      = NULL;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000070   0x61C8             STR      R0,[R1, #+28]
    697            SSP_Peripheral1.u16RxBufferSize  = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000078   0x8488             STRH     R0,[R1, #+36]
    698            SSP_Peripheral1.ppu8RxNextByte   = NULL;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000080   0x6208             STR      R0,[R1, #+32]
    699            SSP_Peripheral1.u32PrivateFlags  = 0;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable15_4
   \   00000088   0x6108             STR      R0,[R1, #+16]
    700          
    701            SSP_Peripheral2.pBaseAddress     = AT91C_BASE_US2;
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable15_16  ;; 0x40098000
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   00000092   0x6008             STR      R0,[R1, #+0]
    702            SSP_Peripheral2.u8PeripheralId   = AT91C_ID_US2;
   \   00000094   0x200F             MOVS     R0,#+15
   \   00000096   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   0000009A   0xF881 0x0028      STRB     R0,[R1, #+40]
    703            SSP_Peripheral2.pCsGpioAddress   = NULL;
   \   0000009E   0x2000             MOVS     R0,#+0
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000A4   0x6048             STR      R0,[R1, #+4]
    704            SSP_Peripheral2.psTransmitBuffer = NULL;
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000AC   0x62C8             STR      R0,[R1, #+44]
    705            SSP_Peripheral2.pu8RxBuffer      = NULL;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000B4   0x61C8             STR      R0,[R1, #+28]
    706            SSP_Peripheral2.u16RxBufferSize  = 0;
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000BC   0x8488             STRH     R0,[R1, #+36]
    707            SSP_Peripheral2.ppu8RxNextByte   = NULL;
   \   000000BE   0x2000             MOVS     R0,#+0
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000C4   0x6208             STR      R0,[R1, #+32]
    708            SSP_Peripheral2.u32PrivateFlags  = 0;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x.... 0x....      LDR.W    R1,??DataTable15_6
   \   000000CC   0x6108             STR      R0,[R1, #+16]
    709          
    710            /* Init starting SSP and clear all flags */
    711            SSP_psCurrentSsp = &SSP_Peripheral0;
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   000000D2   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    712            SSP_u32Flags = 0;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x.... 0x....      LDR.W    R1,??DataTable15_18
   \   000000DE   0x6008             STR      R0,[R1, #+0]
    713            G_u32Ssp0ApplicationFlags = 0;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x.... 0x....      LDR.W    R1,??DataTable15_19
   \   000000E6   0x6008             STR      R0,[R1, #+0]
    714            G_u32Ssp1ApplicationFlags = 0;
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x.... 0x....      LDR.W    R1,??DataTable15_20
   \   000000EE   0x6008             STR      R0,[R1, #+0]
    715            G_u32Ssp2ApplicationFlags = 0;
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable15_21
   \   000000F6   0x6008             STR      R0,[R1, #+0]
    716            
    717            /* Set application pointer */
    718            Ssp_pfnStateMachine = SspSM_Idle;
   \   000000F8   0x.... 0x....      ADR.W    R0,SspSM_Idle
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable15_11
   \   00000100   0x6008             STR      R0,[R1, #+0]
    719            DebugPrintf("SSP Peripherals Ready\n\r");
   \   00000102   0x.... 0x....      LDR.W    R0,??DataTable15_22
   \   00000106   0x.... 0x....      BL       DebugPrintf
    720          
    721          } /* end SspInitialize() */
   \   0000010A   0xBD01             POP      {R0,PC}          ;; return
    722          
    723          
    724          /*!----------------------------------------------------------------------------------------------------------------------
    725          @fn void SspRunActiveState(void)
    726          
    727          @brief Selects and runs one iteration of the current state in the state machine.
    728          
    729          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    730          may take 1ms / n to execute.
    731          
    732          Requires:
    733          - State machine function pointer points at current state
    734          
    735          Promises:
    736          - Calls the function to pointed by the state machine function pointer
    737          
    738          */

   \                                 In section .text, align 2, keep-with-next
    739          void SspRunActiveState(void)
    740          {
   \                     SspRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    741            Ssp_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    742          
    743          } /* end SspRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    744          
    745          
    746          /*!----------------------------------------------------------------------------------------------------------------------
    747          @fn void SspManualMode(void)
    748          
    749          @brief Runs a transmit cycle of the SSP application to clock out a message.  This function is used only during
    750          initialization.
    751          
    752          Requires:
    753          - G_u32SystemFlags _SYSTEM_INITIALIZING is set
    754          - SSP application has been initialized.
    755          
    756          Promises:
    757          - All currently queued SSP Master transmit and receive operations are completed.
    758          
    759          */

   \                                 In section .text, align 2, keep-with-next
    760          void SspManualMode(void)
    761          {
   \                     SspManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    762            u32 u32Timer;
    763            
    764            /* Set up for manual mode */
    765            SSP_u32Flags |= _SSP_MANUAL_MODE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_18
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable15_18
   \   00000010   0x6008             STR      R0,[R1, #+0]
    766            SSP_psCurrentSsp = &SSP_Peripheral0;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000016   0x.... 0x....      LDR.W    R1,??DataTable15_17
   \   0000001A   0x6008             STR      R0,[R1, #+0]
    767          
    768            /* Run the SSP state machine so all SSP peripherals send their current message */  
    769            while(SSP_u32Flags & _SSP_MANUAL_MODE)
   \                     ??SspManualMode_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable15_18
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x07C0             LSLS     R0,R0,#+31
   \   00000024   0xD515             BPL.N    ??SspManualMode_1
    770            {
    771              WATCHDOG_BONE();
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable15_23  ;; 0xa5000001
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable15_24  ;; 0x400e1250
   \   0000002E   0x6008             STR      R0,[R1, #+0]
    772              Ssp_pfnStateMachine();
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable15_11
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x4780             BLX      R0
    773              MessagingRunActiveState();
   \   00000038   0x.... 0x....      BL       MessagingRunActiveState
    774              
    775              u32Timer = G_u32SystemTime1ms;
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable15_25
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x9000             STR      R0,[SP, #+0]
    776              while( !IsTimeUp(&u32Timer, 1) );
   \                     ??SspManualMode_2: (+1)
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       IsTimeUp
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD1E5             BNE.N    ??SspManualMode_0
   \   00000050   0xE7F8             B.N      ??SspManualMode_2
    777            }
    778                
    779          } /* end SspManualMode() */
   \                     ??SspManualMode_1: (+1)
   \   00000052   0xBD01             POP      {R0,PC}          ;; return
    780          
    781          
    782          /*!----------------------------------------------------------------------------------------------------------------------
    783          @fn ISR SSP0_IRQHandler
    784          
    785          @brief Initial handling of enabled SSP0 interrupts before generic handler. 
    786          
    787          Requires:
    788          - NONE
    789          
    790          Promises:
    791          - Global SSP ISR variables updated for SSP0
    792          - SSP_u32Int0Count incremented for debug purposes
    793          
    794          */

   \                                 In section .text, align 2, keep-with-next
    795          void SSP0_IRQHandler(void)
    796          {
   \                     SSP0_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    797            /* Set the current ISR pointers to SSP0 targets */
    798            SSP_psCurrentISR = &SSP_Peripheral0;                         
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_3
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    799            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp0ApplicationFlags; 
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_19
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   00000014   0x6008             STR      R0,[R1, #+0]
    800            SSP_u32Int0Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_28
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_28
   \   00000022   0x6008             STR      R0,[R1, #+0]
    801          
    802            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    803            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    804            
    805          } /* end SSP0_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    806          
    807          
    808          /*!----------------------------------------------------------------------------------------------------------------------
    809          @fn ISR SSP1_IRQHandler
    810          
    811          @brief Initial handling of enabled SSP1 interrupts before generic handler. 
    812          
    813          Requires:
    814          - NONE
    815          
    816          Promises:
    817          - Global SSP ISR variables updated for SSP1
    818          - SSP_u32Int1Count incremented for debug purposes
    819          
    820          */

   \                                 In section .text, align 2, keep-with-next
    821          void SSP1_IRQHandler(void)
    822          {
   \                     USART1_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    823            /* Set the current ISR pointers to SSP1 targets */
    824            SSP_psCurrentISR = &SSP_Peripheral1;                      
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_4
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    825            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp1ApplicationFlags; 
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_20
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   00000014   0x6008             STR      R0,[R1, #+0]
    826            SSP_u32Int1Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_29
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_29
   \   00000022   0x6008             STR      R0,[R1, #+0]
    827          
    828            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    829            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    830            
    831          } /* end SSP1_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    832          
    833          
    834          /*!----------------------------------------------------------------------------------------------------------------------
    835          @fn ISR SSP2_IRQHandler
    836          
    837          @brief Initial handling of enabled SSP2 interrupts before generic handler. 
    838          
    839          Requires:
    840          - NONE
    841          
    842          Promises:
    843          - Global SSP ISR variables updated for SSP2
    844          - SSP_u32Int2Count incremented for debug purposes
    845          
    846          */

   \                                 In section .text, align 2, keep-with-next
    847          void SSP2_IRQHandler(void)
    848          {
   \                     USART2_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    849            /* Set the current ISR pointers to SSP2 targets */
    850            SSP_psCurrentISR = &SSP_Peripheral2;                      
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_6
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    851            SSP_pu32SspApplicationFlagsISR = &G_u32Ssp2ApplicationFlags;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable15_21
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   00000014   0x6008             STR      R0,[R1, #+0]
    852            SSP_u32Int2Count++;
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable15_30
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable15_30
   \   00000022   0x6008             STR      R0,[R1, #+0]
    853          
    854            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    855            SspGenericHandler();
   \   00000024   0x.... 0x....      BL       SspGenericHandler
    856           
    857          } /* end SSP2_IRQHandler() */
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
    858          
    859          
    860          /*----------------------------------------------------------------------------------------------------------------------*/
    861          /*! @privatesection */                                                                                            
    862          /*----------------------------------------------------------------------------------------------------------------------*/
    863          
    864          /*!----------------------------------------------------------------------------------------------------------------------
    865          @fn static void SspGenericHandler(void)
    866          
    867          @brief Common handler for all expected SSP interrupts regardless of base peripheral
    868          
    869          CHIP SELECT: only enabled for SLAVE peripherals.  A Slave peripheral needs this 
    870          signal to know it is communicating. If it is supposed to be transmitting and does 
    871          not have any flow control, the data should already be queued to send.
    872          
    873          TXEMPTY: Transmit for Flow Control Slaves
    874          RXRDY: Receive for Flow Control Slaves
    875          
    876          ENDTX: An End Transmit interrupt will occur when the PDC has finished sending all 
    877          of the bytes for Master or Slave.
    878          
    879          ENDRX: An End Receive interrupt will occur when the PDC has finished receiving all 
    880          of the expected bytes for Master or a single byte for Slave.
    881          
    882          
    883          Requires:
    884          - SSP_psCurrentISR points to the SSP peripheral that has triggered the interrupt
    885          - SSP_pu32SspApplicationFlagsISR points to the application flags from the SSP 
    886            peripheral that triggered the interrupt
    887          - A different SSP peripheral cannot interrupt this ISR
    888          
    889          Promises:
    890          - Each interrupt has different outcomes for the system depending on the SSP mode.  
    891            See each section for more details.
    892          
    893          */

   \                                 In section .text, align 2, keep-with-next
    894          static void SspGenericHandler(void)
    895          {
   \                     SspGenericHandler: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    896            u32 u32Byte;
    897            u32 u32Timeout;
    898            u32 u32Current_CSR;
    899            
    900            /* Get a copy of CSR because reading it changes it */
    901            u32Current_CSR = SSP_psCurrentISR->pBaseAddress->US_CSR;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x6940             LDR      R0,[R0, #+20]
   \   0000000C   0x0006             MOVS     R6,R0
    902            
    903          
    904            /*** CS change state interrupt - only enabled on Slave SSP peripherals ***/
    905            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_CTSIC) && 
    906                (u32Current_CSR & AT91C_US_CTSIC) )
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x6900             LDR      R0,[R0, #+16]
   \   00000018   0x0300             LSLS     R0,R0,#+12
   \   0000001A   0xF140 0x809F      BPL.W    ??SspGenericHandler_0
   \   0000001E   0x0330             LSLS     R0,R6,#+12
   \   00000020   0xF140 0x809C      BPL.W    ??SspGenericHandler_0
    907            {
    908              /* Is the CS pin asserted now? */
    909              if( (SSP_psCurrentISR->pCsGpioAddress->PIO_PDSR & SSP_psCurrentISR->u32CsPin) == 0)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x6840             LDR      R0,[R0, #+4]
   \   0000002C   0x6BC0             LDR      R0,[R0, #+60]
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000032   0x6809             LDR      R1,[R1, #+0]
   \   00000034   0x6889             LDR      R1,[R1, #+8]
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD138             BNE.N    ??SspGenericHandler_1
    910              {
    911                /* Flag that CS is asserted and make sure TX and RX COMPLETE flags are clear */
    912                *SSP_pu32SspApplicationFlagsISR |= _SSP_CS_ASSERTED;
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   0000004A   0x6809             LDR      R1,[R1, #+0]
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    913                *SSP_pu32SspApplicationFlagsISR &= ~(_SSP_TX_COMPLETE | _SSP_RX_COMPLETE);
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF030 0x0006      BICS     R0,R0,#0x6
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x6008             STR      R0,[R1, #+0]
    914                
    915                /* If a no flow control Slave is receiving, then it should be ready to respond with dummy bytes */
    916                if(SSP_psCurrentISR->eSspMode == SSP_SLAVE)
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000066   0x6800             LDR      R0,[R0, #+0]
   \   00000068   0x7B40             LDRB     R0,[R0, #+13]
   \   0000006A   0x2802             CMP      R0,#+2
   \   0000006C   0xD10B             BNE.N    ??SspGenericHandler_2
    917                {
    918                  if(SSP_psCurrentISR->psTransmitBuffer == NULL)
   \   0000006E   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x6AC0             LDR      R0,[R0, #+44]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD105             BNE.N    ??SspGenericHandler_2
    919                  {
    920                    SSP_psCurrentISR->pBaseAddress->US_THR = SSP_DUMMY_BYTE;
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000080   0x6809             LDR      R1,[R1, #+0]
   \   00000082   0x6809             LDR      R1,[R1, #+0]
   \   00000084   0x61C8             STR      R0,[R1, #+28]
    921                  }
    922                }
    923          
    924                /* Flow control Slaves should have their RXRDY interrupt enabled */
    925                if(SSP_psCurrentISR->eSspMode == SSP_SLAVE_FLOW_CONTROL)
   \                     ??SspGenericHandler_2: (+1)
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x7B40             LDRB     R0,[R0, #+13]
   \   0000008E   0x2803             CMP      R0,#+3
   \   00000090   0xD164             BNE.N    ??SspGenericHandler_0
    926                {
    927                  SSP_psCurrentISR->pBaseAddress->US_IER |= AT91C_US_RXRDY;
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x6880             LDR      R0,[R0, #+8]
   \   0000009C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000A0   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x6809             LDR      R1,[R1, #+0]
   \   000000A8   0x6088             STR      R0,[R1, #+8]
   \   000000AA   0xE057             B.N      ??SspGenericHandler_0
    928                }
    929          
    930              }
    931              else
    932              {
    933                /* Flag that CS is deasserted */
    934                *SSP_pu32SspApplicationFlagsISR &= ~_SSP_CS_ASSERTED;
   \                     ??SspGenericHandler_1: (+1)
   \   000000AC   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x0840             LSRS     R0,R0,#+1
   \   000000B6   0x0040             LSLS     R0,R0,#+1
   \   000000B8   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    935                           
    936                /* If a transmit was interrupted, then the message needs to be aborted. */
    937                if(SSP_psCurrentISR->u32PrivateFlags & _SSP_PERIPHERAL_TX)
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x6900             LDR      R0,[R0, #+16]
   \   000000C8   0x0280             LSLS     R0,R0,#+10
   \   000000CA   0xD527             BPL.N    ??SspGenericHandler_3
    938                {
    939                  /* Clean up the message status and flags */
    940                  SSP_psCurrentISR->pBaseAddress->US_IDR = AT91C_US_ENDTX;
   \   000000CC   0x2010             MOVS     R0,#+16
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
    941                  
    942                  SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_TX;  
   \   000000D8   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x6900             LDR      R0,[R0, #+16]
   \   000000E0   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000000E8   0x6809             LDR      R1,[R1, #+0]
   \   000000EA   0x6108             STR      R0,[R1, #+16]
    943                  UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, ABANDONED);
   \   000000EC   0x2105             MOVS     R1,#+5
   \   000000EE   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x6AC0             LDR      R0,[R0, #+44]
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x.... 0x....      BL       UpdateMessageStatus
    944                  DeQueueMessage(&SSP_psCurrentISR->psTransmitBuffer);
   \   000000FC   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x302C             ADDS     R0,R0,#+44
   \   00000104   0x.... 0x....      BL       DeQueueMessage
    945             
    946                  *SSP_pu32SspApplicationFlagsISR |= _SSP_TX_COMPLETE; 
   \   00000108   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x6800             LDR      R0,[R0, #+0]
   \   00000110   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   00000118   0x6809             LDR      R1,[R1, #+0]
   \   0000011A   0x6008             STR      R0,[R1, #+0]
    947                  
    948                }
    949          
    950                /* Make sure PDC counters are reset for next transmission on Slave - no flow control devices only */
    951                if(SSP_psCurrentISR->eSspMode == SSP_SLAVE)
   \                     ??SspGenericHandler_3: (+1)
   \   0000011C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x7B40             LDRB     R0,[R0, #+13]
   \   00000124   0x2802             CMP      R0,#+2
   \   00000126   0xD10D             BNE.N    ??SspGenericHandler_4
    952                {
    953                  SSP_psCurrentISR->pBaseAddress->US_RCR = 1;
   \   00000128   0x2001             MOVS     R0,#+1
   \   0000012A   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000012E   0x6809             LDR      R1,[R1, #+0]
   \   00000130   0x6809             LDR      R1,[R1, #+0]
   \   00000132   0xF8C1 0x0104      STR      R0,[R1, #+260]
    954                  SSP_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000013C   0x6809             LDR      R1,[R1, #+0]
   \   0000013E   0x6809             LDR      R1,[R1, #+0]
   \   00000140   0xF8C1 0x0114      STR      R0,[R1, #+276]
    955                }
    956          
    957                /* Special case for an interrupted flow control mode */
    958                if(SSP_psCurrentISR->eSspMode == SSP_SLAVE_FLOW_CONTROL)
   \                     ??SspGenericHandler_4: (+1)
   \   00000144   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x7B40             LDRB     R0,[R0, #+13]
   \   0000014C   0x2803             CMP      R0,#+3
   \   0000014E   0xD105             BNE.N    ??SspGenericHandler_0
    959                {
    960                  /* Re-enable Rx interrupt, clean-up the operation */    
    961                  SSP_psCurrentISR->pBaseAddress->US_IER = AT91C_US_RXRDY;
   \   00000150   0x2001             MOVS     R0,#+1
   \   00000152   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000156   0x6809             LDR      R1,[R1, #+0]
   \   00000158   0x6809             LDR      R1,[R1, #+0]
   \   0000015A   0x6088             STR      R0,[R1, #+8]
    962                }
    963                
    964              } /* end of CS de-asserted */
    965              
    966            } /* end CS change state interrupt */
    967          
    968            
    969            /*** SSP ISR transmit handling for flow-control devices that do not use DMA ***/
    970            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_TXEMPTY) && 
    971                (u32Current_CSR & AT91C_US_TXEMPTY) )
   \                     ??SspGenericHandler_0: (+1)
   \   0000015C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000160   0x6800             LDR      R0,[R0, #+0]
   \   00000162   0x6800             LDR      R0,[R0, #+0]
   \   00000164   0x6900             LDR      R0,[R0, #+16]
   \   00000166   0x0580             LSLS     R0,R0,#+22
   \   00000168   0xD56B             BPL.N    ??SspGenericHandler_5
   \   0000016A   0x05B0             LSLS     R0,R6,#+22
   \   0000016C   0xD569             BPL.N    ??SspGenericHandler_5
    972            {
    973              /* Decrement counter and read the dummy byte so the SSP peripheral doesn't overrun */
    974              SSP_psCurrentISR->u32CurrentTxBytesRemaining--;
   \   0000016E   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000172   0x6800             LDR      R0,[R0, #+0]
   \   00000174   0x6B00             LDR      R0,[R0, #+48]
   \   00000176   0x1E40             SUBS     R0,R0,#+1
   \   00000178   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000017C   0x6809             LDR      R1,[R1, #+0]
   \   0000017E   0x6308             STR      R0,[R1, #+48]
    975              u32Byte = SSP_psCurrentISR->pBaseAddress->US_RHR;
   \   00000180   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000184   0x6800             LDR      R0,[R0, #+0]
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x6980             LDR      R0,[R0, #+24]
   \   0000018A   0x0004             MOVS     R4,R0
    976              
    977              if(SSP_psCurrentISR->u32CurrentTxBytesRemaining != 0)
   \   0000018C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000190   0x6800             LDR      R0,[R0, #+0]
   \   00000192   0x6B00             LDR      R0,[R0, #+48]
   \   00000194   0x2800             CMP      R0,#+0
   \   00000196   0xD020             BEQ.N    ??SspGenericHandler_6
    978              {
    979                /* Advance the pointer (non-circular buffer), load the next byte and use the callback */
    980                SSP_psCurrentISR->pu8CurrentTxData++;
   \   00000198   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000019C   0x6800             LDR      R0,[R0, #+0]
   \   0000019E   0x6B40             LDR      R0,[R0, #+52]
   \   000001A0   0x1C40             ADDS     R0,R0,#+1
   \   000001A2   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000001A6   0x6809             LDR      R1,[R1, #+0]
   \   000001A8   0x6348             STR      R0,[R1, #+52]
    981                u32Byte = 0x000000FF & *SSP_psCurrentISR->pu8CurrentTxData;
   \   000001AA   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000001AE   0x6800             LDR      R0,[R0, #+0]
   \   000001B0   0x6B40             LDR      R0,[R0, #+52]
   \   000001B2   0x7800             LDRB     R0,[R0, #+0]
   \   000001B4   0x0004             MOVS     R4,R0
    982          
    983                /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
    984                if(SSP_psCurrentISR->eBitOrder == SSP_LSB_FIRST)
   \   000001B6   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000001BA   0x6800             LDR      R0,[R0, #+0]
   \   000001BC   0x7B00             LDRB     R0,[R0, #+12]
   \   000001BE   0x2801             CMP      R0,#+1
   \   000001C0   0xD103             BNE.N    ??SspGenericHandler_7
    985                {
    986                  u32Byte = __RBIT(u32Byte) >> 24;
   \   000001C2   0xFA94 0xF0A4      RBIT     R0,R4
   \   000001C6   0x0E00             LSRS     R0,R0,#+24
   \   000001C8   0x0004             MOVS     R4,R0
    987                }
    988              
    989                /* Clear interrupt flag */
    990                SSP_psCurrentISR->pBaseAddress->US_THR = (u8)u32Byte; 
   \                     ??SspGenericHandler_7: (+1)
   \   000001CA   0x0020             MOVS     R0,R4
   \   000001CC   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   000001CE   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000001D2   0x6809             LDR      R1,[R1, #+0]
   \   000001D4   0x6809             LDR      R1,[R1, #+0]
   \   000001D6   0x61C8             STR      R0,[R1, #+28]
   \   000001D8   0xE02E             B.N      ??SspGenericHandler_8
    991              }
    992              else
    993              {
    994                /* Done! Disable TX interrupt */
    995                SSP_psCurrentISR->pBaseAddress->US_IDR = AT91C_US_TXEMPTY;
   \                     ??SspGenericHandler_6: (+1)
   \   000001DA   0xF44F 0x7000      MOV      R0,#+512
   \   000001DE   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000001E2   0x6809             LDR      R1,[R1, #+0]
   \   000001E4   0x6809             LDR      R1,[R1, #+0]
   \   000001E6   0x60C8             STR      R0,[R1, #+12]
    996                
    997                /* Clean up the message status and flags */
    998                *SSP_pu32SspApplicationFlagsISR |= _SSP_TX_COMPLETE; 
   \   000001E8   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   000001EC   0x6800             LDR      R0,[R0, #+0]
   \   000001EE   0x6800             LDR      R0,[R0, #+0]
   \   000001F0   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   000001F4   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   000001F8   0x6809             LDR      R1,[R1, #+0]
   \   000001FA   0x6008             STR      R0,[R1, #+0]
    999                UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   000001FC   0x2103             MOVS     R1,#+3
   \   000001FE   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000202   0x6800             LDR      R0,[R0, #+0]
   \   00000204   0x6AC0             LDR      R0,[R0, #+44]
   \   00000206   0x6800             LDR      R0,[R0, #+0]
   \   00000208   0x.... 0x....      BL       UpdateMessageStatus
   1000                DeQueueMessage(&SSP_psCurrentISR->psTransmitBuffer);
   \   0000020C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000210   0x6800             LDR      R0,[R0, #+0]
   \   00000212   0x302C             ADDS     R0,R0,#+44
   \   00000214   0x.... 0x....      BL       DeQueueMessage
   1001                SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_TX;  
   \   00000218   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000021C   0x6800             LDR      R0,[R0, #+0]
   \   0000021E   0x6900             LDR      R0,[R0, #+16]
   \   00000220   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000224   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000228   0x6809             LDR      R1,[R1, #+0]
   \   0000022A   0x6108             STR      R0,[R1, #+16]
   1002           
   1003                /* Re-enable Rx interrupt and make final call to callback */    
   1004                SSP_psCurrentISR->pBaseAddress->US_IER = AT91C_US_RXRDY;
   \   0000022C   0x2001             MOVS     R0,#+1
   \   0000022E   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000232   0x6809             LDR      R1,[R1, #+0]
   \   00000234   0x6809             LDR      R1,[R1, #+0]
   \   00000236   0x6088             STR      R0,[R1, #+8]
   1005              }
   1006              
   1007              /* Both cases use the callback */
   1008              SSP_psCurrentISR->fnSlaveTxFlowCallback();
   \                     ??SspGenericHandler_8: (+1)
   \   00000238   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000023C   0x6800             LDR      R0,[R0, #+0]
   \   0000023E   0x6940             LDR      R0,[R0, #+20]
   \   00000240   0x4780             BLX      R0
   1009              
   1010            } /* end AT91C_US_TXEMPTY */
   1011            
   1012            
   1013            /*** SSP ISR handling for Slave Rx with flow control (no DMA) ***/
   1014            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_RXRDY) && 
   1015                (SSP_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_RXRDY) )
   \                     ??SspGenericHandler_5: (+1)
   \   00000242   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000246   0x6800             LDR      R0,[R0, #+0]
   \   00000248   0x6800             LDR      R0,[R0, #+0]
   \   0000024A   0x6900             LDR      R0,[R0, #+16]
   \   0000024C   0x07C0             LSLS     R0,R0,#+31
   \   0000024E   0xD537             BPL.N    ??SspGenericHandler_9
   \   00000250   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000254   0x6800             LDR      R0,[R0, #+0]
   \   00000256   0x6800             LDR      R0,[R0, #+0]
   \   00000258   0x6940             LDR      R0,[R0, #+20]
   \   0000025A   0x07C0             LSLS     R0,R0,#+31
   \   0000025C   0xD530             BPL.N    ??SspGenericHandler_9
   1016            {
   1017              /* Pull the byte out of the receive register into the Rx buffer */
   1018              u32Byte = 0x000000FF & SSP_psCurrentISR->pBaseAddress->US_RHR;
   \   0000025E   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000262   0x6800             LDR      R0,[R0, #+0]
   \   00000264   0x6800             LDR      R0,[R0, #+0]
   \   00000266   0x6980             LDR      R0,[R0, #+24]
   \   00000268   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000026A   0x0004             MOVS     R4,R0
   1019          
   1020              /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
   1021              if(SSP_psCurrentISR->eBitOrder == SSP_LSB_FIRST)
   \   0000026C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000270   0x6800             LDR      R0,[R0, #+0]
   \   00000272   0x7B00             LDRB     R0,[R0, #+12]
   \   00000274   0x2801             CMP      R0,#+1
   \   00000276   0xD103             BNE.N    ??SspGenericHandler_10
   1022              {
   1023                u32Byte = __RBIT(u32Byte)>>24;
   \   00000278   0xFA94 0xF0A4      RBIT     R0,R4
   \   0000027C   0x0E00             LSRS     R0,R0,#+24
   \   0000027E   0x0004             MOVS     R4,R0
   1024              }
   1025              
   1026              /* DEBUG */
   1027              if((u8)u32Byte == 0xff)
   \                     ??SspGenericHandler_10: (+1)
   \   00000280   0x0020             MOVS     R0,R4
   \   00000282   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000284   0x28FF             CMP      R0,#+255
   \   00000286   0xD106             BNE.N    ??SspGenericHandler_11
   1028              {
   1029                SSP_u32AntCounter++;
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable15_31
   \   0000028C   0x6800             LDR      R0,[R0, #+0]
   \   0000028E   0x1C40             ADDS     R0,R0,#+1
   \   00000290   0x.... 0x....      LDR.W    R1,??DataTable15_31
   \   00000294   0x6008             STR      R0,[R1, #+0]
   1030              }
   1031              
   1032              /* Send the byte to the Rx buffer; since we only do one byte at a time in this mode, then _SSP_RX_COMPLETE */
   1033              **(SSP_psCurrentISR->ppu8RxNextByte) = (u8)u32Byte;
   \                     ??SspGenericHandler_11: (+1)
   \   00000296   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000029A   0x6800             LDR      R0,[R0, #+0]
   \   0000029C   0x6A00             LDR      R0,[R0, #+32]
   \   0000029E   0x6800             LDR      R0,[R0, #+0]
   \   000002A0   0x7004             STRB     R4,[R0, #+0]
   1034              *SSP_pu32SspApplicationFlagsISR |= _SSP_RX_COMPLETE;
   \   000002A2   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   000002A6   0x6800             LDR      R0,[R0, #+0]
   \   000002A8   0x6800             LDR      R0,[R0, #+0]
   \   000002AA   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000002AE   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   000002B2   0x6809             LDR      R1,[R1, #+0]
   \   000002B4   0x6008             STR      R0,[R1, #+0]
   1035          
   1036              /* Invoke callback */
   1037              SSP_psCurrentISR->fnSlaveRxFlowCallback();
   \   000002B6   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000002BA   0x6800             LDR      R0,[R0, #+0]
   \   000002BC   0x6980             LDR      R0,[R0, #+24]
   \   000002BE   0x4780             BLX      R0
   1038            } /* end of receive with flow control */
   1039          
   1040            
   1041            /*** SSP ISR responses for non-flow control devices that use DMA (Master or Slave) ***/
   1042              
   1043            /* ENDRX Interrupt when all requested bytes have been received */
   1044            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
   1045                (u32Current_CSR & AT91C_US_ENDRX) )
   \                     ??SspGenericHandler_9: (+1)
   \   000002C0   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000002C4   0x6800             LDR      R0,[R0, #+0]
   \   000002C6   0x6800             LDR      R0,[R0, #+0]
   \   000002C8   0x6900             LDR      R0,[R0, #+16]
   \   000002CA   0x0700             LSLS     R0,R0,#+28
   \   000002CC   0xF140 0x8082      BPL.W    ??SspGenericHandler_12
   \   000002D0   0x0730             LSLS     R0,R6,#+28
   \   000002D2   0xF140 0x807F      BPL.W    ??SspGenericHandler_12
   1046            {
   1047              /* Master mode and Slave mode operate differently */
   1048              if( (SSP_psCurrentISR->eSspMode == SSP_MASTER_AUTO_CS) ||
   1049                  (SSP_psCurrentISR->eSspMode == SSP_MASTER_MANUAL_CS) ) 
   \   000002D6   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000002DA   0x6800             LDR      R0,[R0, #+0]
   \   000002DC   0x7B40             LDRB     R0,[R0, #+13]
   \   000002DE   0x2800             CMP      R0,#+0
   \   000002E0   0xD005             BEQ.N    ??SspGenericHandler_13
   \   000002E2   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000002E6   0x6800             LDR      R0,[R0, #+0]
   \   000002E8   0x7B40             LDRB     R0,[R0, #+13]
   \   000002EA   0x2801             CMP      R0,#+1
   \   000002EC   0xD13D             BNE.N    ??SspGenericHandler_14
   1050              {
   1051                /* Reset the byte counter and clear the RX flag */
   1052                SSP_psCurrentISR->u16RxBytes = 0;
   \                     ??SspGenericHandler_13: (+1)
   \   000002EE   0x2000             MOVS     R0,#+0
   \   000002F0   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000002F4   0x6809             LDR      R1,[R1, #+0]
   \   000002F6   0x84C8             STRH     R0,[R1, #+38]
   1053                SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_RX;
   \   000002F8   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   000002FC   0x6800             LDR      R0,[R0, #+0]
   \   000002FE   0x6900             LDR      R0,[R0, #+16]
   \   00000300   0xF430 0x0080      BICS     R0,R0,#0x400000
   \   00000304   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000308   0x6809             LDR      R1,[R1, #+0]
   \   0000030A   0x6108             STR      R0,[R1, #+16]
   1054                SSP_psCurrentISR->u32PrivateFlags |=  _SSP_PERIPHERAL_RX_COMPLETE;
   \   0000030C   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000310   0x6800             LDR      R0,[R0, #+0]
   \   00000312   0x6900             LDR      R0,[R0, #+16]
   \   00000314   0xF450 0x0000      ORRS     R0,R0,#0x800000
   \   00000318   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   0000031C   0x6809             LDR      R1,[R1, #+0]
   \   0000031E   0x6108             STR      R0,[R1, #+16]
   1055                SSP_u32RxCounter++;
   \   00000320   0x.... 0x....      LDR.W    R0,??DataTable15_32
   \   00000324   0x6800             LDR      R0,[R0, #+0]
   \   00000326   0x1C40             ADDS     R0,R0,#+1
   \   00000328   0x.... 0x....      LDR.W    R1,??DataTable15_32
   \   0000032C   0x6008             STR      R0,[R1, #+0]
   1056                
   1057                /* Deassert CS for SSP_MASTER_AUTO_CS transfers */
   1058                if(SSP_psCurrentSsp->eSspMode == SSP_MASTER_AUTO_CS)
   \   0000032E   0x.... 0x....      LDR.W    R0,??DataTable15_17
   \   00000332   0x6800             LDR      R0,[R0, #+0]
   \   00000334   0x7B40             LDRB     R0,[R0, #+13]
   \   00000336   0x2800             CMP      R0,#+0
   \   00000338   0xD108             BNE.N    ??SspGenericHandler_15
   1059                {
   1060                  SSP_psCurrentISR->pCsGpioAddress->PIO_SODR = SSP_psCurrentISR->u32CsPin;
   \   0000033A   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000033E   0x6800             LDR      R0,[R0, #+0]
   \   00000340   0x6880             LDR      R0,[R0, #+8]
   \   00000342   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000346   0x6809             LDR      R1,[R1, #+0]
   \   00000348   0x6849             LDR      R1,[R1, #+4]
   \   0000034A   0x6308             STR      R0,[R1, #+48]
   1061                }
   1062               
   1063                /* Disable the receiver and transmitter */
   1064                SSP_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS;
   \                     ??SspGenericHandler_15: (+1)
   \   0000034C   0xF240 0x2002      MOVW     R0,#+514
   \   00000350   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000354   0x6809             LDR      R1,[R1, #+0]
   \   00000356   0x6809             LDR      R1,[R1, #+0]
   \   00000358   0xF8C1 0x0120      STR      R0,[R1, #+288]
   1065                SSP_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDRX;
   \   0000035C   0x2008             MOVS     R0,#+8
   \   0000035E   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000362   0x6809             LDR      R1,[R1, #+0]
   \   00000364   0x6809             LDR      R1,[R1, #+0]
   \   00000366   0x60C8             STR      R0,[R1, #+12]
   \   00000368   0xE034             B.N      ??SspGenericHandler_12
   1066              }
   1067              /* Otherwise the peripheral is a Slave that just received a byte */
   1068              /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR))*/
   1069              else
   1070              {
   1071                /* Flag that a byte has arrived */
   1072                *SSP_pu32SspApplicationFlagsISR |= _SSP_RX_COMPLETE;
   \                     ??SspGenericHandler_14: (+1)
   \   0000036A   0x.... 0x....      LDR.W    R0,??DataTable15_27
   \   0000036E   0x6800             LDR      R0,[R0, #+0]
   \   00000370   0x6800             LDR      R0,[R0, #+0]
   \   00000372   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000376   0x.... 0x....      LDR.W    R1,??DataTable15_27
   \   0000037A   0x6809             LDR      R1,[R1, #+0]
   \   0000037C   0x6008             STR      R0,[R1, #+0]
   1073          
   1074                /* Update the pointer to the next valid Rx location (always leap-frogs the immediate 
   1075                next byte since it will be filled by the other DMA process) */
   1076                SSP_psCurrentISR->pBaseAddress->US_RNPR++;
   \   0000037E   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   00000382   0x6800             LDR      R0,[R0, #+0]
   \   00000384   0x6800             LDR      R0,[R0, #+0]
   \   00000386   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   0000038A   0x1C40             ADDS     R0,R0,#+1
   \   0000038C   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   00000390   0x6809             LDR      R1,[R1, #+0]
   \   00000392   0x6809             LDR      R1,[R1, #+0]
   \   00000394   0xF8C1 0x0110      STR      R0,[R1, #+272]
   1077                if(SSP_psCurrentISR->pBaseAddress->US_RPR == (u32)(SSP_psCurrentISR->pu8RxBuffer + (u32)SSP_psCurrentISR->u16RxBufferSize) )
   \   00000398   0x.... 0x....      LDR.W    R0,??DataTable15_26
   \   0000039C   0x6800             LDR      R0,[R0, #+0]
   \   0000039E   0x6800             LDR      R0,[R0, #+0]
   \   000003A0   0xF8D0 0x0100      LDR      R0,[R0, #+256]
   \   000003A4   0x.... 0x....      LDR.W    R1,??DataTable15_26
   \   000003A8   0x6809             LDR      R1,[R1, #+0]
   \   000003AA   0x69C9             LDR      R1,[R1, #+28]
   \   000003AC   0x....             LDR.N    R2,??DataTable15_26
   \   000003AE   0x6812             LDR      R2,[R2, #+0]
   \   000003B0   0x8C92             LDRH     R2,[R2, #+36]
   \   000003B2   0x1851             ADDS     R1,R2,R1
   \   000003B4   0x4288             CMP      R0,R1
   \   000003B6   0xD107             BNE.N    ??SspGenericHandler_16
   1078                {
   1079                  SSP_psCurrentISR->pBaseAddress->US_RPR = (u32)SSP_psCurrentISR->pu8RxBuffer;  
   \   000003B8   0x....             LDR.N    R0,??DataTable15_26
   \   000003BA   0x6800             LDR      R0,[R0, #+0]
   \   000003BC   0x69C0             LDR      R0,[R0, #+28]
   \   000003BE   0x....             LDR.N    R1,??DataTable15_26
   \   000003C0   0x6809             LDR      R1,[R1, #+0]
   \   000003C2   0x6809             LDR      R1,[R1, #+0]
   \   000003C4   0xF8C1 0x0100      STR      R0,[R1, #+256]
   1080                }
   1081                
   1082                /* Write RNCR to 1 to clear the ENDRX flag */
   1083                SSP_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \                     ??SspGenericHandler_16: (+1)
   \   000003C8   0x2001             MOVS     R0,#+1
   \   000003CA   0x....             LDR.N    R1,??DataTable15_26
   \   000003CC   0x6809             LDR      R1,[R1, #+0]
   \   000003CE   0x6809             LDR      R1,[R1, #+0]
   \   000003D0   0xF8C1 0x0114      STR      R0,[R1, #+276]
   1084              }  
   1085            } /* end ENDRX handling */
   1086          
   1087          
   1088            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
   1089            if( (SSP_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
   1090                (u32Current_CSR & AT91C_US_ENDTX) )
   \                     ??SspGenericHandler_12: (+1)
   \   000003D4   0x....             LDR.N    R0,??DataTable15_26
   \   000003D6   0x6800             LDR      R0,[R0, #+0]
   \   000003D8   0x6800             LDR      R0,[R0, #+0]
   \   000003DA   0x6900             LDR      R0,[R0, #+16]
   \   000003DC   0x06C0             LSLS     R0,R0,#+27
   \   000003DE   0xD548             BPL.N    ??SspGenericHandler_17
   \   000003E0   0x06F0             LSLS     R0,R6,#+27
   \   000003E2   0xD546             BPL.N    ??SspGenericHandler_17
   1091            {
   1092              /* If this was a non-dummy transmit... */
   1093              if(SSP_psCurrentISR->u32PrivateFlags & _SSP_PERIPHERAL_TX)
   \   000003E4   0x....             LDR.N    R0,??DataTable15_26
   \   000003E6   0x6800             LDR      R0,[R0, #+0]
   \   000003E8   0x6900             LDR      R0,[R0, #+16]
   \   000003EA   0x0280             LSLS     R0,R0,#+10
   \   000003EC   0xD513             BPL.N    ??SspGenericHandler_18
   1094              {
   1095                /* Update this message token status and then DeQueue it */
   1096                UpdateMessageStatus(SSP_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   000003EE   0x2103             MOVS     R1,#+3
   \   000003F0   0x....             LDR.N    R0,??DataTable15_26
   \   000003F2   0x6800             LDR      R0,[R0, #+0]
   \   000003F4   0x6AC0             LDR      R0,[R0, #+44]
   \   000003F6   0x6800             LDR      R0,[R0, #+0]
   \   000003F8   0x.... 0x....      BL       UpdateMessageStatus
   1097                DeQueueMessage(&SSP_psCurrentISR->psTransmitBuffer);
   \   000003FC   0x....             LDR.N    R0,??DataTable15_26
   \   000003FE   0x6800             LDR      R0,[R0, #+0]
   \   00000400   0x302C             ADDS     R0,R0,#+44
   \   00000402   0x.... 0x....      BL       DeQueueMessage
   1098                SSP_psCurrentISR->u32PrivateFlags &= ~_SSP_PERIPHERAL_TX;
   \   00000406   0x....             LDR.N    R0,??DataTable15_26
   \   00000408   0x6800             LDR      R0,[R0, #+0]
   \   0000040A   0x6900             LDR      R0,[R0, #+16]
   \   0000040C   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   00000410   0x....             LDR.N    R1,??DataTable15_26
   \   00000412   0x6809             LDR      R1,[R1, #+0]
   \   00000414   0x6108             STR      R0,[R1, #+16]
   1099              }
   1100           
   1101              /* Master devices: Disable the transmitter and interrupt source. 
   1102              No action for Slave devices as the PDC pointers are already reset back to 
   1103              SSP_u8Dummies due to the "Next" PDC registers and the transmitter stays on.
   1104              Flow control Slaves do not use PDC and thus will not generate this interrupt. */
   1105              if( (SSP_psCurrentISR->eSspMode == SSP_MASTER_AUTO_CS) ||
   1106                  (SSP_psCurrentISR->eSspMode == SSP_MASTER_MANUAL_CS) )
   \                     ??SspGenericHandler_18: (+1)
   \   00000416   0x....             LDR.N    R0,??DataTable15_26
   \   00000418   0x6800             LDR      R0,[R0, #+0]
   \   0000041A   0x7B40             LDRB     R0,[R0, #+13]
   \   0000041C   0x2800             CMP      R0,#+0
   \   0000041E   0xD004             BEQ.N    ??SspGenericHandler_19
   \   00000420   0x....             LDR.N    R0,??DataTable15_26
   \   00000422   0x6800             LDR      R0,[R0, #+0]
   \   00000424   0x7B40             LDRB     R0,[R0, #+13]
   \   00000426   0x2801             CMP      R0,#+1
   \   00000428   0xD10B             BNE.N    ??SspGenericHandler_20
   1107              {
   1108                SSP_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \                     ??SspGenericHandler_19: (+1)
   \   0000042A   0xF44F 0x7000      MOV      R0,#+512
   \   0000042E   0x....             LDR.N    R1,??DataTable15_26
   \   00000430   0x6809             LDR      R1,[R1, #+0]
   \   00000432   0x6809             LDR      R1,[R1, #+0]
   \   00000434   0xF8C1 0x0120      STR      R0,[R1, #+288]
   1109                SSP_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \   00000438   0x2010             MOVS     R0,#+16
   \   0000043A   0x....             LDR.N    R1,??DataTable15_26
   \   0000043C   0x6809             LDR      R1,[R1, #+0]
   \   0000043E   0x6809             LDR      R1,[R1, #+0]
   \   00000440   0x60C8             STR      R0,[R1, #+12]
   1110              }
   1111          
   1112              /* Allow the peripheral to finish clocking out the Tx byte */
   1113              u32Timeout = 0;
   \                     ??SspGenericHandler_20: (+1)
   \   00000442   0x2000             MOVS     R0,#+0
   \   00000444   0x0005             MOVS     R5,R0
   1114              while ( !(SSP_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_TXEMPTY) && 
   1115                      u32Timeout < SSP_TXEMPTY_TIMEOUT)
   \                     ??SspGenericHandler_21: (+1)
   \   00000446   0x....             LDR.N    R0,??DataTable15_26
   \   00000448   0x6800             LDR      R0,[R0, #+0]
   \   0000044A   0x6800             LDR      R0,[R0, #+0]
   \   0000044C   0x6940             LDR      R0,[R0, #+20]
   \   0000044E   0x0580             LSLS     R0,R0,#+22
   \   00000450   0xD403             BMI.N    ??SspGenericHandler_22
   \   00000452   0x2D64             CMP      R5,#+100
   \   00000454   0xD201             BCS.N    ??SspGenericHandler_22
   1116              {
   1117                u32Timeout++;
   \   00000456   0x1C6D             ADDS     R5,R5,#+1
   \   00000458   0xE7F5             B.N      ??SspGenericHandler_21
   1118              } 
   1119              
   1120              /* Deassert chip select when the buffer and shift register are totally empty */
   1121              if(SSP_psCurrentSsp->eSspMode == SSP_MASTER_AUTO_CS)
   \                     ??SspGenericHandler_22: (+1)
   \   0000045A   0x....             LDR.N    R0,??DataTable15_17
   \   0000045C   0x6800             LDR      R0,[R0, #+0]
   \   0000045E   0x7B40             LDRB     R0,[R0, #+13]
   \   00000460   0x2800             CMP      R0,#+0
   \   00000462   0xD106             BNE.N    ??SspGenericHandler_17
   1122              {
   1123                SSP_psCurrentISR->pCsGpioAddress->PIO_SODR = SSP_psCurrentISR->u32CsPin;
   \   00000464   0x....             LDR.N    R0,??DataTable15_26
   \   00000466   0x6800             LDR      R0,[R0, #+0]
   \   00000468   0x6880             LDR      R0,[R0, #+8]
   \   0000046A   0x....             LDR.N    R1,??DataTable15_26
   \   0000046C   0x6809             LDR      R1,[R1, #+0]
   \   0000046E   0x6849             LDR      R1,[R1, #+4]
   \   00000470   0x6308             STR      R0,[R1, #+48]
   1124              }
   1125              
   1126            } /* end ENDTX interrupt handling */
   1127          
   1128            
   1129          } /* end SspGenericHandler() */
   \                     ??SspGenericHandler_17: (+1)
   \   00000472   0xBD70             POP      {R4-R6,PC}       ;; return
   1130          
   1131          
   1132          /***********************************************************************************************************************
   1133          State Machine Function Definitions
   1134          
   1135          The SSP state machine monitors messaging activity on the available SSP Master peripherals.  
   1136          It manages all SSP outgoing  messages and will transmit any message that has been queued.  
   1137          All configured SSP peripherals can be transmitting and receiving simultaneously.
   1138          ***********************************************************************************************************************/
   1139          
   1140          /*!-------------------------------------------------------------------------------------------------------------------
   1141          @fn static void SspSM_Idle(void)
   1142          
   1143          @brief Wait for a transmit message to be queued -- this can include a dummy transmission to 
   1144          receive bytes.
   1145          Half duplex transmissions are always assumed. Check one peripheral per iteration. 
   1146          
   1147          */

   \                                 In section .text, align 4, keep-with-next
   1148          static void SspSM_Idle(void)
   1149          {
   \                     SspSM_Idle: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1150            u32 u32Byte;
   1151            
   1152            /* Check all SPI/SSP peripherals for message activity or skip the current peripheral 
   1153            if it is already busy.
   1154            Slave devices receive outside of the state machine.
   1155            For Master devices sending a message, SSP_psCurrentSsp->psTransmitBuffer->pu8Message will 
   1156            point to the application transmit buffer.
   1157            For Master devices receiving a message, SSP_psCurrentSsp->u16RxBytes will != 0. Dummy bytes 
   1158            are sent. */
   1159            if( ( (SSP_psCurrentSsp->psTransmitBuffer != NULL) || (SSP_psCurrentSsp->u16RxBytes !=0) ) && 
   1160               !(SSP_psCurrentSsp->u32PrivateFlags & (_SSP_PERIPHERAL_TX | _SSP_PERIPHERAL_RX)       ) 
   1161              )
   \   00000002   0x....             LDR.N    R0,??DataTable15_17
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6AC0             LDR      R0,[R0, #+44]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD105             BNE.N    ??SspSM_Idle_0
   \   0000000C   0x....             LDR.N    R0,??DataTable15_17
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x8CC0             LDRH     R0,[R0, #+38]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xF000 0x80C7      BEQ.W    ??SspSM_Idle_1
   \                     ??SspSM_Idle_0: (+1)
   \   00000018   0x....             LDR.N    R0,??DataTable15_17
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6900             LDR      R0,[R0, #+16]
   \   0000001E   0xF410 0x0FC0      TST      R0,#0x600000
   \   00000022   0xF040 0x80C0      BNE.W    ??SspSM_Idle_1
   1162            {
   1163              /* For an SSP_MASTER_AUTO_CS device, start by asserting chip select 
   1164             (SSP_MASTER_MANUAL_CS devices should already have asserted CS in the user's task) */
   1165              if(SSP_psCurrentSsp->eSspMode == SSP_MASTER_AUTO_CS)
   \   00000026   0x....             LDR.N    R0,??DataTable15_17
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x7B40             LDRB     R0,[R0, #+13]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD106             BNE.N    ??SspSM_Idle_2
   1166              {
   1167                SSP_psCurrentSsp->pCsGpioAddress->PIO_CODR = SSP_psCurrentSsp->u32CsPin;
   \   00000030   0x....             LDR.N    R0,??DataTable15_17
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x6880             LDR      R0,[R0, #+8]
   \   00000036   0x....             LDR.N    R1,??DataTable15_17
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6849             LDR      R1,[R1, #+4]
   \   0000003C   0x6348             STR      R0,[R1, #+52]
   1168              }
   1169                 
   1170              /* Check if the message is receiving based on expected byte count */
   1171              if(SSP_psCurrentSsp->u16RxBytes !=0)
   \                     ??SspSM_Idle_2: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable15_17
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x8CC0             LDRH     R0,[R0, #+38]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD040             BEQ.N    ??SspSM_Idle_3
   1172              {
   1173                /* Receiving: flag that the peripheral is now busy */
   1174                SSP_psCurrentSsp->u32PrivateFlags |= _SSP_PERIPHERAL_RX;    
   \   00000048   0x....             LDR.N    R0,??DataTable15_17
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x6900             LDR      R0,[R0, #+16]
   \   0000004E   0xF450 0x0080      ORRS     R0,R0,#0x400000
   \   00000052   0x....             LDR.N    R1,??DataTable15_17
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x6108             STR      R0,[R1, #+16]
   1175                
   1176                /* Initialize the receive buffer so we can see data changes but also so we send
   1177                predictable dummy bytes since we'll point to this buffer to source the transmit dummies */
   1178                memset(SSP_psCurrentSsp->pu8RxBuffer, SSP_DUMMY_BYTE, SSP_psCurrentSsp->u16RxBufferSize);
   \   00000058   0x....             LDR.N    R0,??DataTable15_17
   \   0000005A   0x6800             LDR      R0,[R0, #+0]
   \   0000005C   0x8C85             LDRH     R5,[R0, #+36]
   \   0000005E   0x2600             MOVS     R6,#+0
   \   00000060   0x....             LDR.N    R0,??DataTable15_17
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x69C7             LDR      R7,[R0, #+28]
   \   00000066   0x0032             MOVS     R2,R6
   \   00000068   0x0029             MOVS     R1,R5
   \   0000006A   0x0038             MOVS     R0,R7
   \   0000006C   0x.... 0x....      BL       __aeabi_memset
   1179          
   1180                /* Load the PDC counter and pointer registers */
   1181                SSP_psCurrentSsp->pBaseAddress->US_RPR = (unsigned int)SSP_psCurrentSsp->pu8RxBuffer; 
   \   00000070   0x....             LDR.N    R0,??DataTable15_17
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x69C0             LDR      R0,[R0, #+28]
   \   00000076   0x....             LDR.N    R1,??DataTable15_17
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0xF8C1 0x0100      STR      R0,[R1, #+256]
   1182                SSP_psCurrentSsp->pBaseAddress->US_TPR = (unsigned int)SSP_psCurrentSsp->pu8RxBuffer; 
   \   00000080   0x....             LDR.N    R0,??DataTable15_17
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x69C0             LDR      R0,[R0, #+28]
   \   00000086   0x....             LDR.N    R1,??DataTable15_17
   \   00000088   0x6809             LDR      R1,[R1, #+0]
   \   0000008A   0x6809             LDR      R1,[R1, #+0]
   \   0000008C   0xF8C1 0x0108      STR      R0,[R1, #+264]
   1183                SSP_psCurrentSsp->pBaseAddress->US_RCR = SSP_psCurrentSsp->u16RxBytes;
   \   00000090   0x....             LDR.N    R0,??DataTable15_17
   \   00000092   0x6800             LDR      R0,[R0, #+0]
   \   00000094   0x8CC0             LDRH     R0,[R0, #+38]
   \   00000096   0x....             LDR.N    R1,??DataTable15_17
   \   00000098   0x6809             LDR      R1,[R1, #+0]
   \   0000009A   0x6809             LDR      R1,[R1, #+0]
   \   0000009C   0xF8C1 0x0104      STR      R0,[R1, #+260]
   1184                SSP_psCurrentSsp->pBaseAddress->US_TCR = SSP_psCurrentSsp->u16RxBytes;
   \   000000A0   0x....             LDR.N    R0,??DataTable15_17
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x8CC0             LDRH     R0,[R0, #+38]
   \   000000A6   0x....             LDR.N    R1,??DataTable15_17
   \   000000A8   0x6809             LDR      R1,[R1, #+0]
   \   000000AA   0x6809             LDR      R1,[R1, #+0]
   \   000000AC   0xF8C1 0x010C      STR      R0,[R1, #+268]
   1185          
   1186                /* When RCR is loaded, the ENDRX flag is cleared so it is safe to enable the interrupt */
   1187                SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_ENDRX;
   \   000000B0   0x2008             MOVS     R0,#+8
   \   000000B2   0x....             LDR.N    R1,??DataTable15_17
   \   000000B4   0x6809             LDR      R1,[R1, #+0]
   \   000000B6   0x6809             LDR      R1,[R1, #+0]
   \   000000B8   0x6088             STR      R0,[R1, #+8]
   1188                
   1189                /* Enable the receiver and transmitter to start the transfer */
   1190                SSP_psCurrentSsp->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \   000000BA   0xF240 0x1001      MOVW     R0,#+257
   \   000000BE   0x....             LDR.N    R1,??DataTable15_17
   \   000000C0   0x6809             LDR      R1,[R1, #+0]
   \   000000C2   0x6809             LDR      R1,[R1, #+0]
   \   000000C4   0xF8C1 0x0120      STR      R0,[R1, #+288]
   \   000000C8   0xE06D             B.N      ??SspSM_Idle_1
   1191                
   1192              } /* End of receive function */
   1193              else
   1194              {
   1195                /* Transmitting: update the message's status and flag that the peripheral is now busy */
   1196                UpdateMessageStatus(SSP_psCurrentSsp->psTransmitBuffer->u32Token, SENDING);
   \                     ??SspSM_Idle_3: (+1)
   \   000000CA   0x2102             MOVS     R1,#+2
   \   000000CC   0x....             LDR.N    R0,??DataTable15_17
   \   000000CE   0x6800             LDR      R0,[R0, #+0]
   \   000000D0   0x6AC0             LDR      R0,[R0, #+44]
   \   000000D2   0x6800             LDR      R0,[R0, #+0]
   \   000000D4   0x.... 0x....      BL       UpdateMessageStatus
   1197                SSP_psCurrentSsp->u32PrivateFlags |= _SSP_PERIPHERAL_TX;    
   \   000000D8   0x....             LDR.N    R0,??DataTable15_17
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x6900             LDR      R0,[R0, #+16]
   \   000000DE   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   000000E2   0x....             LDR.N    R1,??DataTable15_17
   \   000000E4   0x6809             LDR      R1,[R1, #+0]
   \   000000E6   0x6108             STR      R0,[R1, #+16]
   1198                
   1199                /* TRANSMIT SPI_SSP_SLAVE_FLOW_CONTROL */ 
   1200                if(SSP_psCurrentSsp->eSspMode == SSP_SLAVE_FLOW_CONTROL)
   \   000000E8   0x....             LDR.N    R0,??DataTable15_17
   \   000000EA   0x6800             LDR      R0,[R0, #+0]
   \   000000EC   0x7B40             LDRB     R0,[R0, #+13]
   \   000000EE   0x2803             CMP      R0,#+3
   \   000000F0   0xD13B             BNE.N    ??SspSM_Idle_4
   1201                {
   1202                  /* A Slave device with flow control uses interrupt-driven single byte transfers.
   1203                  CS must be asserted for the Slave to have queued data to get to here. */
   1204          
   1205                  /* Load in the message parameters. */
   1206                  SSP_psCurrentSsp->u32CurrentTxBytesRemaining = SSP_psCurrentSsp->psTransmitBuffer->u32Size;
   \   000000F2   0x....             LDR.N    R0,??DataTable15_17
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x6AC0             LDR      R0,[R0, #+44]
   \   000000F8   0x6840             LDR      R0,[R0, #+4]
   \   000000FA   0x....             LDR.N    R1,??DataTable15_17
   \   000000FC   0x6809             LDR      R1,[R1, #+0]
   \   000000FE   0x6308             STR      R0,[R1, #+48]
   1207                  SSP_psCurrentSsp->pu8CurrentTxData = SSP_psCurrentSsp->psTransmitBuffer->pu8Message;
   \   00000100   0x....             LDR.N    R0,??DataTable15_17
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x6AC0             LDR      R0,[R0, #+44]
   \   00000106   0x3008             ADDS     R0,R0,#+8
   \   00000108   0x....             LDR.N    R1,??DataTable15_17
   \   0000010A   0x6809             LDR      R1,[R1, #+0]
   \   0000010C   0x6348             STR      R0,[R1, #+52]
   1208          
   1209                  /* If we need LSB first, use inline assembly to flip bits with a single instruction. */
   1210                  u32Byte = 0x000000FF & *SSP_psCurrentSsp->pu8CurrentTxData;
   \   0000010E   0x....             LDR.N    R0,??DataTable15_17
   \   00000110   0x6800             LDR      R0,[R0, #+0]
   \   00000112   0x6B40             LDR      R0,[R0, #+52]
   \   00000114   0x7800             LDRB     R0,[R0, #+0]
   \   00000116   0x0004             MOVS     R4,R0
   1211                  if(SSP_psCurrentSsp->eBitOrder == SSP_LSB_FIRST)
   \   00000118   0x....             LDR.N    R0,??DataTable15_17
   \   0000011A   0x6800             LDR      R0,[R0, #+0]
   \   0000011C   0x7B00             LDRB     R0,[R0, #+12]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD103             BNE.N    ??SspSM_Idle_5
   1212                  {
   1213                    u32Byte = __RBIT(u32Byte)>>24;
   \   00000122   0xFA94 0xF0A4      RBIT     R0,R4
   \   00000126   0x0E00             LSRS     R0,R0,#+24
   \   00000128   0x0004             MOVS     R4,R0
   1214                  }
   1215                  
   1216                  /* This driver assumes half-duplex comms, so disable RX interrupt for now */
   1217                  SSP_psCurrentSsp->pBaseAddress->US_IDR = AT91C_US_RXRDY;
   \                     ??SspSM_Idle_5: (+1)
   \   0000012A   0x2001             MOVS     R0,#+1
   \   0000012C   0x....             LDR.N    R1,??DataTable15_17
   \   0000012E   0x6809             LDR      R1,[R1, #+0]
   \   00000130   0x6809             LDR      R1,[R1, #+0]
   \   00000132   0x60C8             STR      R0,[R1, #+12]
   1218                  
   1219                  /* Reset the transmitter since we have not been managing dummy bytes and it tends to be
   1220                  in the middle of a transmission or something that causes the wrong byte to get sent (at least on startup). */
   1221                  SSP_psCurrentSsp->pBaseAddress->US_CR = (AT91C_US_RSTTX);
   \   00000134   0x2008             MOVS     R0,#+8
   \   00000136   0x....             LDR.N    R1,??DataTable15_17
   \   00000138   0x6809             LDR      R1,[R1, #+0]
   \   0000013A   0x6809             LDR      R1,[R1, #+0]
   \   0000013C   0x6008             STR      R0,[R1, #+0]
   1222                  SSP_psCurrentSsp->pBaseAddress->US_CR = (AT91C_US_TXEN);
   \   0000013E   0x2040             MOVS     R0,#+64
   \   00000140   0x....             LDR.N    R1,??DataTable15_17
   \   00000142   0x6809             LDR      R1,[R1, #+0]
   \   00000144   0x6809             LDR      R1,[R1, #+0]
   \   00000146   0x6008             STR      R0,[R1, #+0]
   1223                  SSP_psCurrentSsp->pBaseAddress->US_THR = (u8)u32Byte;
   \   00000148   0x0020             MOVS     R0,R4
   \   0000014A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000014C   0x....             LDR.N    R1,??DataTable15_17
   \   0000014E   0x6809             LDR      R1,[R1, #+0]
   \   00000150   0x6809             LDR      R1,[R1, #+0]
   \   00000152   0x61C8             STR      R0,[R1, #+28]
   1224                  SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_TXEMPTY;
   \   00000154   0xF44F 0x7000      MOV      R0,#+512
   \   00000158   0x....             LDR.N    R1,??DataTable15_17
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0x6809             LDR      R1,[R1, #+0]
   \   0000015E   0x6088             STR      R0,[R1, #+8]
   1225                  
   1226                  /* Trigger the callback which should provide flow-control to start transmitting */
   1227                  SSP_psCurrentSsp->fnSlaveTxFlowCallback();
   \   00000160   0x....             LDR.N    R0,??DataTable15_17
   \   00000162   0x6800             LDR      R0,[R0, #+0]
   \   00000164   0x6940             LDR      R0,[R0, #+20]
   \   00000166   0x4780             BLX      R0
   \   00000168   0xE01D             B.N      ??SspSM_Idle_1
   1228                }
   1229                
   1230                /* TRANSMIT SSP_MASTER_AUTO_CS, SSP_MASTER_MANUAL_CS, SSP_SLAVE (no flow control) */
   1231                /* A Master or Slave device without flow control uses the PDC */
   1232                else
   1233                {
   1234                  /* Load the PDC counter and pointer registers.  The "Next" pointers are never changed and will
   1235                  always point to SSP_u8Dummies with length 1.  */
   1236                  SSP_psCurrentSsp->pBaseAddress->US_TPR = (unsigned int)SSP_psCurrentSsp->psTransmitBuffer->pu8Message; 
   \                     ??SspSM_Idle_4: (+1)
   \   0000016A   0x....             LDR.N    R0,??DataTable15_17
   \   0000016C   0x6800             LDR      R0,[R0, #+0]
   \   0000016E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000170   0x3008             ADDS     R0,R0,#+8
   \   00000172   0x....             LDR.N    R1,??DataTable15_17
   \   00000174   0x6809             LDR      R1,[R1, #+0]
   \   00000176   0x6809             LDR      R1,[R1, #+0]
   \   00000178   0xF8C1 0x0108      STR      R0,[R1, #+264]
   1237                  SSP_psCurrentSsp->pBaseAddress->US_TCR = SSP_psCurrentSsp->psTransmitBuffer->u32Size;
   \   0000017C   0x....             LDR.N    R0,??DataTable15_17
   \   0000017E   0x6800             LDR      R0,[R0, #+0]
   \   00000180   0x6AC0             LDR      R0,[R0, #+44]
   \   00000182   0x6840             LDR      R0,[R0, #+4]
   \   00000184   0x....             LDR.N    R1,??DataTable15_17
   \   00000186   0x6809             LDR      R1,[R1, #+0]
   \   00000188   0x6809             LDR      R1,[R1, #+0]
   \   0000018A   0xF8C1 0x010C      STR      R0,[R1, #+268]
   1238             
   1239                  /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
   1240                  SSP_psCurrentSsp->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \   0000018E   0x2010             MOVS     R0,#+16
   \   00000190   0x....             LDR.N    R1,??DataTable15_17
   \   00000192   0x6809             LDR      R1,[R1, #+0]
   \   00000194   0x6809             LDR      R1,[R1, #+0]
   \   00000196   0x6088             STR      R0,[R1, #+8]
   1241                  
   1242                  /* Enable the transmitter to start the transfer */
   1243                  SSP_psCurrentSsp->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \   00000198   0xF44F 0x7080      MOV      R0,#+256
   \   0000019C   0x....             LDR.N    R1,??DataTable15_17
   \   0000019E   0x6809             LDR      R1,[R1, #+0]
   \   000001A0   0x6809             LDR      R1,[R1, #+0]
   \   000001A2   0xF8C1 0x0120      STR      R0,[R1, #+288]
   1244                }
   1245              } /* End of transmitting function */
   1246            }
   1247            
   1248            /* Adjust to check the next peripheral next time through */
   1249            switch (SSP_psCurrentSsp->u8PeripheralId)
   \                     ??SspSM_Idle_1: (+1)
   \   000001A6   0x....             LDR.N    R0,??DataTable15_17
   \   000001A8   0x6800             LDR      R0,[R0, #+0]
   \   000001AA   0xF890 0x0028      LDRB     R0,[R0, #+40]
   \   000001AE   0x280D             CMP      R0,#+13
   \   000001B0   0xD004             BEQ.N    ??SspSM_Idle_6
   \   000001B2   0xD315             BCC.N    ??SspSM_Idle_7
   \   000001B4   0x280F             CMP      R0,#+15
   \   000001B6   0xD009             BEQ.N    ??SspSM_Idle_8
   \   000001B8   0xD304             BCC.N    ??SspSM_Idle_9
   \   000001BA   0xE011             B.N      ??SspSM_Idle_7
   1250            {
   1251              case AT91C_ID_US0:
   1252                SSP_psCurrentSsp = &SSP_Peripheral1;
   \                     ??SspSM_Idle_6: (+1)
   \   000001BC   0x....             LDR.N    R0,??DataTable15_4
   \   000001BE   0x....             LDR.N    R1,??DataTable15_17
   \   000001C0   0x6008             STR      R0,[R1, #+0]
   1253                break;
   \   000001C2   0xE013             B.N      ??SspSM_Idle_10
   1254          
   1255              case AT91C_ID_US1:
   1256                SSP_psCurrentSsp = &SSP_Peripheral2;
   \                     ??SspSM_Idle_9: (+1)
   \   000001C4   0x....             LDR.N    R0,??DataTable15_6
   \   000001C6   0x....             LDR.N    R1,??DataTable15_17
   \   000001C8   0x6008             STR      R0,[R1, #+0]
   1257                break;
   \   000001CA   0xE00F             B.N      ??SspSM_Idle_10
   1258          
   1259              case AT91C_ID_US2:
   1260                SSP_psCurrentSsp = &SSP_Peripheral0;
   \                     ??SspSM_Idle_8: (+1)
   \   000001CC   0x....             LDR.N    R0,??DataTable15_3
   \   000001CE   0x....             LDR.N    R1,??DataTable15_17
   \   000001D0   0x6008             STR      R0,[R1, #+0]
   1261                SSP_u32Flags &= ~_SSP_MANUAL_MODE;
   \   000001D2   0x....             LDR.N    R0,??DataTable15_18
   \   000001D4   0x6800             LDR      R0,[R0, #+0]
   \   000001D6   0x0840             LSRS     R0,R0,#+1
   \   000001D8   0x0040             LSLS     R0,R0,#+1
   \   000001DA   0x....             LDR.N    R1,??DataTable15_18
   \   000001DC   0x6008             STR      R0,[R1, #+0]
   1262                break;
   \   000001DE   0xE005             B.N      ??SspSM_Idle_10
   1263          
   1264              default:
   1265                DebugPrintf("Invalid SSP attempt\r\n");
   \                     ??SspSM_Idle_7: (+1)
   \   000001E0   0x....             LDR.N    R0,??DataTable15_33
   \   000001E2   0x.... 0x....      BL       DebugPrintf
   1266                SSP_psCurrentSsp = &SSP_Peripheral0;
   \   000001E6   0x....             LDR.N    R0,??DataTable15_3
   \   000001E8   0x....             LDR.N    R1,??DataTable15_17
   \   000001EA   0x6008             STR      R0,[R1, #+0]
   1267                break;
   1268            } /* end switch */
   1269            
   1270          } /* end SspSM_Idle() */
   \                     ??SspSM_Idle_10: (+1)
   \   000001EC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     SSP_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     SSP_Peripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x004518CE         DC32     0x4518ce

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x........         DC32     SSP_Peripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x004118FF         DC32     0x4118ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x........         DC32     SSP_u8Dummies

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_10:
   \   00000000   0x00080018         DC32     0x80018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_11:
   \   00000000   0x........         DC32     Ssp_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_12:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_13:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_14:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_15:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_16:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_17:
   \   00000000   0x........         DC32     SSP_psCurrentSsp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_18:
   \   00000000   0x........         DC32     SSP_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_19:
   \   00000000   0x........         DC32     G_u32Ssp0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_20:
   \   00000000   0x........         DC32     G_u32Ssp1ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_21:
   \   00000000   0x........         DC32     G_u32Ssp2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_22:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_23:
   \   00000000   0xA5000001         DC32     0xa5000001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_24:
   \   00000000   0x400E1250         DC32     0x400e1250

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_25:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_26:
   \   00000000   0x........         DC32     SSP_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_27:
   \   00000000   0x........         DC32     SSP_pu32SspApplicationFlagsISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_28:
   \   00000000   0x........         DC32     SSP_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_29:
   \   00000000   0x........         DC32     SSP_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_30:
   \   00000000   0x........         DC32     SSP_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_31:
   \   00000000   0x........         DC32     SSP_u32AntCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_32:
   \   00000000   0x........         DC32     SSP_u32RxCounter

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_33:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0D 0x0A          DC8 "\015\012SSP message too large\012\015"
   \              0x53 0x53    
   \              0x50 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x61    
   \              0x72 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x53 0x53          DC8 "SSP Peripherals Ready\012\015"
   \              0x50 0x20    
   \              0x50 0x65    
   \              0x72 0x69    
   \              0x70 0x68    
   \              0x65 0x72    
   \              0x61 0x6C    
   \              0x73 0x20    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x79 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x49 0x6E          DC8 "Invalid SSP attempt\015\012"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x53 0x53    
   \              0x50 0x20    
   \              0x61 0x74    
   \              0x74 0x65    
   \              0x6D 0x70    
   \              0x74 0x0D    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0
   1271          
   1272          
   1273          #if 0
   1274          /*!-------------------------------------------------------------------------------------------------------------------
   1275          @fn static void SspSM_Error(void)          
   1276          
   1277          @brief Handle an error 
   1278          
   1279          */
   1280          static void SspSM_Error(void)          
   1281          {
   1282            Ssp_pfnStateMachine = SspSM_Idle;
   1283            
   1284          } /* end SspSM_Error() */
   1285          #endif
   1286                  
   1287          
   1288          
   1289          
   1290          
   1291          /*--------------------------------------------------------------------------------------------------------------------*/
   1292          /* End of File */
   1293          /*--------------------------------------------------------------------------------------------------------------------*/
   1294          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   SSP0_IRQHandler
         8   -> SspGenericHandler
       0   SspAssertCS
       0   SspDeAssertCS
      16   SspGenericHandler
        16   -- Indirect call
        16   -> DeQueueMessage
        16   -> UpdateMessageStatus
       8   SspInitialize
         8   -> DebugPrintf
       8   SspManualMode
         8   -- Indirect call
         8   -> IsTimeUp
         8   -> MessagingRunActiveState
       0   SspQueryReceiveStatus
       0   SspReadByte
      16   SspReadData
        16   -> DebugPrintf
       8   SspRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   SspRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   SspRunActiveState
         8   -- Indirect call
      24   SspSM_Idle
        24   -- Indirect call
        24   -> DebugPrintf
        24   -> UpdateMessageStatus
        24   -> __aeabi_memset
      24   SspWriteByte
        24   -> QueueMessage
        24   -> SspManualMode
      24   SspWriteData
        24   -> QueueMessage
        24   -> SspManualMode
       8   USART1_IrqHandler
         8   -> SspGenericHandler
       8   USART2_IrqHandler
         8   -> SspGenericHandler


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_10
       4  ??DataTable15_11
       4  ??DataTable15_12
       4  ??DataTable15_13
       4  ??DataTable15_14
       4  ??DataTable15_15
       4  ??DataTable15_16
       4  ??DataTable15_17
       4  ??DataTable15_18
       4  ??DataTable15_19
       4  ??DataTable15_2
       4  ??DataTable15_20
       4  ??DataTable15_21
       4  ??DataTable15_22
       4  ??DataTable15_23
       4  ??DataTable15_24
       4  ??DataTable15_25
       4  ??DataTable15_26
       4  ??DataTable15_27
       4  ??DataTable15_28
       4  ??DataTable15_29
       4  ??DataTable15_3
       4  ??DataTable15_30
       4  ??DataTable15_31
       4  ??DataTable15_32
       4  ??DataTable15_33
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
      28  ?_0
      24  ?_1
      24  ?_2
       4  G_u32Ssp0ApplicationFlags
       4  G_u32Ssp1ApplicationFlags
       4  G_u32Ssp2ApplicationFlags
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      42  SSP0_IRQHandler
      56  SSP_Peripheral0
      56  SSP_Peripheral1
      56  SSP_Peripheral2
       4  SSP_psCurrentISR
       4  SSP_psCurrentSsp
       4  SSP_pu32SspApplicationFlagsISR
       4  SSP_u32AntCounter
       4  SSP_u32Flags
       4  SSP_u32Int0Count
       4  SSP_u32Int1Count
       4  SSP_u32Int2Count
       4  SSP_u32RxCounter
       1  SSP_u8Dummies
      14  SspAssertCS
      14  SspDeAssertCS
    1140  SspGenericHandler
     268  SspInitialize
      84  SspManualMode
      60  SspQueryReceiveStatus
      42  SspReadByte
      62  SspReadData
      98  SspRelease
     364  SspRequest
      12  SspRunActiveState
     494  SspSM_Idle
      58  SspWriteByte
      58  SspWriteData
       4  Ssp_pfnStateMachine
      42  USART1_IrqHandler
      42  USART2_IrqHandler

 
   221 bytes in section .bss
    76 bytes in section .rodata
 3 096 bytes in section .text
 
 3 096 bytes of CODE  memory
    76 bytes of CONST memory
   221 bytes of DATA  memory

Errors: none
Warnings: none
